<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Github的Typora图床</title>
    <url>/2022/10/07/Githubed/</url>
    <content><![CDATA[<p><strong>考虑到有部分人没有服务器，所以这里用免费的github作为图床</strong></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>安装好 <em>Typora</em> ： <a href="https://pan.xunlei.com/s/VNB_VLRHiLk6wUoyXr4mCWM6A1">提取码：h9bb</a>    <em>PicGo</em>  ：<a href="https://pan.xunlei.com/s/VNB_WALBOdxS0Hkp49VZlZT_A1">提取码：k77e</a></li>
<li><em>Gitee</em> 账户：<a href="https://github.com/">https://github.com/</a></li>
</ul>
<h2 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h2><h3 id="使用Github作为图床"><a href="#使用Github作为图床" class="headerlink" title="使用Github作为图床"></a>使用Github作为图床</h3><p><strong>1.新建一个仓库</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007215042471.png" alt="image-20221007215042471" style="zoom:50%;" />

<p><strong>2.设置好仓库名 仓库为开放状态 并且添加README文件</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007215229045.png" alt="image-20221007215229045" style="zoom:50%;" />

<p><strong>3.获取Token（记得备份）</strong></p>
<p>创建一个token，依次选择<code>Settings —&gt; Developer settings—&gt; Personal access tokens</code>，点击<code>Generate new token</code>创建token。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007215855658.png" alt="image-20221007215855658" style="zoom:67%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007220120150.png" alt="image-20221007220120150" style="zoom:67%;" />

<h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p><strong>1.自定义安装PicGo，首先选择“PicGo设置”，点击“设置Server”，开启Server，设置监听地址为主机127.0.0.1，端口号为36677</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/PicGo%E9%85%8D%E7%BD%AE-1.png" alt="image-20221007220311253" style="zoom:50%;" />

<p><strong>2.建议将“时间戳重命名”开启（也可以将上传前重命名开启，自己命名图片名称。这里重命名优先权大于时间命名），避免上传图片重名</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210072205359.png" alt="image-20221007220545297" style="zoom:50%;" />

<p><strong>3. 选择“图床设置”—&gt;“GitHub图床”，进行设置</strong></p>
<p>仓库名： 使用 用户名 + 仓库名</p>
<p>分支名： 默认为master或main（看仓库具体分支是什么）</p>
<p>token： 使用上述创建的token</p>
<p>存储路径：这里使用上述创建仓库的img目录</p>
<p>自定义域名：不必填，默认格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://raw.githubusercontent.com/[用户名]/[仓库名]/master</span><br></pre></td></tr></table></figure>

<p>但是自己平常访问Github经常404的话建议改为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/cdn.jsdelivr.net/gh</span><span class="regexp">/用户名/</span>仓库名/文件路径</span><br></pre></td></tr></table></figure>

<p>对于使用存储在GitHub上面的<strong>静态文件</strong>，可使用jsDelivr CDN快速访问</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210072207463.png" alt="image-20221007220730401" style="zoom:50%;" />

<p><strong>测试文件保存成功</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210072210888.png" alt="image-20221007221015835"></p>
<h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h3><ul>
<li>点击 <code>文件</code>-&gt;  <code>偏好设置</code> -&gt; <code>图像</code></li>
</ul>
<p><img src="https://dreamin-1312842512.cos.ap-guangzhou.myqcloud.com/image-20220910163202939.png" alt="image-20220910163202939"></p>
<ul>
<li>如上图配置即可使用</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/haojie_duan/article/details/120400386">https://blog.csdn.net/haojie_duan/article/details/120400386</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1834573">https://cloud.tencent.com/developer/article/1834573</a></p>
</li>
<li><p><a href="https://juejin.cn/post/7099811254864674823">https://juejin.cn/post/7099811254864674823</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>Http基础</title>
    <url>/2022/09/12/Http/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h4 id="Http及Https概念"><a href="#Http及Https概念" class="headerlink" title="Http及Https概念"></a><em>Http</em>及<em>Https</em>概念</h4><p>1.超文本传输协议（<em>HyperText Transfer Protocol</em> 即<em>http</em>）是一种用于分布式、协作式和超媒体信息系统的应用层协议，所有的www文件都必须遵守这个标准和协议。</p>
<p>2.<em>http</em>是为了<em>Web</em>浏览器与<em>Web</em>服务器之间的通信而设计的，基于<em>TCP&#x2F;IP</em>通信协议来传递数据。</p>
<p>3.超文本传输安全协议（<em>HyperText Transfer Protocol Secure</em>即<em>https</em>）是一种通过计算机网络进行安全通信的传输协议。</p>
<p>4.<em>https</em>经由<em>http</em>进行通信，但利用<em>SS&#x2F;TLS</em>来加密数据包，所以开发的主要目的是提供对网络服务器的身份认证，保护交换资料的隐私与完整性。</p>
<p>5.<em>Http</em>的<em>URL</em>是由<code>http://</code>起始与默认使用端口<strong>80</strong>，<em>Https</em>的<em>URL</em>则是由<code>https://</code>起始与默认使用端口<strong>443</strong>。</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205712842.png" alt="image-20221005205712842"></p>
<h4 id="Http工作原理"><a href="#Http工作原理" class="headerlink" title="Http工作原理"></a><em>Http</em>工作原理</h4><p>1.它是工作于客户端以及服务器端的架构之上。</p>
<p>2.浏览器作为<em>http</em>客户端通过<em>URL</em>向<em>http</em>服务端即<em>Web</em>服务器发送所有请求。</p>
<p>3.服务器有：<em>Apache</em>服务器，<em>IIS</em>服务器（<em>Internet Information Services</em>）为主。</p>
<p>4.<em>Web</em>服务器根据接收到的请求后，想客户端发送响应信息。</p>
<p>5.<em>http</em>默认端口号为80,可以改为8080或者其他端口。</p>
<p><strong>三点注意事项</strong></p>
<ul>
<li><p><em>http</em>是无连接的：<em>无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</em></p>
</li>
<li><p><em>http</em>是媒体独立：<em>这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送，客户端以及服务器指定使用适合的 MIME-type 内容类型。</em></p>
</li>
<li><p><em>http</em>是无状态的：<em>HTTP 协议是无状态协议，无状态是指协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大，另一方面，在服务器不需要先前信息时它的应答就较快。</em></p>
</li>
</ul>
<p><strong>通信流程</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/cgiarch.gif" alt="cgiarch"></p>
<h4 id="Https作用"><a href="#Https作用" class="headerlink" title="Https作用"></a><em>Https</em>作用</h4><p>主要作用是在不安全的网络上建立一个安全通道，并在可使用适当的加密包和服务器证书时可被验证且可被信任时，对窃听人和中间人攻击时提供合理的防护。</p>
<p><em>http</em>的信任基于预先安装在操作系统中的证书颁发机构（<em>CA</em>）。</p>
<p>证书仅在一下情况可被信任：</p>
<ul>
<li>浏览器正确的实现了<em>https</em>且操作系统中安装了正确且受信任的证书颁发机构。</li>
<li>证书颁发机构进信任合法的网站。</li>
<li>被访问的网站提供了一个有效的证书，也就是说它是由一个操作系统信任的证书颁发机构签发的。</li>
<li>此证书正确验证了被访问的网站。</li>
<li>此协议的加密层（<em>SSL&#x2F;TLS</em>）能够有效的地提供认证和高强度的加密。</li>
</ul>
<h4 id="Http消息结构"><a href="#Http消息结构" class="headerlink" title="Http消息结构"></a><em>Http</em>消息结构</h4><p>1.<em>http</em>是基于客户端&#x2F;服务端（<em>C&#x2F;S</em>）的架构模型，通过一个可靠的链接来交换信息，是一个无转态的请求&#x2F;响应协议。</p>
<ul>
<li>“客户端”是一个应用程序（<em>Web</em>浏览器），通过连接到服务器大到向服务器发送一个或多个<em>HTTP</em>的请求的目的。</li>
<li>“服务端”是一个应用程序（<em>Apache Web</em>服务器或<em>IIS</em>服务器等），通过接收客户端的请求并向客户端发送<em>HTTP</em>响应数据。</li>
</ul>
<p>2.<em>Http</em>使用统一的资源标识符（<em>Uniform Resource Identifiers, URI</em>）来传输数据和建议连接。</p>
<p>3.一旦建立连接，数据消息就通过类似<em>Internet</em>邮件所使用的格式和多功能邮件扩展来传送。</p>
<h4 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h4><p><strong>客户端发送一个<em>http</em>请求到服务器的请求消息包括一下格式：请求行（<em>request line</em>）、请求头部（header）、空行和请求数据四个部分组成</strong></p>
<p><em><strong>一般格式：</strong></em></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png" alt="img"></p>
<h4 id="服务端响应消息"><a href="#服务端响应消息" class="headerlink" title="服务端响应消息"></a>服务端响应消息</h4><p><strong><em>http</em>响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg" alt="img"></p>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><em>客户端请求</em></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">GET</span> /hello.txt HTTP/<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">User</span>-Agent: curl/<span class="number">7</span>.<span class="number">16</span>.<span class="number">3</span> libcurl/<span class="number">7</span>.<span class="number">16</span>.<span class="number">3</span> OpenSSL/<span class="number">0</span>.<span class="number">9</span>.<span class="number">7</span>l zlib/<span class="number">1</span>.<span class="number">2</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">Host</span>: www.example.com</span><br><span class="line"><span class="attribute">Accept</span>-Language: en, mi</span><br></pre></td></tr></table></figure>

<p><em>服务端响应</em></p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;34aa387-d-1568eb00&quot;</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>51</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br></pre></td></tr></table></figure>

<p><em>输出结果</em></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Hello World! My payload includes <span class="keyword">a</span> trailing <span class="literal">CRLF</span>.</span><br></pre></td></tr></table></figure>

<h4 id="Http请求方法"><a href="#Http请求方法" class="headerlink" title="Http请求方法"></a><em>Http</em>请求方法</h4><p><em>http1.0</em>定义了三种请求方法：<em>GET</em>，<em>POST</em>和<em>HEAD</em>方法。</p>
<p><em>http1.1</em>新增了六种请求方法：<em>OPTIONS</em>、<em>PUT</em>、<em>PATCH</em>、<em>DELETE</em>、<em>TRACE</em>和<em>CONNECT</em>方法。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><em>GET</em></td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>2</td>
<td><em>HEAD</em></td>
<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>3</td>
<td><em>POST</em></td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>
</tr>
<tr>
<td>4</td>
<td><em>PUT</em></td>
<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td>5</td>
<td><em>DELETE</em></td>
<td>请求服务器删除指定的页面。</td>
</tr>
<tr>
<td>6</td>
<td><em>CONNECT</em></td>
<td><em>HTTP&#x2F;1.1</em> 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>7</td>
<td><em>OPTIONS</em></td>
<td>允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td>8</td>
<td><em>TRACE</em></td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>9</td>
<td><em>PATCH</em></td>
<td>是对<em>PUT</em>方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
<h4 id="Http响应头消息"><a href="#Http响应头消息" class="headerlink" title="Http响应头消息"></a><em>Http</em>响应头消息</h4><table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法（如GET、POST等）。</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">表示后面的文档属于什么MIME类型。Servlet默认为text&#x2F;plain，但通常需要显式地指定为text&#x2F;html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">应该在什么时候认为文档已经过期，从而不再缓存它？</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL&#x3D;<a href="http://host/path&quot;)%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82">http://host/path&quot;)让浏览器读取指定的页面。</a> 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV&#x3D;”Refresh” CONTENT&#x3D;”5;URL&#x3D;<a href="http://host/path&quot;%EF%BC%9E%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%E6%88%96%E9%87%8D%E5%AE%9A%E5%90%91%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8CGI%E6%88%96Servlet%E7%9A%84HTML%E7%BC%96%E5%86%99%E8%80%85%E5%8D%81%E5%88%86%E9%87%8D%E8%A6%81%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8C%E5%AF%B9%E4%BA%8EServlet%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%9B%B4%E6%8E%A5%E8%AE%BE%E7%BD%AERefresh%E5%A4%B4%E6%9B%B4%E5%8A%A0%E6%96%B9%E4%BE%BF%E3%80%82">http://host/path&quot;＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。</a>  注意Refresh的意义是”N秒之后刷新本页面或访问指定页面”，而不是”每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV&#x3D;”Refresh” …＞。  注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm&#x3D;＼”executives＼””)。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</td>
</tr>
</tbody></table>
<h4 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a><em>Http</em>状态码</h4><p>当浏览访问一个网页时，浏览者的浏览器会向网页所在服务器请求。当浏览器接收并显示网页前，此网页所在服务器会返回一个包含<em>HTTP</em>状态码的信息头（<em>server header</em>）用以响应浏览器的请求。</p>
<p>常见的<em>HTTP</em>状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 网页资源被永久转移到其它<em>URL</em></li>
<li>404 - 请求的网页资源不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h5 id="Http状态码分类"><a href="#Http状态码分类" class="headerlink" title="Http状态码分类"></a><em>Http</em>状态码分类</h5><p><em>Http</em>状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应（100-199），成功响应（200-299），重定向（300-399），客户端错误（400-499）和服务器错误（500-599）。</p>
<p><em>Http</em>状态码列表</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h4 id="Http内容类型"><a href="#Http内容类型" class="headerlink" title="Http内容类型"></a><em>Http</em>内容类型</h4><p><em>Content-Type</em>（内容类型），一般是指网页中存在的<em>content-type</em>，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式，什么编码来读取这个文件，这就是经常看到的一些<em>PHP</em>网页点击的结果却是下载一个文件或一张图片的原因。</p>
<p>content-type标头告诉客户端实际返回的内容的内容类型。例</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Content-<span class="keyword">Type</span>: text/html;charset=utf-<span class="number">8</span></span><br><span class="line">Content-<span class="keyword">Type</span>: multipart/<span class="keyword">form</span>-<span class="keyword">data</span>;boundary=something</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\mua\AppData\Roaming\Typora\typora-user-images\image-20220909182611661.png" alt="image-20220909182611661"></p>
<p><strong>常用的媒体格式类型如下：</strong></p>
<ul>
<li>text&#x2F;html ： <em>HTML</em>格式</li>
<li>text&#x2F;plain：纯文本格式</li>
<li>text&#x2F;xml：<em>XML</em>格式</li>
<li>image&#x2F;gif：<em>gif</em>图片格式</li>
<li>image&#x2F;jpeg：<em>jpg</em>图片格式</li>
<li>image&#x2F;png：<em>png</em>图片格式</li>
</ul>
<p><strong>以<em>application</em>开头的媒体格式类型：</strong></p>
<ul>
<li>application&#x2F;xhtml+xml：<em>XHTML</em>格式</li>
<li>application&#x2F;xml：<em>XML</em>数据格式</li>
<li>application&#x2F;atom+xml：<em>Atom XML</em>聚合格式</li>
<li>application&#x2F;json：<em>JSON</em>数据格式</li>
<li>application&#x2F;msword：<em>Word</em>格式</li>
<li>application&#x2F;pdf ： <em>pdf</em>格式</li>
<li>application&#x2F;octet-stream：二进制流数据</li>
<li>application&#x2F;x-www-form-urlencoded：<form encType=""> 中默认的encType，form表单数据被编码为<em>key&#x2F;value</em>格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p><strong>一种常见的上传文件之时使用的媒体格式：</strong></p>
<ul>
<li>multipart&#x2F;form-data：需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<h5 id="content-type对照表"><a href="#content-type对照表" class="headerlink" title="content-type对照表"></a>content-type对照表</h5><table>
<thead>
<tr>
<th align="left">文件扩展名</th>
<th align="left">Content-Type(Mime-Type)</th>
<th align="left">文件扩展名</th>
<th align="left">Content-Type(Mime-Type)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.*（ 二进制流，不知道下载文件类型）</td>
<td align="left">application&#x2F;octet-stream</td>
<td align="left">.tif</td>
<td align="left">image&#x2F;tiff</td>
</tr>
<tr>
<td align="left">.001</td>
<td align="left">application&#x2F;x-001</td>
<td align="left">.301</td>
<td align="left">application&#x2F;x-301</td>
</tr>
<tr>
<td align="left">.323</td>
<td align="left">text&#x2F;h323</td>
<td align="left">.906</td>
<td align="left">application&#x2F;x-906</td>
</tr>
<tr>
<td align="left">.907</td>
<td align="left">drawing&#x2F;907</td>
<td align="left">.a11</td>
<td align="left">application&#x2F;x-a11</td>
</tr>
<tr>
<td align="left">.acp</td>
<td align="left">audio&#x2F;x-mei-aac</td>
<td align="left">.ai</td>
<td align="left">application&#x2F;postscript</td>
</tr>
<tr>
<td align="left">.aif</td>
<td align="left">audio&#x2F;aiff</td>
<td align="left">.aifc</td>
<td align="left">audio&#x2F;aiff</td>
</tr>
<tr>
<td align="left">.aiff</td>
<td align="left">audio&#x2F;aiff</td>
<td align="left">.anv</td>
<td align="left">application&#x2F;x-anv</td>
</tr>
<tr>
<td align="left">.asa</td>
<td align="left">text&#x2F;asa</td>
<td align="left">.asf</td>
<td align="left">video&#x2F;x-ms-asf</td>
</tr>
<tr>
<td align="left">.asp</td>
<td align="left">text&#x2F;asp</td>
<td align="left">.asx</td>
<td align="left">video&#x2F;x-ms-asf</td>
</tr>
<tr>
<td align="left">.au</td>
<td align="left">audio&#x2F;basic</td>
<td align="left">.avi</td>
<td align="left">video&#x2F;avi</td>
</tr>
<tr>
<td align="left">.awf</td>
<td align="left">application&#x2F;vnd.adobe.workflow</td>
<td align="left">.biz</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.bmp</td>
<td align="left">application&#x2F;x-bmp</td>
<td align="left">.bot</td>
<td align="left">application&#x2F;x-bot</td>
</tr>
<tr>
<td align="left">.c4t</td>
<td align="left">application&#x2F;x-c4t</td>
<td align="left">.c90</td>
<td align="left">application&#x2F;x-c90</td>
</tr>
<tr>
<td align="left">.cal</td>
<td align="left">application&#x2F;x-cals</td>
<td align="left">.cat</td>
<td align="left">application&#x2F;vnd.ms-pki.seccat</td>
</tr>
<tr>
<td align="left">.cdf</td>
<td align="left">application&#x2F;x-netcdf</td>
<td align="left">.cdr</td>
<td align="left">application&#x2F;x-cdr</td>
</tr>
<tr>
<td align="left">.cel</td>
<td align="left">application&#x2F;x-cel</td>
<td align="left">.cer</td>
<td align="left">application&#x2F;x-x509-ca-cert</td>
</tr>
<tr>
<td align="left">.cg4</td>
<td align="left">application&#x2F;x-g4</td>
<td align="left">.cgm</td>
<td align="left">application&#x2F;x-cgm</td>
</tr>
<tr>
<td align="left">.cit</td>
<td align="left">application&#x2F;x-cit</td>
<td align="left">.class</td>
<td align="left">java&#x2F;*</td>
</tr>
<tr>
<td align="left">.cml</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.cmp</td>
<td align="left">application&#x2F;x-cmp</td>
</tr>
<tr>
<td align="left">.cmx</td>
<td align="left">application&#x2F;x-cmx</td>
<td align="left">.cot</td>
<td align="left">application&#x2F;x-cot</td>
</tr>
<tr>
<td align="left">.crl</td>
<td align="left">application&#x2F;pkix-crl</td>
<td align="left">.crt</td>
<td align="left">application&#x2F;x-x509-ca-cert</td>
</tr>
<tr>
<td align="left">.csi</td>
<td align="left">application&#x2F;x-csi</td>
<td align="left">.css</td>
<td align="left">text&#x2F;css</td>
</tr>
<tr>
<td align="left">.cut</td>
<td align="left">application&#x2F;x-cut</td>
<td align="left">.dbf</td>
<td align="left">application&#x2F;x-dbf</td>
</tr>
<tr>
<td align="left">.dbm</td>
<td align="left">application&#x2F;x-dbm</td>
<td align="left">.dbx</td>
<td align="left">application&#x2F;x-dbx</td>
</tr>
<tr>
<td align="left">.dcd</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.dcx</td>
<td align="left">application&#x2F;x-dcx</td>
</tr>
<tr>
<td align="left">.der</td>
<td align="left">application&#x2F;x-x509-ca-cert</td>
<td align="left">.dgn</td>
<td align="left">application&#x2F;x-dgn</td>
</tr>
<tr>
<td align="left">.dib</td>
<td align="left">application&#x2F;x-dib</td>
<td align="left">.dll</td>
<td align="left">application&#x2F;x-msdownload</td>
</tr>
<tr>
<td align="left">.doc</td>
<td align="left">application&#x2F;msword</td>
<td align="left">.dot</td>
<td align="left">application&#x2F;msword</td>
</tr>
<tr>
<td align="left">.drw</td>
<td align="left">application&#x2F;x-drw</td>
<td align="left">.dtd</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.dwf</td>
<td align="left">Model&#x2F;vnd.dwf</td>
<td align="left">.dwf</td>
<td align="left">application&#x2F;x-dwf</td>
</tr>
<tr>
<td align="left">.dwg</td>
<td align="left">application&#x2F;x-dwg</td>
<td align="left">.dxb</td>
<td align="left">application&#x2F;x-dxb</td>
</tr>
<tr>
<td align="left">.dxf</td>
<td align="left">application&#x2F;x-dxf</td>
<td align="left">.edn</td>
<td align="left">application&#x2F;vnd.adobe.edn</td>
</tr>
<tr>
<td align="left">.emf</td>
<td align="left">application&#x2F;x-emf</td>
<td align="left">.eml</td>
<td align="left">message&#x2F;rfc822</td>
</tr>
<tr>
<td align="left">.ent</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.epi</td>
<td align="left">application&#x2F;x-epi</td>
</tr>
<tr>
<td align="left">.eps</td>
<td align="left">application&#x2F;x-ps</td>
<td align="left">.eps</td>
<td align="left">application&#x2F;postscript</td>
</tr>
<tr>
<td align="left">.etd</td>
<td align="left">application&#x2F;x-ebx</td>
<td align="left">.exe</td>
<td align="left">application&#x2F;x-msdownload</td>
</tr>
<tr>
<td align="left">.fax</td>
<td align="left">image&#x2F;fax</td>
<td align="left">.fdf</td>
<td align="left">application&#x2F;vnd.fdf</td>
</tr>
<tr>
<td align="left">.fif</td>
<td align="left">application&#x2F;fractals</td>
<td align="left">.fo</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.frm</td>
<td align="left">application&#x2F;x-frm</td>
<td align="left">.g4</td>
<td align="left">application&#x2F;x-g4</td>
</tr>
<tr>
<td align="left">.gbr</td>
<td align="left">application&#x2F;x-gbr</td>
<td align="left">.</td>
<td align="left">application&#x2F;x-</td>
</tr>
<tr>
<td align="left">.gif</td>
<td align="left">image&#x2F;gif</td>
<td align="left">.gl2</td>
<td align="left">application&#x2F;x-gl2</td>
</tr>
<tr>
<td align="left">.gp4</td>
<td align="left">application&#x2F;x-gp4</td>
<td align="left">.hgl</td>
<td align="left">application&#x2F;x-hgl</td>
</tr>
<tr>
<td align="left">.hmr</td>
<td align="left">application&#x2F;x-hmr</td>
<td align="left">.hpg</td>
<td align="left">application&#x2F;x-hpgl</td>
</tr>
<tr>
<td align="left">.hpl</td>
<td align="left">application&#x2F;x-hpl</td>
<td align="left">.hqx</td>
<td align="left">application&#x2F;mac-binhex40</td>
</tr>
<tr>
<td align="left">.hrf</td>
<td align="left">application&#x2F;x-hrf</td>
<td align="left">.hta</td>
<td align="left">application&#x2F;hta</td>
</tr>
<tr>
<td align="left">.htc</td>
<td align="left">text&#x2F;x-component</td>
<td align="left">.htm</td>
<td align="left">text&#x2F;html</td>
</tr>
<tr>
<td align="left">.html</td>
<td align="left">text&#x2F;html</td>
<td align="left">.htt</td>
<td align="left">text&#x2F;webviewhtml</td>
</tr>
<tr>
<td align="left">.htx</td>
<td align="left">text&#x2F;html</td>
<td align="left">.icb</td>
<td align="left">application&#x2F;x-icb</td>
</tr>
<tr>
<td align="left">.ico</td>
<td align="left">image&#x2F;x-icon</td>
<td align="left">.ico</td>
<td align="left">application&#x2F;x-ico</td>
</tr>
<tr>
<td align="left">.iff</td>
<td align="left">application&#x2F;x-iff</td>
<td align="left">.ig4</td>
<td align="left">application&#x2F;x-g4</td>
</tr>
<tr>
<td align="left">.igs</td>
<td align="left">application&#x2F;x-igs</td>
<td align="left">.iii</td>
<td align="left">application&#x2F;x-iphone</td>
</tr>
<tr>
<td align="left">.img</td>
<td align="left">application&#x2F;x-img</td>
<td align="left">.ins</td>
<td align="left">application&#x2F;x-internet-signup</td>
</tr>
<tr>
<td align="left">.isp</td>
<td align="left">application&#x2F;x-internet-signup</td>
<td align="left">.IVF</td>
<td align="left">video&#x2F;x-ivf</td>
</tr>
<tr>
<td align="left">.java</td>
<td align="left">java&#x2F;*</td>
<td align="left">.jfif</td>
<td align="left">image&#x2F;jpeg</td>
</tr>
<tr>
<td align="left">.jpe</td>
<td align="left">image&#x2F;jpeg</td>
<td align="left">.jpe</td>
<td align="left">application&#x2F;x-jpe</td>
</tr>
<tr>
<td align="left">.jpeg</td>
<td align="left">image&#x2F;jpeg</td>
<td align="left">.jpg</td>
<td align="left">image&#x2F;jpeg</td>
</tr>
<tr>
<td align="left">.jpg</td>
<td align="left">application&#x2F;x-jpg</td>
<td align="left">.js</td>
<td align="left">application&#x2F;x-javascript</td>
</tr>
<tr>
<td align="left">.jsp</td>
<td align="left">text&#x2F;html</td>
<td align="left">.la1</td>
<td align="left">audio&#x2F;x-liquid-file</td>
</tr>
<tr>
<td align="left">.lar</td>
<td align="left">application&#x2F;x-laplayer-reg</td>
<td align="left">.latex</td>
<td align="left">application&#x2F;x-latex</td>
</tr>
<tr>
<td align="left">.lavs</td>
<td align="left">audio&#x2F;x-liquid-secure</td>
<td align="left">.lbm</td>
<td align="left">application&#x2F;x-lbm</td>
</tr>
<tr>
<td align="left">.lmsff</td>
<td align="left">audio&#x2F;x-la-lms</td>
<td align="left">.ls</td>
<td align="left">application&#x2F;x-javascript</td>
</tr>
<tr>
<td align="left">.ltr</td>
<td align="left">application&#x2F;x-ltr</td>
<td align="left">.m1v</td>
<td align="left">video&#x2F;x-mpeg</td>
</tr>
<tr>
<td align="left">.m2v</td>
<td align="left">video&#x2F;x-mpeg</td>
<td align="left">.m3u</td>
<td align="left">audio&#x2F;mpegurl</td>
</tr>
<tr>
<td align="left">.m4e</td>
<td align="left">video&#x2F;mpeg4</td>
<td align="left">.mac</td>
<td align="left">application&#x2F;x-mac</td>
</tr>
<tr>
<td align="left">.man</td>
<td align="left">application&#x2F;x-troff-man</td>
<td align="left">.math</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.mdb</td>
<td align="left">application&#x2F;msaccess</td>
<td align="left">.mdb</td>
<td align="left">application&#x2F;x-mdb</td>
</tr>
<tr>
<td align="left">.mfp</td>
<td align="left">application&#x2F;x-shockwave-flash</td>
<td align="left">.mht</td>
<td align="left">message&#x2F;rfc822</td>
</tr>
<tr>
<td align="left">.mhtml</td>
<td align="left">message&#x2F;rfc822</td>
<td align="left">.mi</td>
<td align="left">application&#x2F;x-mi</td>
</tr>
<tr>
<td align="left">.mid</td>
<td align="left">audio&#x2F;mid</td>
<td align="left">.midi</td>
<td align="left">audio&#x2F;mid</td>
</tr>
<tr>
<td align="left">.mil</td>
<td align="left">application&#x2F;x-mil</td>
<td align="left">.mml</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.mnd</td>
<td align="left">audio&#x2F;x-musicnet-download</td>
<td align="left">.mns</td>
<td align="left">audio&#x2F;x-musicnet-stream</td>
</tr>
<tr>
<td align="left">.mocha</td>
<td align="left">application&#x2F;x-javascript</td>
<td align="left">.movie</td>
<td align="left">video&#x2F;x-sgi-movie</td>
</tr>
<tr>
<td align="left">.mp1</td>
<td align="left">audio&#x2F;mp1</td>
<td align="left">.mp2</td>
<td align="left">audio&#x2F;mp2</td>
</tr>
<tr>
<td align="left">.mp2v</td>
<td align="left">video&#x2F;mpeg</td>
<td align="left">.mp3</td>
<td align="left">audio&#x2F;mp3</td>
</tr>
<tr>
<td align="left">.mp4</td>
<td align="left">video&#x2F;mpeg4</td>
<td align="left">.mpa</td>
<td align="left">video&#x2F;x-mpg</td>
</tr>
<tr>
<td align="left">.mpd</td>
<td align="left">application&#x2F;vnd.ms-project</td>
<td align="left">.mpe</td>
<td align="left">video&#x2F;x-mpeg</td>
</tr>
<tr>
<td align="left">.mpeg</td>
<td align="left">video&#x2F;mpg</td>
<td align="left">.mpg</td>
<td align="left">video&#x2F;mpg</td>
</tr>
<tr>
<td align="left">.mpga</td>
<td align="left">audio&#x2F;rn-mpeg</td>
<td align="left">.mpp</td>
<td align="left">application&#x2F;vnd.ms-project</td>
</tr>
<tr>
<td align="left">.mps</td>
<td align="left">video&#x2F;x-mpeg</td>
<td align="left">.mpt</td>
<td align="left">application&#x2F;vnd.ms-project</td>
</tr>
<tr>
<td align="left">.mpv</td>
<td align="left">video&#x2F;mpg</td>
<td align="left">.mpv2</td>
<td align="left">video&#x2F;mpeg</td>
</tr>
<tr>
<td align="left">.mpw</td>
<td align="left">application&#x2F;vnd.ms-project</td>
<td align="left">.mpx</td>
<td align="left">application&#x2F;vnd.ms-project</td>
</tr>
<tr>
<td align="left">.mtx</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.mxp</td>
<td align="left">application&#x2F;x-mmxp</td>
</tr>
<tr>
<td align="left">.net</td>
<td align="left">image&#x2F;pnetvue</td>
<td align="left">.nrf</td>
<td align="left">application&#x2F;x-nrf</td>
</tr>
<tr>
<td align="left">.nws</td>
<td align="left">message&#x2F;rfc822</td>
<td align="left">.odc</td>
<td align="left">text&#x2F;x-ms-odc</td>
</tr>
<tr>
<td align="left">.out</td>
<td align="left">application&#x2F;x-out</td>
<td align="left">.p10</td>
<td align="left">application&#x2F;pkcs10</td>
</tr>
<tr>
<td align="left">.p12</td>
<td align="left">application&#x2F;x-pkcs12</td>
<td align="left">.p7b</td>
<td align="left">application&#x2F;x-pkcs7-certificates</td>
</tr>
<tr>
<td align="left">.p7c</td>
<td align="left">application&#x2F;pkcs7-mime</td>
<td align="left">.p7m</td>
<td align="left">application&#x2F;pkcs7-mime</td>
</tr>
<tr>
<td align="left">.p7r</td>
<td align="left">application&#x2F;x-pkcs7-certreqresp</td>
<td align="left">.p7s</td>
<td align="left">application&#x2F;pkcs7-signature</td>
</tr>
<tr>
<td align="left">.pc5</td>
<td align="left">application&#x2F;x-pc5</td>
<td align="left">.pci</td>
<td align="left">application&#x2F;x-pci</td>
</tr>
<tr>
<td align="left">.pcl</td>
<td align="left">application&#x2F;x-pcl</td>
<td align="left">.pcx</td>
<td align="left">application&#x2F;x-pcx</td>
</tr>
<tr>
<td align="left">.pdf</td>
<td align="left">application&#x2F;pdf</td>
<td align="left">.pdf</td>
<td align="left">application&#x2F;pdf</td>
</tr>
<tr>
<td align="left">.pdx</td>
<td align="left">application&#x2F;vnd.adobe.pdx</td>
<td align="left">.pfx</td>
<td align="left">application&#x2F;x-pkcs12</td>
</tr>
<tr>
<td align="left">.pgl</td>
<td align="left">application&#x2F;x-pgl</td>
<td align="left">.pic</td>
<td align="left">application&#x2F;x-pic</td>
</tr>
<tr>
<td align="left">.pko</td>
<td align="left">application&#x2F;vnd.ms-pki.pko</td>
<td align="left">.pl</td>
<td align="left">application&#x2F;x-perl</td>
</tr>
<tr>
<td align="left">.plg</td>
<td align="left">text&#x2F;html</td>
<td align="left">.pls</td>
<td align="left">audio&#x2F;scpls</td>
</tr>
<tr>
<td align="left">.plt</td>
<td align="left">application&#x2F;x-plt</td>
<td align="left">.png</td>
<td align="left">image&#x2F;png</td>
</tr>
<tr>
<td align="left">.png</td>
<td align="left">application&#x2F;x-png</td>
<td align="left">.pot</td>
<td align="left">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td align="left">.ppa</td>
<td align="left">application&#x2F;vnd.ms-powerpoint</td>
<td align="left">.ppm</td>
<td align="left">application&#x2F;x-ppm</td>
</tr>
<tr>
<td align="left">.pps</td>
<td align="left">application&#x2F;vnd.ms-powerpoint</td>
<td align="left">.ppt</td>
<td align="left">application&#x2F;vnd.ms-powerpoint</td>
</tr>
<tr>
<td align="left">.ppt</td>
<td align="left">application&#x2F;x-ppt</td>
<td align="left">.pr</td>
<td align="left">application&#x2F;x-pr</td>
</tr>
<tr>
<td align="left">.prf</td>
<td align="left">application&#x2F;pics-rules</td>
<td align="left">.prn</td>
<td align="left">application&#x2F;x-prn</td>
</tr>
<tr>
<td align="left">.prt</td>
<td align="left">application&#x2F;x-prt</td>
<td align="left">.ps</td>
<td align="left">application&#x2F;x-ps</td>
</tr>
<tr>
<td align="left">.ps</td>
<td align="left">application&#x2F;postscript</td>
<td align="left">.ptn</td>
<td align="left">application&#x2F;x-ptn</td>
</tr>
<tr>
<td align="left">.pwz</td>
<td align="left">application&#x2F;vnd.ms-powerpoint</td>
<td align="left">.r3t</td>
<td align="left">text&#x2F;vnd.rn-realtext3d</td>
</tr>
<tr>
<td align="left">.ra</td>
<td align="left">audio&#x2F;vnd.rn-realaudio</td>
<td align="left">.ram</td>
<td align="left">audio&#x2F;x-pn-realaudio</td>
</tr>
<tr>
<td align="left">.ras</td>
<td align="left">application&#x2F;x-ras</td>
<td align="left">.rat</td>
<td align="left">application&#x2F;rat-file</td>
</tr>
<tr>
<td align="left">.rdf</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.rec</td>
<td align="left">application&#x2F;vnd.rn-recording</td>
</tr>
<tr>
<td align="left">.red</td>
<td align="left">application&#x2F;x-red</td>
<td align="left">.rgb</td>
<td align="left">application&#x2F;x-rgb</td>
</tr>
<tr>
<td align="left">.rjs</td>
<td align="left">application&#x2F;vnd.rn-realsystem-rjs</td>
<td align="left">.rjt</td>
<td align="left">application&#x2F;vnd.rn-realsystem-rjt</td>
</tr>
<tr>
<td align="left">.rlc</td>
<td align="left">application&#x2F;x-rlc</td>
<td align="left">.rle</td>
<td align="left">application&#x2F;x-rle</td>
</tr>
<tr>
<td align="left">.rm</td>
<td align="left">application&#x2F;vnd.rn-realmedia</td>
<td align="left">.rmf</td>
<td align="left">application&#x2F;vnd.adobe.rmf</td>
</tr>
<tr>
<td align="left">.rmi</td>
<td align="left">audio&#x2F;mid</td>
<td align="left">.rmj</td>
<td align="left">application&#x2F;vnd.rn-realsystem-rmj</td>
</tr>
<tr>
<td align="left">.rmm</td>
<td align="left">audio&#x2F;x-pn-realaudio</td>
<td align="left">.rmp</td>
<td align="left">application&#x2F;vnd.rn-rn_music_package</td>
</tr>
<tr>
<td align="left">.rms</td>
<td align="left">application&#x2F;vnd.rn-realmedia-secure</td>
<td align="left">.rmvb</td>
<td align="left">application&#x2F;vnd.rn-realmedia-vbr</td>
</tr>
<tr>
<td align="left">.rmx</td>
<td align="left">application&#x2F;vnd.rn-realsystem-rmx</td>
<td align="left">.rnx</td>
<td align="left">application&#x2F;vnd.rn-realplayer</td>
</tr>
<tr>
<td align="left">.rp</td>
<td align="left">image&#x2F;vnd.rn-realpix</td>
<td align="left">.rpm</td>
<td align="left">audio&#x2F;x-pn-realaudio-plugin</td>
</tr>
<tr>
<td align="left">.rsml</td>
<td align="left">application&#x2F;vnd.rn-rsml</td>
<td align="left">.rt</td>
<td align="left">text&#x2F;vnd.rn-realtext</td>
</tr>
<tr>
<td align="left">.rtf</td>
<td align="left">application&#x2F;msword</td>
<td align="left">.rtf</td>
<td align="left">application&#x2F;x-rtf</td>
</tr>
<tr>
<td align="left">.rv</td>
<td align="left">video&#x2F;vnd.rn-realvideo</td>
<td align="left">.sam</td>
<td align="left">application&#x2F;x-sam</td>
</tr>
<tr>
<td align="left">.sat</td>
<td align="left">application&#x2F;x-sat</td>
<td align="left">.sdp</td>
<td align="left">application&#x2F;sdp</td>
</tr>
<tr>
<td align="left">.sdw</td>
<td align="left">application&#x2F;x-sdw</td>
<td align="left">.sit</td>
<td align="left">application&#x2F;x-stuffit</td>
</tr>
<tr>
<td align="left">.slb</td>
<td align="left">application&#x2F;x-slb</td>
<td align="left">.sld</td>
<td align="left">application&#x2F;x-sld</td>
</tr>
<tr>
<td align="left">.slk</td>
<td align="left">drawing&#x2F;x-slk</td>
<td align="left">.smi</td>
<td align="left">application&#x2F;smil</td>
</tr>
<tr>
<td align="left">.smil</td>
<td align="left">application&#x2F;smil</td>
<td align="left">.smk</td>
<td align="left">application&#x2F;x-smk</td>
</tr>
<tr>
<td align="left">.snd</td>
<td align="left">audio&#x2F;basic</td>
<td align="left">.sol</td>
<td align="left">text&#x2F;plain</td>
</tr>
<tr>
<td align="left">.sor</td>
<td align="left">text&#x2F;plain</td>
<td align="left">.spc</td>
<td align="left">application&#x2F;x-pkcs7-certificates</td>
</tr>
<tr>
<td align="left">.spl</td>
<td align="left">application&#x2F;futuresplash</td>
<td align="left">.spp</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.ssm</td>
<td align="left">application&#x2F;streamingmedia</td>
<td align="left">.sst</td>
<td align="left">application&#x2F;vnd.ms-pki.certstore</td>
</tr>
<tr>
<td align="left">.stl</td>
<td align="left">application&#x2F;vnd.ms-pki.stl</td>
<td align="left">.stm</td>
<td align="left">text&#x2F;html</td>
</tr>
<tr>
<td align="left">.sty</td>
<td align="left">application&#x2F;x-sty</td>
<td align="left">.svg</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.swf</td>
<td align="left">application&#x2F;x-shockwave-flash</td>
<td align="left">.tdf</td>
<td align="left">application&#x2F;x-tdf</td>
</tr>
<tr>
<td align="left">.tg4</td>
<td align="left">application&#x2F;x-tg4</td>
<td align="left">.tga</td>
<td align="left">application&#x2F;x-tga</td>
</tr>
<tr>
<td align="left">.tif</td>
<td align="left">image&#x2F;tiff</td>
<td align="left">.tif</td>
<td align="left">application&#x2F;x-tif</td>
</tr>
<tr>
<td align="left">.tiff</td>
<td align="left">image&#x2F;tiff</td>
<td align="left">.tld</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.top</td>
<td align="left">drawing&#x2F;x-top</td>
<td align="left">.torrent</td>
<td align="left">application&#x2F;x-bittorrent</td>
</tr>
<tr>
<td align="left">.tsd</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.txt</td>
<td align="left">text&#x2F;plain</td>
</tr>
<tr>
<td align="left">.uin</td>
<td align="left">application&#x2F;x-icq</td>
<td align="left">.uls</td>
<td align="left">text&#x2F;iuls</td>
</tr>
<tr>
<td align="left">.vcf</td>
<td align="left">text&#x2F;x-vcard</td>
<td align="left">.vda</td>
<td align="left">application&#x2F;x-vda</td>
</tr>
<tr>
<td align="left">.vdx</td>
<td align="left">application&#x2F;vnd.visio</td>
<td align="left">.vml</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.vpg</td>
<td align="left">application&#x2F;x-vpeg005</td>
<td align="left">.vsd</td>
<td align="left">application&#x2F;vnd.visio</td>
</tr>
<tr>
<td align="left">.vsd</td>
<td align="left">application&#x2F;x-vsd</td>
<td align="left">.vss</td>
<td align="left">application&#x2F;vnd.visio</td>
</tr>
<tr>
<td align="left">.vst</td>
<td align="left">application&#x2F;vnd.visio</td>
<td align="left">.vst</td>
<td align="left">application&#x2F;x-vst</td>
</tr>
<tr>
<td align="left">.vsw</td>
<td align="left">application&#x2F;vnd.visio</td>
<td align="left">.vsx</td>
<td align="left">application&#x2F;vnd.visio</td>
</tr>
<tr>
<td align="left">.vtx</td>
<td align="left">application&#x2F;vnd.visio</td>
<td align="left">.vxml</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.wav</td>
<td align="left">audio&#x2F;wav</td>
<td align="left">.wax</td>
<td align="left">audio&#x2F;x-ms-wax</td>
</tr>
<tr>
<td align="left">.wb1</td>
<td align="left">application&#x2F;x-wb1</td>
<td align="left">.wb2</td>
<td align="left">application&#x2F;x-wb2</td>
</tr>
<tr>
<td align="left">.wb3</td>
<td align="left">application&#x2F;x-wb3</td>
<td align="left">.wbmp</td>
<td align="left">image&#x2F;vnd.wap.wbmp</td>
</tr>
<tr>
<td align="left">.wiz</td>
<td align="left">application&#x2F;msword</td>
<td align="left">.wk3</td>
<td align="left">application&#x2F;x-wk3</td>
</tr>
<tr>
<td align="left">.wk4</td>
<td align="left">application&#x2F;x-wk4</td>
<td align="left">.wkq</td>
<td align="left">application&#x2F;x-wkq</td>
</tr>
<tr>
<td align="left">.wks</td>
<td align="left">application&#x2F;x-wks</td>
<td align="left">.wm</td>
<td align="left">video&#x2F;x-ms-wm</td>
</tr>
<tr>
<td align="left">.wma</td>
<td align="left">audio&#x2F;x-ms-wma</td>
<td align="left">.wmd</td>
<td align="left">application&#x2F;x-ms-wmd</td>
</tr>
<tr>
<td align="left">.wmf</td>
<td align="left">application&#x2F;x-wmf</td>
<td align="left">.wml</td>
<td align="left">text&#x2F;vnd.wap.wml</td>
</tr>
<tr>
<td align="left">.wmv</td>
<td align="left">video&#x2F;x-ms-wmv</td>
<td align="left">.wmx</td>
<td align="left">video&#x2F;x-ms-wmx</td>
</tr>
<tr>
<td align="left">.wmz</td>
<td align="left">application&#x2F;x-ms-wmz</td>
<td align="left">.wp6</td>
<td align="left">application&#x2F;x-wp6</td>
</tr>
<tr>
<td align="left">.wpd</td>
<td align="left">application&#x2F;x-wpd</td>
<td align="left">.wpg</td>
<td align="left">application&#x2F;x-wpg</td>
</tr>
<tr>
<td align="left">.wpl</td>
<td align="left">application&#x2F;vnd.ms-wpl</td>
<td align="left">.wq1</td>
<td align="left">application&#x2F;x-wq1</td>
</tr>
<tr>
<td align="left">.wr1</td>
<td align="left">application&#x2F;x-wr1</td>
<td align="left">.wri</td>
<td align="left">application&#x2F;x-wri</td>
</tr>
<tr>
<td align="left">.wrk</td>
<td align="left">application&#x2F;x-wrk</td>
<td align="left">.ws</td>
<td align="left">application&#x2F;x-ws</td>
</tr>
<tr>
<td align="left">.ws2</td>
<td align="left">application&#x2F;x-ws</td>
<td align="left">.wsc</td>
<td align="left">text&#x2F;scriptlet</td>
</tr>
<tr>
<td align="left">.wsdl</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.wvx</td>
<td align="left">video&#x2F;x-ms-wvx</td>
</tr>
<tr>
<td align="left">.xdp</td>
<td align="left">application&#x2F;vnd.adobe.xdp</td>
<td align="left">.xdr</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.xfd</td>
<td align="left">application&#x2F;vnd.adobe.xfd</td>
<td align="left">.xfdf</td>
<td align="left">application&#x2F;vnd.adobe.xfdf</td>
</tr>
<tr>
<td align="left">.xhtml</td>
<td align="left">text&#x2F;html</td>
<td align="left">.xls</td>
<td align="left">application&#x2F;vnd.ms-excel</td>
</tr>
<tr>
<td align="left">.xls</td>
<td align="left">application&#x2F;x-xls</td>
<td align="left">.xlw</td>
<td align="left">application&#x2F;x-xlw</td>
</tr>
<tr>
<td align="left">.xml</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.xpl</td>
<td align="left">audio&#x2F;scpls</td>
</tr>
<tr>
<td align="left">.xq</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.xql</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.xquery</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.xsd</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.xsl</td>
<td align="left">text&#x2F;xml</td>
<td align="left">.xslt</td>
<td align="left">text&#x2F;xml</td>
</tr>
<tr>
<td align="left">.xwd</td>
<td align="left">application&#x2F;x-xwd</td>
<td align="left">.x_b</td>
<td align="left">application&#x2F;x-x_b</td>
</tr>
<tr>
<td align="left">.sis</td>
<td align="left">application&#x2F;vnd.symbian.install</td>
<td align="left">.sisx</td>
<td align="left">application&#x2F;vnd.symbian.install</td>
</tr>
<tr>
<td align="left">.x_t</td>
<td align="left">application&#x2F;x-x_t</td>
<td align="left">.ipa</td>
<td align="left">application&#x2F;vnd.iphone</td>
</tr>
<tr>
<td align="left">.apk</td>
<td align="left">application&#x2F;vnd.android.package-archive</td>
<td align="left">.xap</td>
<td align="left">application&#x2F;x-silverlight-app</td>
</tr>
</tbody></table>
<h4 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a><em>MIME</em>类型</h4><p><em>MIME</em>（<em>Multpurpose Internet Extension</em>）是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。</p>
<p><em>MIME</em>消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p>
<p>浏览器通常使用<em>MIME</em>类型（而不是为文件扩展名）来确定如何处理<em>URL</em>，因此<em>Web</em>服务器在响应头中添加正确的<em>MIME</em>类型非常重要。如果配置不正确，浏览器可能无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type/subtype</span><br></pre></td></tr></table></figure>

<p>MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 <strong>&#x2F;</strong> 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。</p>
<p>MIME类型对大小写不敏感，但是传统写法都是小写。</p>
<p>两种主要的 MIME 类型在默认类型中扮演了重要的角色：</p>
<ul>
<li><strong>text&#x2F;plain</strong> 表示文本文件的默认值。</li>
<li><strong>application&#x2F;octet-stream</strong> 表示所有其他情况的默认值。</li>
</ul>
<h5 id="常见的-MIME-类型"><a href="#常见的-MIME-类型" class="headerlink" title="常见的 MIME 类型"></a>常见的 MIME 类型</h5><ul>
<li>超文本标记语言文本 <strong>.html、.html</strong>：<strong>text&#x2F;html</strong></li>
<li>普通文本 <strong>.txt</strong>： <strong>text&#x2F;plain</strong></li>
<li>RTF 文本 <strong>.rtf</strong>： <strong>application&#x2F;rtf</strong></li>
<li>GIF 图形 <strong>.gif</strong>： <strong>image&#x2F;gif</strong></li>
<li>JPEG 图形 <strong>.jpeg、.jpg</strong>： <strong>image&#x2F;jpeg</strong></li>
<li>au 声音文件 <strong>.au</strong>： <strong>audio&#x2F;basic</strong></li>
<li>MIDI 音乐文件 <strong>mid、.midi</strong>： <strong>audio&#x2F;midi、audio&#x2F;x-midi</strong></li>
<li>RealAudio 音乐文件 <strong>.ra、.ram</strong>： <strong>audio&#x2F;x-pn-realaudio</strong></li>
<li>MPEG 文件 <strong>.mpg、.mpeg</strong>： <strong>video&#x2F;mpeg</strong></li>
<li>AVI 文件 <strong>.avi</strong>： <strong>video&#x2F;x-msvideo</strong></li>
<li>GZIP 文件 <strong>.gz</strong>： <strong>application&#x2F;x-gzip</strong></li>
<li>TAR 文件 <strong>.tar</strong>： <strong>application&#x2F;x-tar</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
<th align="left">典型示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>text</code></td>
<td align="left">表明文件是普通文本，理论上是人类可读</td>
<td align="left"><code>text/plain</code>, <code>text/html</code>, <code>text/css, text/javascript</code></td>
</tr>
<tr>
<td align="left"><code>image</code></td>
<td align="left">表明是某种图像。不包括视频，但是动态图（比如动态gif）也使用image类型</td>
<td align="left"><code>image/gif</code>, <code>image/png</code>, <code>image/jpeg</code>, <code>image/bmp</code>, <code>image/webp</code>, <code>image/x-icon</code>, <code>image/vnd.microsoft.icon</code></td>
</tr>
<tr>
<td align="left"><code>audio</code></td>
<td align="left">表明是某种音频文件</td>
<td align="left"><code>audio/midi</code>, <code>audio/mpeg, audio/webm, audio/ogg, audio/wav</code></td>
</tr>
<tr>
<td align="left"><code>video</code></td>
<td align="left">表明是某种视频文件</td>
<td align="left"><code>video/webm</code>, <code>video/ogg</code></td>
</tr>
<tr>
<td align="left"><code>application</code></td>
<td align="left">表明是某种二进制数据</td>
<td align="left"><code>application/octet-stream</code>, <code>application/pkcs12</code>, <code>application/vnd.mspowerpoint</code>, <code>application/xhtml+xml</code>, <code>application/xml</code>, <code>application/pdf</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>折腾OpenWrt的半个月</title>
    <url>/2022/11/02/beatOpenWrt/</url>
    <content><![CDATA[<p>考试完整理</p>
]]></content>
      <categories>
        <category>toy</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>OpenWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Java排序算法Sort源码分析</title>
    <url>/2022/12/05/arrayssort/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>学习了数据结构与算法，作为最不能忽略的排序算法，排序可谓门类很多，主要常见的有以下几类：</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211281609568.png" alt="img" style="zoom:50%;" />

<p><strong>关于时间复杂度：</strong></p>
<ol>
<li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>
<li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li>
<li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>
<li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ol>
<p><strong>关于稳定性</strong>：</p>
<ol>
<li><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p>
</li>
<li><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
</li>
</ol>
<h2 id="Java的sort-包"><a href="#Java的sort-包" class="headerlink" title="Java的sort()包"></a>Java的sort()包</h2><p>本文主要讲的是JAVA内置排序Arrays.sort()实现的排序的类型。</p>
<p>Java开发中，经常需要进行数组和链表的各种操作，所以数组和链表的排序是重中之重。</p>
<p>Collections.sort()方法用来对链表排序，而Collections.sort()的底层，其实使用的也是Arrays.sort()方法。JAVA内置排序的核心类，都在于Arrays工具类，接下来也重点剖析该类。</p>
<h3 id="Arrays的工具类"><a href="#Arrays的工具类" class="headerlink" title="Arrays的工具类"></a>Arrays的工具类</h3><p>打开JDK9的包先看看Arrays中的sort()方法种类。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211281720162.png" alt="image-20221128172038129" style="zoom:50%;" />



<blockquote>
<p>从排序的<strong>范围</strong>角度划分，分为了以下：</p>
</blockquote>
<ol>
<li>针对数组的整体做排序的方法，如<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
<li>针对数组的局部做排序的方法，如<ul>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>从排序的<strong>类型</strong>角度划分，分为了以下：</p>
</blockquote>
<ol>
<li>对数组按照默认升序的方式进行排序的方法，如<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
</ul>
</li>
<li>对数组按照自定义排序类型进行排序的方法，如<ul>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>从<strong>操作对象</strong>的角度划分，分为了以下：</p>
</blockquote>
<ol>
<li>对基本类型（byte，int，char等）数组操作的方法<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
</ul>
</li>
<li>对对象类型（object）数组操作的方法<ul>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>小总结：</p>
</blockquote>
<p>最重要的划分是从操作对象的角度进行划分，因为Java对不同类型的数组，实现了不同的实现方法。下面进行分析：</p>
<h3 id="基本数据类型的排序"><a href="#基本数据类型的排序" class="headerlink" title="基本数据类型的排序"></a>基本数据类型的排序</h3><p>基本数据类型数组对应不同长度时使用的排序算法：</p>
<ol>
<li>当长度小于47时，采用<strong>插入排序</strong>算法。</li>
<li>当长度介于47以及286中间时，先判断数组是否具备特定结构，如果具备，采用<strong>快速排序</strong>，不具备时采用一种优化形式：<strong>双轴快排</strong>算法。</li>
<li>当长度大于286时，有特定结构的话，就是使用<strong>归并排序</strong>算法。</li>
</ol>
<p>下图为总结：</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211281746963.png" alt="up-205a0fbd3c9218e765bbbd1a17947a400d9" style="zoom: 67%;" />



<h3 id="是否有具有特定结构"><a href="#是否有具有特定结构" class="headerlink" title="是否有具有特定结构"></a>是否有具有特定结构</h3><p>在判断是否使用归并排序前，要先判断数组是否具备特定结构，怎么进行判断呢，首先看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left; k &lt; right; run[count] = k) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);            </span><br><span class="line">            	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;                </span><br><span class="line">                    <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;                </span><br><span class="line">                <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                    sort(a, left, right, <span class="literal">true</span>);                    </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The array is not highly structured,</span></span><br><span class="line"><span class="comment">         * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="literal">true</span>);            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大概逻辑就是：每个降序序列为一个组。像<code>1,9,8,7,6,8</code>，9到6是降序，为一组，称为降序组，将其组成升序<code>1,6,7,8,9,8</code>,最后再从8往后找下一组降序组。</p>
<p>每次遇到一个降序组，count都会进行++count的操作，当count的值大于MAX_RUN_COUNT(也即67)时，判定这个数组不具备特定结构，就是说数组的数据时升时降，还是比较适合采用<strong>快速排序</strong>。反之，小于67的时候，则证明该数组有特定结构，就继续采用<strong>归并排序</strong>。</p>
<h3 id="对象类型数组的排序"><a href="#对象类型数组的排序" class="headerlink" title="对象类型数组的排序"></a>对象类型数组的排序</h3><p>对象类型对应不同长度时使用的排序算法：</p>
<ol>
<li>如果对象数组的长度小于32，采用不包含并操作的<strong>mini-TimSort</strong>算法。</li>
<li>如果对象数组的长度大于31，采用完整的<strong>TimSort算法</strong>。</li>
</ol>
<p><strong>TimSort算法</strong></p>
<p>这是一种结合了归并排序和插入排序的混合排序算法，设计初衷是为了在真实世界中的各种数据中可以由较好的性能。</p>
<p>基本的运行过程：</p>
<ol>
<li>扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转。我们将这样的段称之为run。</li>
<li>定义最小run长度，短于此的run通过插入排序合并为长度高于最小run长度；</li>
<li>反复归并一些相邻run，过程中需要避免归并长度相差很大的run，直至整个排序完成；</li>
<li>如何避免归并长度相差很大run呢， 依次将run压入栈中，若栈顶run X，run Y，run Z 的长度违反了X&gt;Y+Z 或 Y&gt;Z 则Y run与较小长度的run合并，并再次放入栈中。 依据这个法则，能够尽量使得大小相同的run合并，以提高性能。注意Timsort是稳定排序故只有相邻的run才能归并。</li>
<li>Merge操作还可以辅之以galloping，具体细节可以自行研究。</li>
</ol>
<p>timsort是工业级算法，其混用插入排序与归并排序，二分搜索等算法，亮点是充分利用待排序数据可能部分有序的事实，并且依据待排序数据内容动态改变排序策略——选择性进行归并以及galloping。</p>
<h3 id="不同的算法对于效率的影响"><a href="#不同的算法对于效率的影响" class="headerlink" title="不同的算法对于效率的影响"></a>不同的算法对于效率的影响</h3><p>对于较小长度的数组，采用时间复杂度为O(n^2)的插入排序无伤大雅，毕竟n很小，排序的性能也高于快速排序。但是在n较大的情况下，归并排序和快速排序都是性能较优秀的算法，平均时间复杂度都在O(nlogn)之间，区别在于归并排序较为稳定。</p>
<p>对于基本数组类型，稳定性没有太大意义，所以可以使用不稳定的快排，但是对于对象类型，稳定性是比较重要的，对象相等的复杂性让我们没办法保证每个人都回重写正确的equal方法，故使用稳定算法的归并排序和插入排序结合的TimSort算法。</p>
<p>对于归并排序来说，比较次数比快速排序少，移动次数比快排多，而对于对象来说，比较是相对耗时的操作，所以并不适合快排，对于基本数据类型来说，比较和移动都不怎么耗时，所以用归并和快速都可以。</p>
<blockquote>
<p>All in All</p>
</blockquote>
<p>基本数据类型数组使用快排+归并:</p>
<ol>
<li>基本数据类型无所谓稳定性，可以采用非稳定的快排</li>
<li>对于基本数据类型来说，比较和移动都不怎么耗时，所以用归并或者快排都可以</li>
</ol>
<p>对象数据类型不使用快排:</p>
<ol>
<li>对象数据类型要求稳定性，需要采用稳定的归并+插入</li>
<li>对于对象来说，比较操作相对耗时，所以用比较操作较少的归并排序</li>
</ol>
<h2 id="三种排序详解"><a href="#三种排序详解" class="headerlink" title="三种排序详解"></a>三种排序详解</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><strong>1. 基本思想</strong></p>
<blockquote>
<p>将整个序列分为两部分：前面 <code>i</code> 个元素为有序序列，后面 <code>n - i</code> 个元素为无序序列。每一次排序，将无序序列的第 <code>1</code> 个元素，在有序序列中找到相应的位置并插入。</p>
</blockquote>
<p><strong>2. 算法步骤</strong></p>
<ol>
<li>第 <code>1</code> 趟排序：<ol>
<li>第 <code>1</code> 个元素为有序序列，后面第 <code>2</code> ~ <code>n </code>个元素（总共 <code>n - 1</code> 个元素）为无序序列。</li>
<li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li>
<li>如果遇到「有序序列的元素 &lt;&#x3D; 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li>
</ol>
</li>
<li>第 <code>2</code> 趟排序：<ol>
<li>第 <code>1</code> ~ <code>2</code> 个元素为有序序列，后面第 <code>3</code> ~ <code>n</code> 个元素（总共 <code>n - 2</code> 个元素）为无序序列。</li>
<li>从右至左遍历有序序列中的元素，如果遇到「有序序列的元素 &gt; 无序序列的第 <code>1</code> 个元素」的情况时，则将向有序序列的元素后移动一位。</li>
<li>如果遇到「有序序列的元素 &lt;&#x3D; 无序序列的第 <code>1</code> 个元素」的情况或者「到达数组开始位置」时，则说明找到了插入位置。将「无序序列的第 <code>1</code> 个元素」插入该位置。</li>
</ol>
</li>
<li>依次类推，对剩余 <code>n - 3</code> 个元素重复上述排序过程，直到所有元素都变为有序序列，则排序结束。</li>
</ol>
<p>简单来说，插入排序的算法步骤为：</p>
<ol>
<li>先将第 <code>1</code> 个元素作为一个有序序列，将第 <code>2</code> ~ <code>n</code> 个元素作为无序序列。</li>
<li>从左到右遍历一遍无序序列，对于无序序列中的每一个元素：<ol>
<li>遍历有序序列，找到适当的插入位置。</li>
<li>将有序序列中插入位置右侧的元素依次右移一位。</li>
<li>将该元素插入到适当位置。</li>
</ol>
</li>
</ol>
<p> <strong>3. 动画演示</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212051952620.gif" alt="img"></p>
<p><strong>4. 算法分析</strong></p>
<ul>
<li>最佳时间复杂度：O(n)</li>
<li>最差时间复杂度：O(n^2)</li>
<li>平均时间复杂度：O(n^2)</li>
<li>稳定性：稳定</li>
</ul>
<p><strong>5. 代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toInsertSort</span><span class="params">(<span class="type">int</span> []arr)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;arr.length;i++) &#123;	    <span class="comment">//i是当前数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span> ; j&gt;=<span class="number">0</span>;j--) &#123;	   <span class="comment">//j是从i-1开始向前移动，并每次与arr[i]判断大小</span></span><br><span class="line">			<span class="keyword">if</span>(arr[i]&lt;arr[j]) &#123;		     <span class="comment">//如果arr[i]小于arr[j]说明arr[i]当前至少是要插入到arr[j]的前面</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">				arr[j] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">				i = j-<span class="number">1</span>;		     <span class="comment">//互换后i也要向前移动一位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span>;              <span class="comment">//直到arr[i]比arr[j]大，因为前面从小到大已经排好序，所以没有必要继续向前判断了					</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>1. 基本思想</strong></p>
<blockquote>
<p>通过一趟排序将无序序列分为独立的两个序列，第一个序列的值均比第二个序列的值小。然后递归地排列两个子序列，以达到整个序列有序。</p>
</blockquote>
<p><strong>2. 算法步骤</strong></p>
<ol>
<li>从序列中找到一个基准数 <code>point</code>（这里以当前序列第 <code>1</code> 个元素作为基准数，即 <code>point = arr[low]</code>）。</li>
<li>使用双指针，将序列中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧：<ol>
<li>使用指针 <code>i</code>，指向当前需要处理的元素位置，需要保证位置 <code>i</code> 之前的元素都小于基准数。初始时，<code>i</code> 指向当前序列的第 <code>2</code> 个元素位置。</li>
<li>使用指针 <code>j</code> 遍历当前序列，如果遇到 <code>arr[j]</code> 小于基准数 <code>point</code>，则将 <code>arr[j]</code> 与当前需要处理的元素 <code>arr[i]</code> 交换，并将 <code>i</code> 向右移动 <code>1</code> 位，保证位置 <code>i</code> 之前的元素都小于基准数。</li>
<li>最后遍历完，此时位置 <code>i</code> 之前的元素都小于基准数，第 <code>i - 1</code> 位置上的元素是最后一个小于基准数 <code>point</code> 的元素，此位置为基准数最终的正确位置。将基准数与该位置上的元素进行交换。此时，基准数左侧都是小于基准数的元素，右侧都是大于等于基准数的元素。</li>
<li>然后将序列拆分为左右两个子序列。</li>
</ol>
</li>
<li>对左右两个子序列分别重复第 <code>2</code> 步，直到各个子序列只有 <code>1</code> 个元素，则排序结束。</li>
</ol>
<p><strong>3. 动画演示</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052003794.gif" alt="img"></p>
<p><strong>4. 算法分析</strong></p>
<ul>
<li>最佳时间复杂度：O(n*log2(n))</li>
<li>最差时间复杂度：O(n^2)</li>
<li>平均时间复杂度：O(n*log2(n))</li>
<li>稳定性：不稳定</li>
</ul>
<p><strong>5. 代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sortPointer</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//定义基准数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> nums[high];</span><br><span class="line">        <span class="comment">//定义第二指针元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pointer</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="comment">//将指针前后开并记录第二指针的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low; i &lt; high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (center &gt;= nums[i]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">                nums[i] = nums[pointer];</span><br><span class="line">                nums[pointer] = temp;</span><br><span class="line">                pointer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回第二指针的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[pointer];</span><br><span class="line">        nums[pointer] = nums[high];</span><br><span class="line">        nums[high] = temp;</span><br><span class="line">        <span class="keyword">return</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">//运用递归的方式进行重复操作</span></span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> sortPointer(nums, low, high);</span><br><span class="line">            quickSort(nums, low, position - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, position + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>1. 基本思想</strong></p>
<blockquote>
<p>采用经典的分治策略，先递归地将当前序列平均分成两半。然后将有序序列两两合并，最终合并成一个有序序列。</p>
</blockquote>
<p><strong>2. 算法步骤</strong></p>
<ol>
<li>分割过程：先递归地将当前序列平均分成两半，直到子序列长度为 1。<ol>
<li>在一个数组长度为n的数组中找到序列中心位置 <code>mid</code>，从中心位置将序列分成左右两个子序列。</li>
<li>对左右两个子序列分别进行递归分割。</li>
<li>最终将数组分割为 n 个长度均为 1 的有序子序列。</li>
</ol>
</li>
<li>归并过程：从长度为 1 的有序子序列开始，依次进行两两归并，直到合并成一个长度为 n 的有序序列。<ol>
<li>使用数组变量 <code>arr </code>存放归并后的有序数组。</li>
<li>使用两个指针分别指向两个有序子序列 的开始位置。</li>
<li>比较两个指针指向的元素，将两个有序子序列中较小元素依次存入到结果数组 <code>arr</code> 中，并将指针移动到下一位置。</li>
<li>重复步骤 3，直到某一指针到达子序列末尾。</li>
<li>返回归并后的有序数组 <code>arr</code>。</li>
</ol>
</li>
</ol>
<p><strong>3. 动画演示</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052023716.gif" alt="img"></p>
<ol>
<li>初始序列为 <code>[6, 2, 1, 3, 7, 5, 4, 8]</code>。</li>
<li>将序列分解为 <code>[6, 2, 1, 3]</code>，<code>[7, 5, 4, 8]</code>。</li>
<li>将序列分解为 <code>[6, 2]</code>，<code>[1, 3]</code>，<code>[7, 5]</code>，<code>[4, 8]</code>。</li>
<li>将序列分为为 <code>[6]</code>，<code>[2]</code>，<code>[1]</code>，<code>[3]</code>，<code>[7]</code>，<code>[5]</code>，<code>[4]</code>，<code>[8]</code>。</li>
<li>将序列看做是 <code>8</code> 个长度为 <code>1</code> 的子序列，即 <code>[6]</code>，<code>[2]</code>，<code>[1]</code>，<code>[3]</code>，<code>[7]</code>，<code>[5]</code>，<code>[4]</code>，<code>[8]</code>。</li>
<li>第 <code>1</code> 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：<code>[2, 6]</code>，<code>[1, 3]</code>，<code>[5, 7]</code>，<code>[4, 8]</code>。</li>
<li>第 <code>2</code> 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：<code>[1, 2, 3, 6]</code>，<code>[4, 5, 7, 8]</code>。</li>
<li>第 <code>3</code> 趟排序：将子序列中的有序子序列两两归并，归并后的子序列为：<code>[1, 2, 3, 4, 5, 6, 7, 8]</code>。得到长度为 <code>n</code> 的有序序列，排序结束。</li>
</ol>
<p><strong>4. 算法分析</strong></p>
<ul>
<li>时间复杂度：O(n×log2⁡n)</li>
<li>空间复杂度：O(n)</li>
<li>稳定性：稳定<ul>
<li>因为在两个有序子序列的归并过程中，如果两个有序序列中出现相同元素，归并排序能够使前一个序列中那个相同元素先被复制，从而确保这两个元素的相对次序不发生改变。</li>
</ul>
</li>
</ul>
<p><strong>5. 代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        sortArray(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start,<span class="type">int</span> mid, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个临时数组储存排序后的数组</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            <span class="comment">//较小的元素存在数组的前面，较大的放在后面对应的位置</span></span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[k++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = array[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将不整除时多余的元素放置于数组后面</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= end) &#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//临时数组赋值回原数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; k; l++) &#123;</span><br><span class="line">            array[l + start] = temp[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortArray</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> start,<span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//运用递归的方式进行归并排序</span></span><br><span class="line">        <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">        sortArray(array,start,mid);</span><br><span class="line">        sortArray(array,mid + <span class="number">1</span>,end);</span><br><span class="line">        merge(array,start,mid,end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://sort.hust.cc/">完整的排序算法分类</a></p>
<p><a href="https://www.imooc.com/article/257268">Collection.sort()源码分析</a></p>
<p><a href="https://cherish-ls.github.io/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/">JAVA内置排序Arrays.sort实现简述</a></p>
<p><a href="https://algo.itcharge.cn/01.Array/02.Array-Sort">数组排序分析</a></p>
<p><a href="https://www.yuque.com/dreamin-c68j9/hwyqcg/gydluo#">排序算法题目</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基础</title>
    <url>/2022/09/09/MySQL/</url>
    <content><![CDATA[<p>1.数据库：为了增删改查数据。（文件保存数据很蠢很蠢）<br>2.C R U D：增删改查的专业术语。<br>3.层次、网状、关系型模型数据库</p>
<h2 id="数据库开始"><a href="#数据库开始" class="headerlink" title="数据库开始"></a><strong>数据库开始</strong></h2><p>show databases;</p>
<p>imformation_schema：信息数据库，其中保存着关于 MySQL 服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表栏的数据类型与访问权限等</p>
<p>mysql：保存了用户信息。</p>
<p>performance_schema：监控 MySQL 运行过程的资源消耗情况。</p>
<p>sys： 通过过视图的形式把 information_schema 和 performance_schema 结合起来，查询出更加令人容易理解的数据。</p>
<h2 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a><strong>数据库基本操作</strong></h2><p>创建数据库</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> student;</span><br><span class="line"></span><br><span class="line">判断创建语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> student;</span><br><span class="line"></span><br><span class="line">关键字变量名语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="symbol">`database`</span>;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> student;</span><br><span class="line"></span><br><span class="line">判断删除语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> student;</span><br><span class="line"></span><br><span class="line">关键字变量名语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="symbol">`database`</span>;</span><br></pre></td></tr></table></figure>

<p>查看创建数据库的 SQL：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> student;</span><br></pre></td></tr></table></figure>

<p>回退的语句：</p>
<p>Ctrl + C（^C）</p>
<p>创建数据库设置指定的字符编码</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> teacher charset=gbk;</span><br></pre></td></tr></table></figure>

<p>修改数据库字符编码</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">alter database student charset<span class="operator">=</span>gbk<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a><strong>表操作</strong></h3><p>进入库:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">use fuck_school<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>展示表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
<p>制作表：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line"></span><br><span class="line">Id <span class="type">int</span>,</span><br><span class="line"></span><br><span class="line"><span class="type">name</span> <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line"></span><br><span class="line">age <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>有 B 格的写法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> teacher(</span><br><span class="line"></span><br><span class="line">Id <span class="type">int</span> auto_increment <span class="keyword">primary key</span> <span class="keyword">comment</span> <span class="string">&#x27;主键 Id&#x27;</span>, </span><br><span class="line"></span><br><span class="line"><span class="type">name</span> <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">comment</span> <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line"></span><br><span class="line">phone <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;暂时未知&#x27;</span> <span class="keyword">comment</span> <span class="string">&#x27;电话&#x27;</span>, </span><br><span class="line"></span><br><span class="line">adress <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">&#x27;暂时未知&#x27;</span> <span class="keyword">comment</span> <span class="string">&#x27;家庭住址&#x27;</span></span><br><span class="line"></span><br><span class="line">)engine = innodb;</span><br></pre></td></tr></table></figure>
<p>auto_increment 自动增长 用于类似于 ID 的数据（有规律性）</p>
<p>primary key 主键 最主要的 靠它来区分表 </p>
<p>comment 注释</p>
<p>not null 不能为空</p>
<p>default 默认值</p>
<p>engine &#x3D; innodb 数据库引擎类型</p>
<p>展示表结构</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">desc teacher<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> frank,fuck;</span><br></pre></td></tr></table></figure>
<p>修改表：</p>
<p>添加元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>按位元素</p>
<p>之后</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">after</span> Id；</span><br></pre></td></tr></table></figure>
<p>位数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> address <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">first</span>; </span><br></pre></td></tr></table></figure>
<p>删除元素</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> address;</span><br></pre></td></tr></table></figure>
<p>修改元素</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student change address `<span class="keyword">Add</span>` <span class="type">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>修改类型</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student modify Id <span class="type">varchar</span>(<span class="number">11</span>);</span><br></pre></td></tr></table></figure>
<p>修改表名</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">to</span> students;</span><br></pre></td></tr></table></figure>
<p>清空表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> teacher;</span><br></pre></td></tr></table></figure>


<h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a><strong>数据操作</strong></h3><p>插入数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> teacher (Id, <span class="type">name</span>, phone, adress) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;Fuck&#x27;</span>, <span class="string">&#x27;128989&#x27;</span>, <span class="string">&#x27;GuangZhou&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>查看数据</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> teacher;</span><br></pre></td></tr></table></figure>
<p>一次插入多条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> teacher <span class="keyword">values</span> (<span class="keyword">Null</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="keyword">Null</span>, <span class="keyword">default</span>), (<span class="keyword">Null</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="keyword">Null</span>, <span class="keyword">default</span>);</span><br></pre></td></tr></table></figure>
<p>删除数据( 注意 where 后面记得带上数据，否则可能误删多条数据！)</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> teacher <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>清空表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> teacher;</span><br></pre></td></tr></table></figure>
<p>小细节</p>
<p>delete 与 truncate 清表时，delete 会继续接下来的的顺序编号。</p>
<p>更新数据( 同删除数据一样必须带上 where 不然可能带来灾难性的后果）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> teacher <span class="keyword">set</span> <span class="type">name</span> = <span class="string">&#x27;Frank&#x27;</span> <span class="keyword">where</span> <span class="type">name</span> = <span class="string">&#x27;Fuck&#x27;</span>(Id = <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>查询部分数据</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Id, <span class="type">name</span> <span class="keyword">from</span> teacher;</span><br></pre></td></tr></table></figure>
<p>理论部分</p>
<p>DDL data definition language 数据库定义语言 create alter drop show</p>
<p>DML data manipution language 数据库操纵语言 insert update delete select</p>
<p>DCL data control language 数据库控制语言 </p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line"></span><br><span class="line">  -&gt; id <span class="type">smallint</span> unsigned auto_increment <span class="keyword">primary key</span> <span class="keyword">comment</span> <span class="string">&#x27;id&#x27;</span>, </span><br><span class="line"></span><br><span class="line">  -&gt; age tinyint unsigned <span class="keyword">comment</span> <span class="string">&#x27;年龄&#x27;</span>, </span><br><span class="line"></span><br><span class="line">  -&gt; fuck <span class="type">int</span>(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">  -&gt; );</span><br></pre></td></tr></table></figure>
<p><code>unsigned </code></p>
<p>表示正值数据</p>
<p><code>double</code> 类型精度丢失问题</p>
<p>浮点型数据类型会有精度丢失的问题，比如小数位设置 6 位，存入 0.45，0.45 转换成二进制是个无限循环小数 0.01110011100…，无法准确表示，存储的时候会发生精度丢失。</p>
<p><code>Decimal</code>（定点数）</p>
<p>四舍五入后用字符串类型数据进行存储</p>
<p>VarChar 与 Char</p>
<p><code>VarChar</code> 为可变长字符串 节省空间 但是性能较低</p>
<p><code>Char</code> 为定长字符串 空间占用可能较多 但性能高</p>
<p>性能不同原因：VarChar 存储的不仅仅是数据内容，还有字节长度以及节点位置。</p>
<p>Boolean</p>
<p>insert into test values(true&#x2F;false&#x2F;1&#x2F;0);</p>
<p>enum </p>
<p>create table Dmeo(</p>
<p>gender enum(‘women’,’man’,’?’)</p>
<p>);</p>
<p>枚举类型只能用枚举列表里面的元素来赋值（也可以通过整数进行存储）</p>
<p>好处：存储实际上使用整数，速度比字符串快，限制数据节省空间。</p>
<p>set 集合</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Demo(</span><br><span class="line"></span><br><span class="line">hobby_novel <span class="keyword">set</span> (<span class="string">&#x27;secience&#x27;</span>,<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;model&#x27;</span>)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Demo (<span class="string">&#x27;seciece&#x27;</span>,<span class="string">&#x27;model&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>与 enum 相比可以一次选择多个元素</p>
<p>时间</p>
<p>create table Demo(</p>
<p>createdTime date</p>
<p>);</p>
<p>insert into Demo values(‘2022-04-09 11:23:56’);</p>
<h3 id="列属性完整性"><a href="#列属性完整性" class="headerlink" title="列属性完整性"></a><strong>列属性完整性</strong></h3><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>设置主键</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">add</span> <span class="keyword">primary key</span>(id,<span class="type">name</span>);</span><br></pre></td></tr></table></figure>
<p>删除主键</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">drop</span> <span class="keyword">primary</span> <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
<p>主键的唯一性</p>
<p>一个表里只能存在一个主键（复合主键也为一个主键） 并且主键每行数据都不能为空</p>
<h3 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h3><p>设置唯一键</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">add</span> <span class="keyword">unique</span> (phone);</span><br></pre></td></tr></table></figure>
<p>删除唯一键</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> demo <span class="keyword">drop</span> <span class="keyword">index</span> (phone);</span><br></pre></td></tr></table></figure>
<p>主键和唯一键的区别</p>
<p>1.主键不能为空，唯一键可以为空</p>
<p>2.主键只有一个，唯一键可以存在多个</p>
<p>3.主键可以在别的表里用，唯一键只在自己的表里瞎折腾</p>
<p>数据库完整性</p>
<p>1.保证字段完整 eg.保证存在主键、是设置自动增长，有唯一数据</p>
<p>2.保证数据类型正确</p>
<p>3.考虑表里的字段可能会被其他的表所用</p>
<p>4.自己定义约束</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>添加外键</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">create table eatery(</span><br><span class="line"></span><br><span class="line">  -&gt; price int,</span><br><span class="line"></span><br><span class="line">  -&gt; stuId int(<span class="number">4</span>),</span><br><span class="line"></span><br><span class="line">  -&gt; foreign key <span class="function"><span class="params">(stuId)</span> <span class="title">references</span> <span class="title">stuId</span><span class="params">(stuId)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  -&gt;</span> );</span><br></pre></td></tr></table></figure>
<p>后期加入外键</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> eatery_2 <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (stuId) <span class="keyword">references</span> stuId(stuId);</span><br></pre></td></tr></table></figure>
<p>删除外键</p>
<p>先查询 <code>show create table eatery_2;</code></p>
<p>再删除 <code>alter table eatery_2 drop foreign key eatery_2_ ibfk_1;</code></p>
<p>设计时最好在定义表时就设置好外键</p>
<p>置空：用于删除数据</p>
<p>级联：用于更新数据</p>
<p>操作 </p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> eatery <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (stuId) <span class="keyword">references</span> stuId(stuId) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure>
<h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a><strong>关系型数据库</strong></h2><p>关系：两张表的共有字段去确定数据的完整性</p>
<p>行：一条数据 一条数据记录 实体</p>
<p>列：一个字段 属性</p>
<p>数据冗余：虽然会占用空间，但是提高了性能。</p>
<p>实体和实体的关系：一对一，一对多，多对多。</p>
<p>Code 范式</p>
<p>1.确保字段的原子性</p>
<p>2.非键字段必须依赖于键字段 说白了就是别他妈没事找事</p>
<p>3.消除传递依赖</p>
<h3 id="数据查询语句"><a href="#数据查询语句" class="headerlink" title="数据查询语句"></a><strong>数据查询语句</strong></h3><p><strong>单表查询</strong></p>
<p><strong>select</strong></p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;go fuck yourself&#x27;</span> <span class="keyword">as</span> qnmd<span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="number">2</span>*<span class="number">7</span> <span class="keyword">as</span> <span class="keyword">result</span><span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<p><strong>from</strong></p>
<p><strong>dual</strong></p>
<p>伪表：该表主要目的是为了保证在使用 SELECT 语句中的语句的完整性而提供的。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">2</span>*<span class="number">7</span> <span class="keyword">as</span> <span class="keyword">result</span> <span class="keyword">from</span> dual<span class="punctuation">;</span></span><br></pre></td></tr></table></figure>
<p><strong>where</strong> </p>
<p>&lt; &gt; &#x3D; !&#x3D; dddd</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> age &gt;= <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> adress = <span class="string">&#x27;Beijing&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> adress != <span class="string">&#x27;Shanghai&#x27;</span>; </span><br></pre></td></tr></table></figure>
<p>&#x2F;or</p>
<p><strong>in</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> t4 <span class="keyword">where</span> adress <span class="keyword">not</span> <span class="title">in</span>(<span class="params"><span class="string">&#x27;Shanghai&#x27;</span></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> t4 <span class="keyword">where</span> adress <span class="title">in</span>(<span class="params"><span class="string">&#x27;Shanghai&#x27;</span>,<span class="string">&#x27;Beijing&#x27;</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>between and</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">15</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a><strong>聚合函数</strong></h3><p>总和<code> select sum(english) from score;</code></p>
<p>平均 <code>select avg(english) from score;</code></p>
<p>最大<code> select max(english) from score;</code></p>
<p>最小<code>select min(english) from score;</code></p>
<p>次数<code> select count(id) from score; / select count(*) from score;</code></p>
<p><strong>like</strong></p>
<p>查询’张’后面带多个字符</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>‘_’个数表示元素多少个字符</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> <span class="string">&#x27;张__&#x27;</span>; </span><br></pre></td></tr></table></figure>
<p><strong>order by</strong> </p>
<p>升序查询</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> chinese <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>
<p>降序查询</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> score <span class="keyword">order</span> <span class="keyword">by</span> english <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p><strong>group by</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> avg(age) <span class="keyword">as</span> <span class="string">&#x27;年龄&#x27;</span> , address <span class="keyword">as</span> <span class="string">&#x27;地区&#x27;</span> <span class="keyword">from</span> <span class="keyword">info</span> <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p><strong>group_concat()</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(<span class="type">name</span>) , gender <span class="keyword">as</span> <span class="string">&#x27;性别&#x27;</span> <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210141915708.png" alt="image-20221014191523641" style="zoom:33%;" />

<p><strong>having</strong></p>
<p>表示对生成的表进行查询，相当于 where</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> avg(age) <span class="keyword">as</span> <span class="string">&#x27;age&#x27;</span> , address <span class="keyword">from</span> <span class="keyword">info</span> <span class="keyword">group</span> <span class="keyword">by</span> address <span class="keyword">having</span> age &gt; <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><strong>limit</strong></p>
<p>limit 开始位置，结束长度；</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">info</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>distinct all</strong></p>
<p>去重</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count(<span class="keyword">distinct</span> address) <span class="keyword">from</span> <span class="keyword">info</span>; </span><br></pre></td></tr></table></figure>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a><strong>多表查询</strong></h3><p><strong>inner join on</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">name</span>,chinese <span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> score <span class="keyword">on</span> student.id = score.id <span class="keyword">order</span> <span class="keyword">by</span> english <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<p>注意事项：超过两张表时直接在后面继续续写一次语句。</p>
<p><strong>left&#x2F;right join on</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,english <span class="keyword">from</span> student <span class="keyword">left</span>/<span class="keyword">right</span> <span class="keyword">join</span> score <span class="keyword">on</span> student.id = score.id <span class="keyword">order</span> <span class="keyword">by</span> english <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>
<p><strong>cross join</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">cross</span> <span class="keyword">join</span> t3; </span><br></pre></td></tr></table></figure>
<p>有笛卡尔积内味了（数学组合）</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205759542.png" alt="image-20221005205759542" style="zoom: 33%;" />

<p><strong>natural join</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">natural</span> (<span class="keyword">left</span><span class="operator">/</span><span class="keyword">right</span>) <span class="keyword">left</span> <span class="keyword">join</span> t3;</span><br></pre></td></tr></table></figure>
<p>ps.若两表之间无公共字段，则返回的依旧是笛卡尔积。</p>
<p><strong>using</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">inner</span> t3 <span class="keyword">using</span> (<span class="type">name</span>);</span><br></pre></td></tr></table></figure>
<p>ps.当两张表为相同字段时，要采用加上using的结构，否则可能empty set输出。</p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><strong>子查询</strong></h3><p><strong>基本语法</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> student <span class="keyword">where</span> id <span class="title">in</span>(<span class="params"><span class="keyword">select</span> id <span class="keyword">from</span> score <span class="keyword">where</span> english &lt;= <span class="number">85</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>not in</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> student <span class="keyword">where</span> id <span class="keyword">not</span> <span class="title">in</span>(<span class="params"><span class="keyword">select</span> id <span class="keyword">from</span> score <span class="keyword">where</span> chinese &gt;= <span class="number">85</span></span>)</span>;</span><br></pre></td></tr></table></figure>
<p>ps.用in或者not in主要是不止一个结果。</p>
<p><strong>exists &#x2F; not exists</strong></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> id <span class="keyword">from</span> score <span class="keyword">where</span> english &gt;= <span class="number">85</span>); </span><br></pre></td></tr></table></figure>
<p>ps.只要有存在就输出。</p>
<h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p> <strong>视图的创建与查询</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> stu_all <span class="keyword">as</span> <span class="keyword">select</span> <span class="type">name</span>,phone,score <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> vw_stu_all</span><br></pre></td></tr></table></figure>

<p><strong>修改视图</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_all <span class="keyword">as</span> <span class="keyword">select</span> <span class="type">name</span>,phone <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure>

<p><strong>删除视图</strong></p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">drop</span> <span class="built_in">view</span> vw_stu_all</span><br></pre></td></tr></table></figure>

<p><strong>视图算法</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> algorithm=<span class="keyword">merge</span> <span class="keyword">view</span> stu_all <span class="keyword">as</span> <span class="keyword">select</span> name,phone,score <span class="keyword">from</span> student </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Merge算法</p>
</blockquote>
<p>合并算法，每当执行的时候,先将视图的sql语句与外部查询视图的sql语句,合并在一起,最终执行；这样操作对效率基本上没有什么影响</p>
<blockquote>
<p>Temptable</p>
</blockquote>
<p>临时表算法，创建一个临时表用于数据的填充以及查询，当数据量越大时，效率越低，且该视图无法进行update的操作。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><strong>开启事务</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br></pre></td></tr></table></figure>
<p><strong>回滚事务</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">rollback<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>提交事务</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">commit<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210191611437.png" alt="image-20221019161158358" style="zoom:50%;" />

<p><strong>保存回滚点</strong></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">savapoint</span> *；</span><br></pre></td></tr></table></figure>

<p><strong>回到回滚点</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> *;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210191631958.png" alt="image-20221019163142908"></p>
<p><strong>特性：ACID（InnoDB引擎下）</strong></p>
<p>原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>增删改很慢，查很快</p>
<p><strong>创建索引</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> money_index <span class="keyword">on</span> wallet(id);</span><br></pre></td></tr></table></figure>

<p><strong>添加索引</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> wallet <span class="keyword">add</span> <span class="keyword">index</span> money_index (<span class="type">money</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除索引</strong></p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> money_index <span class="keyword">on</span> wallet;</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>delimiter更改结束符号</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br></pre></td></tr></table></figure>

<p><strong>procedure存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create procedure proc()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; update wallet set money=money+50;</span><br><span class="line">    -&gt; insert into wallet values(5,3737);</span><br><span class="line">    -&gt; end //</span><br></pre></td></tr></table></figure>

<p><strong>执行存储</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">call <span class="title">proc</span>()</span>;</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210200006857.png" alt="image-20221020000510172" style="zoom:50%;" />

<p><strong>函数</strong></p>
<p><em>数字</em></p>
<p>rand()随机数</p>
<p>ceil()向上取整</p>
<p>round()向下取整</p>
<p>floor()向下取整</p>
<p>truncate(112,2)截取数字</p>
<p><em>字符串</em></p>
<p>ucase()大写</p>
<p>lcase()小写</p>
<p>left&#x2F;right(‘fuck’,2)截取</p>
<p>substring(‘fuck’,1,3)截取中间</p>
<p>concat(‘fu’,’ck’)拼接字符串</p>
<p><em>时间</em></p>
<p>unix_timestamp()时间毫秒值</p>
<p>year&#x2F;month&#x2F;day(now())获取当前年&#x2F;月&#x2F;日</p>
<p><em>加密</em></p>
<p>sha(‘fuck’);</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2022/10/02/Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p><strong>1.软件程序的运行</strong></p>
<p>硬件如同人的身体，软件如同人的灵魂。没有了灵魂的躯体也不过就是行尸走肉</p>
<p>**1.1 **机器程序与编译程序</p>
<p>电脑只认识0与1而已，而且电脑最重要的运算与逻辑判断是在CPU内部， 而 CPU其实是具有微指令集的。因此，我们需要CPU帮忙工作时，就得要参考微指令集的内容， 然后撰写让CPU读的懂的指令码给CPU执行，这样就能够让CPU运行了。</p>
<p>流程：</p>
<ul>
<li>需要了解机器语言：机器只认识0与1，因此你必须要学习直接写给机器看的语言。</li>
<li>需要了解所有硬件的相关功能函数：因为你的程序必须要写给机器看， 当然你就得要参考机器本身的功能，然后针对该功能去撰写程序码。</li>
<li>程序不具有可携性：每个CPU都有独特的微指令集，同样的，每个硬件都有其功能函数。</li>
<li>程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写， 如果已经开发了一支浏览器程序，想要再开发文件管理程序时，还是得从头再参考硬件的功能函数来继续撰写。</li>
</ul>
<p>所以，需要开发让人类能看得懂得程序语言。然后创造一种“编译器”让人类的写的程序语言转换为机器能看懂的机器码。常见的编译器有C,C++,Java,Fortran等等。</p>
<p><img src="https://dreamin-1312842512.cos.ap-guangzhou.myqcloud.com/image-20220922203728264.png" alt="image-20220922203728264"></p>
<h2 id="关于学习Linux"><a href="#关于学习Linux" class="headerlink" title="关于学习Linux"></a>关于学习Linux</h2><p>两个重要的因素是造成我们学习的原动力： </p>
<ul>
<li><p>创建兴趣： Linux上面可以玩的东西真的太多了，你可以选择一个有趣的课题来深入的玩 一玩！不论是Shell还是图形接口等等， 只要能够玩出兴趣，那么再怎么苦你都会不觉得喔！</p>
</li>
<li><p>成就感： 成就感是怎么来的？说实在话，就是“被认同”来的！怎么被认同呢？写心得分享啊！当你写了心得分享，并且公告在 BBS 上面，自然有朋友会到你的网页去瞧一瞧， 当大家觉得你的网页内容很棒的时候， 哈哈！你肯定会加油继续的分享下去而无法自拔。</p>
</li>
</ul>
<h2 id="主机规划与磁盘分区"><a href="#主机规划与磁盘分区" class="headerlink" title="主机规划与磁盘分区"></a>主机规划与磁盘分区</h2><p><strong>Linux各硬件设备在系统中为文件名</strong></p>
<p><img src="https://dreamin-1312842512.cos.ap-guangzhou.myqcloud.com/image-20221001164035525.png" alt="image-20221001164035525"></p>
<p><strong>磁盘分区</strong></p>
<p><strong>MBR 主要分区、延伸分区与逻辑分区的特性：</strong></p>
<ul>
<li>主要分区与延伸分区最多可以有四笔（硬盘的限制） ；</li>
<li>延伸分区最多只能有一个（操作系统的限制）；</li>
<li>逻辑分区是由延伸分区持续切割出来的分区；</li>
<li>能够被格式化后，作为数据存取的分区为主要分区与逻辑分区。延伸分区无法格式化； </li>
<li>逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制；</li>
</ul>
<p><strong>MBR分区限制：</strong></p>
<ul>
<li>操作系统无法抓取到 2.2T 以上的磁盘容量</li>
<li>MBR 仅有一个区块，若被破坏后，经常无法或很难救援</li>
<li>MBR 内的存放开机管理程序的区块仅 446Bytes，无法容纳较多的程序码</li>
</ul>
<p><strong>GUID partition table, GPT 磁盘分区表：</strong></p>
<ul>
<li>与 MBR 仅使用第一个 512Bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息</li>
<li>GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份</li>
</ul>
<p><strong>计算机开机流程：</strong></p>
<ol>
<li>BIOS：开机主动执行的固件，会认识第一个可开机的设备；</li>
<li>MBR：第一个可开机设备的第一个扇区内的主要开机记录区块，内含开机管理程序；</li>
<li>开机管理程序（boot loader）：一支可读取核心文件来执行的软件；</li>
<li>核心文件：开始操作系统的功能</li>
</ol>
<p><strong>BIOS与UEFI BIOS区别</strong></p>
<p><img src="https://dreamin-1312842512.cos.ap-guangzhou.myqcloud.com/image-20221001200526805.png" alt="image-20221001200526805"></p>
<p><strong>主机硬盘的规划</strong></p>
<p>频繁读写的目录</p>
<ul>
<li>boot</li>
<li>&#x2F; </li>
<li>&#x2F;home </li>
<li>&#x2F;var </li>
<li>Swap</li>
</ul>
<p>1):&#x2F;bin   [***]   (&#x2F;usr&#x2F;bin 、 &#x2F;usr&#x2F;local&#x2F;bin) • 是Binary的缩写, 这个目录存放着最经常使用的命令。</p>
<p>2): &#x2F;sbin (&#x2F;usr&#x2F;sbin 、 &#x2F;usr&#x2F;local&#x2F;sbin) • s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
<p>3):&#x2F;home [***] • 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般 该目录名是以用户的账号命名的。</p>
<p>4):&#x2F;root [***] • 该目录为系统管理员，也称作超级权限者的用户主目录。</p>
<p>5): &#x2F;lib • 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几 乎所有的应用程序都需要用到这些共享库。</p>
<p>6):&#x2F;lost+found • 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
<p>7):&#x2F;etc [***] • 所有的系统管理所需要的配置文件和子目录 my.conf </p>
<p>8):&#x2F;usr  [***] • 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows下的program files目录</p>
<p>9):&#x2F;boot [***] • 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</p>
<p>10):&#x2F;srv • service缩写，该目录存放一些服务启动之后需要提取的数据。</p>
<p>11):&#x2F;sys • 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs</p>
<p>12):tmp • 这个目录是用来存放一些临时文件的</p>
<p>13):&#x2F;dev • 类似于windows的设备管理器，把所有的硬件用文件的形式存储。</p>
<p>14):&#x2F;media [***] • linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</p>
<p>15):&#x2F;mnt [***] • 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。</p>
<p>16):&#x2F;opt     • 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下，默认为空。</p>
<p>17):&#x2F;usr&#x2F;local [***] • 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p>
<p>18):&#x2F;var [***] • 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p>
<h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul>
<li><p>如果磁盘容量大于 2TB 以上时，系统会自动使用 GPT 分区方式来处理磁盘分区。</p>
</li>
<li><p>GPT 分区已经没有延伸与逻辑分区的概念，可以想像成所有的分区都是主分区，某些操作系统要使用 GPT 分区时，必须要搭配 UEFI 的新型 BIOS 格式才可安装使用。</p>
</li>
<li><p>Linux操作系统的文件使用目录树系统，与磁盘的对应需要有“挂载”的动作才行；</p>
</li>
<li><p>开机的流程由：BIOS–&gt;MBR–&gt;–&gt;boot loader–&gt;核心文件</p>
</li>
</ul>
<h2 id="Vim程序编辑器"><a href="#Vim程序编辑器" class="headerlink" title="Vim程序编辑器"></a>Vim程序编辑器</h2><p><strong>三种模式</strong></p>
<ul>
<li>一般指令模式 （command mode）</li>
<li>编辑模式 （insert mode）</li>
<li>命令行命令模式 （command-line mode）</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210211616324.png" alt="image-20221021161616258" style="zoom:50%;" />

<p><strong>常见命令</strong></p>
<p><em>1.输入模式 (i):</em><br>按 i 进入insert输入模式<br>HJKL代替上下左右<br>H向左 L向右 J向下 K向上<br>Ctrl + B 向上翻页<br>Ctrl + F 想下翻页<br>Ctrl + E&#x2F;Y 滚动<br>Shift + G 末尾<br>双击gg 首字符</p>
<p><em>2.命令模式(esc):</em><br>i 光标位置前面输入<br>a 光标位置后面输入<br>o enter到下一行输入<br>x 删除光标所在字符<br>dd 删除整个一行<br>u 撤销<br>dw 删除整个单词<br>b 跳跃单词首字母<br>e 跳跃单词尾字母<br>w 跳跃到下一个单词首字母</p>
<p>shift 省略多个单词直接跳<br>Shift + 6 ^ 跳跃到本行的首字母<br>Shift + 4 $ 跳跃到本行的dd尾字母<br>按 0 跳跃到本行首个字符（ 包括空格）<br>{}移动整段大括号<br>yw 表示复制一个单词<br>y$ 表示从当前开始，往后复制到行末尾<br>p 粘贴剪贴板的内容<br><em>3.可视化模式</em><br>v + hjkl 进行字符选择<br>V + hjkl 进行行选择<br>v + G 全选<br>快捷选择<br>vaw 快速选择单词<br>vab 包含括号<br>vaB 包含大括号<br>shift + &lt;&gt; 前后缩进<br>v shift + · ~ 字母大小写切换<br>v + u&#x2F;U 全部转换为小写&#x2F;大写<br>行号+g<br>g 跳跃到指定的行号<br>快速查找<br>&#x2F;查找字符 按n 进入下一个<br>快速替换<br>按行:s&#x2F;查找单词&#x2F;替换单词&#x2F;g<br>全局:%s&#x2F;查找单词&#x2F;替换单词&#x2F;g<br>指定:首，尾s&#x2F;查找&#x2F;替换&#x2F;g<br>+c 询问</p>
<h2 id="Bashshell"><a href="#Bashshell" class="headerlink" title="Bashshell"></a>Bashshell</h2><p><strong>硬件、核心与 Shell</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221653386.png" alt="image-20221022165342252" style="zoom:50%;" />

<p>例子：用电脑播放音乐</p>
<ol>
<li>硬件：当然就是需要你的硬件有“声卡芯片”这个配备，否则怎么会有声音；</li>
<li>核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序；</li>
<li>应用程序：需要使用者输入发生声音的指令。</li>
</ol>
<p><strong>为何要学命令行的 shell？</strong></p>
<ul>
<li><p>命令行的 shell：大家都一样</p>
</li>
<li><p>远端管理：命令行就是比较快</p>
</li>
<li><p>Linux 的任督二脉： shell 是也</p>
</li>
</ul>
<p><strong>系统的合法 shell 与 &#x2F;etc&#x2F;shells 功能</strong></p>
<p>历史：由于早年的 Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有许多的版本，例如常听到的 Bourne SHell （sh） 、在 Sun 里头默认的 C SHell、 商业上常用的 K SHell、, 还有 TCSH 等等，每一种 Shell 都各有其特点，Linux 使用的这一种版本就称为“ Bourne Again SHell （简称 bash） ”，这个 Shell 是 Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的。</p>
<p><em>Linux可用的shells</em></p>
<ul>
<li>&#x2F;bin&#x2F;sh （已经被 &#x2F;bin&#x2F;bash 所取代）</li>
<li>&#x2F;bin&#x2F;bash （就是 Linux 默认的 shell）</li>
<li>&#x2F;bin&#x2F;tcsh （整合 C Shell ，提供更多的功能）</li>
<li>&#x2F;bin&#x2F;csh （已经被 &#x2F;bin&#x2F;tcsh 所取代）</li>
</ul>
<blockquote>
<p>系统某些服务在运行过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是借由 &#x2F;etc&#x2F;shells 这个文件</p>
</blockquote>
<p><strong>Bash Shell 的功能</strong></p>
<ul>
<li>命令编修能力 （history）：</li>
</ul>
<p>只要在命令行按“上下键”就可以找到前&#x2F;后一个输入的指令，而在很多distribution 里头，默认的指令记忆功能可以到达 1000 个！也就是说，曾经下达过的指令几乎都被记录下来了。<br>这么多的指令记录在哪里呢？在你的主文件夹内的 .bash_history 不过，需要留意的是，<br>~&#x2F;.bash_history 记录的是前一次登陆以前所执行过的指令， 而至于这一次登陆所执行的指令都被暂存在内存中，当你成功的登出系统后，该指令记忆才会记录到 .bash_history 当中</p>
<ul>
<li><p>命令与文件补全功能： （[tab] 按键的好处）</p>
</li>
<li><p>命令别名设置功能： （alias）</p>
</li>
</ul>
<p>可以将<code>ls -al</code> 的命令通过<code>alias lm=&#39;ls -al&#39;</code>就可以将<code>lm</code>直接用来调命令了</p>
<ul>
<li><p>工作控制、前景背景控制： （job control, foreground, background）</p>
</li>
<li><p>程序化脚本： （shell scripts）</p>
</li>
<li><p>万用字符： （Wildcard）</p>
</li>
</ul>
<p><strong>查询指令是否为 Bash shell 的内置命令： type</strong></p>
<p>知道这个指令是来自于外部指令（指的是其他非 bash 所提供的指令） 或是内置在 bash 当中只要利用type 这个指令来观察即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="built_in">type</span> [-tpa] name</span><br><span class="line">选项与参数：</span><br><span class="line">：不加任何选项与参数时，<span class="built_in">type</span> 会显示出 name 是外部指令还是 bash 内置指令</span><br><span class="line">-t ：当加入 -t 参数时，<span class="built_in">type</span> 会将 name 以下面这些字眼显示出他的意义：</span><br><span class="line">file ：表示为外部指令；</span><br><span class="line"><span class="built_in">alias</span> ：表示该指令为命令别名所设置的名称；</span><br><span class="line"><span class="built_in">builtin</span> ：表示该指令为 bash 内置的指令功能；</span><br><span class="line">-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 <span class="built_in">alias</span></span><br><span class="line">范例一：查询一下 <span class="built_in">ls</span> 这个指令是否为 bash 内置？</span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">type</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> is aliased to `<span class="built_in">ls</span> --color=auto<span class="string">&#x27; &amp;lt;==未加任何参数，列出 ls 的最主要使用情况</span></span><br><span class="line"><span class="string">[dmtsai@study ~]$ type -t ls</span></span><br><span class="line"><span class="string">alias &amp;lt;==仅列出 ls 执行时的依据</span></span><br><span class="line"><span class="string">[dmtsai@study ~]$ type -a ls</span></span><br><span class="line"><span class="string">ls is aliased to `ls --color=auto&#x27;</span> &amp;lt;==最先使用 aliase</span><br><span class="line"><span class="built_in">ls</span> is /usr/bin/ls &amp;lt;==还有找到外部指令在 /bin/ls</span><br><span class="line">范例二：那么 <span class="built_in">cd</span> 呢？</span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">type</span> <span class="built_in">cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span> &amp;lt;==看到了吗？ <span class="built_in">cd</span> 是 shell 内置指令</span><br></pre></td></tr></table></figure>

<p><strong>指令的下达与快速编辑按钮</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">范例：如果指令串太长的话，如何使用两行来输出？</span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">cp</span> /var/spool/mail/root /etc/crontab \</span><br><span class="line">&amp;gt; /etc/fstab /root</span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221744722.png" alt="image-20221022174441674" style="zoom: 80%;" />

<h3 id="Shell-的变量功能"><a href="#Shell-的变量功能" class="headerlink" title="Shell 的变量功能"></a><strong>Shell 的变量功能</strong></h3><ul>
<li>变量的可变性与方便性</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221748828.png" alt="image-20221022174833790" style="zoom: 67%;" />

<p>由于系统已经帮我们规划好 MAIL 这个变量，所以使用者只要知道 mail 这个指 令如何使用即可， mail 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了</p>
<ul>
<li>影响 bash 环境操作的变量</li>
</ul>
<p>例如下达 ls 这个指令时，系统就是通过 PATH 这个变量里面的内容所记录的路径顺序来搜寻指令。如果在搜寻完 PATH 变量内的路径还找不到 ls 这个指令时， 就会在屏幕上显示“ command not found ”的错误讯息了。</p>
<ul>
<li>脚本程序设计 （shell script） 的好帮手</li>
</ul>
<p>例如你要写一个大 型的 script 时，有些数据因为可能由于使用者习惯的不同而有差异，比如说路径好了，由于该路径在 script 被使用在相当多的地方，如果下次换了一部主机，都要修改 script 里面的所有路径， 这个时候如果使用变量，而将该变量的定义写在最前面，后面相关的路径名称都以变量来取代， 那么你只要修改一行就等于修改整篇 script 了。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221753121.png" alt="image-20221022175328075" style="zoom:67%;" />

<p><strong>变量的取用与设置：echo, 变量设置规则, unset</strong></p>
<p>可以利用 echo 这个指令来取用变量， 但是，变量在被取用时， 前面必须要加上钱字号“ $ ”才行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ <span class="built_in">echo</span> <span class="variable">$variable</span></span><br><span class="line"></span><br><span class="line">[mua@localhost ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/mua/.local/bin:/home/mua/bin</span><br><span class="line">[mua@localhost ~]$ <span class="built_in">echo</span> <span class="variable">$&#123;PATH&#125;</span> <span class="comment"># 比较规范的形式</span></span><br><span class="line">/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/mua/.local/bin:/home/mua/bin</span><br><span class="line"><span class="comment"># 设置变量名</span></span><br><span class="line">[mua@localhost 桌面]$ fuck=myname</span><br><span class="line">[mua@localhost 桌面]$ <span class="built_in">echo</span> <span class="variable">$fuck</span></span><br><span class="line">myname</span><br><span class="line">[mua@localhost 桌面]$ fuck=VBird</span><br><span class="line">[mua@localhost 桌面]$ <span class="built_in">echo</span> <span class="variable">$fuck</span></span><br><span class="line">VBird</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>变量与变量内容以一个等号“&#x3D;”来链接，如下所示： “myname&#x3D;VBird”</li>
<li>等号两边不能直接接空白字符，如下所示为错误： “myname &#x3D; VBird”或“myname&#x3D;VBird Tsai”</li>
<li>变量名称只能是英文字母与数字，但是开头字符不能是数字，如下为错误：“2myname&#x3D;VBird”</li>
<li>变量内容若有空白字符可使用双引号“””或单引号“’”将变量内容结合起来，但<ul>
<li>双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示： “var&#x3D;”lang is$LANG””则“echo $var”可得“lang is zh_TW.UTF-8”</li>
<li>单引号内的特殊字符则仅为一般字符 （纯文本），如下所示： “var&#x3D;’lang is $LANG’”则“echo $var”可得“lang is $LANG”</li>
</ul>
</li>
<li>可用跳脱字符“ \ ”将特殊符号（如 [Enter], $, , 空白字符, ‘等）变成一般字符，如：“myname&#x3D;VBird\ Tsai”</li>
<li>在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“ 指令 ”或 “$（指令）”。特别注意，那个 &#96; 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 例如想要取得核心版本的设置： “version&#x3D;$（uname -r）”再“echo$version”可得“3.10.0-229.el7.x86_64”</li>
<li>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容，如下所示：“PATH&#x3D;”$PATH”:&#x2F;home&#x2F;bin”或“PATH&#x3D;${PATH}:&#x2F;home&#x2F;bin”</li>
<li>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量： “exportPATH”</li>
<li>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好） </li>
<li>取消变量的方法为使用 unset ：“unset 变量名称”例如取消 myname 的设置： “unsetmyname”</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 范例一：设置变量hr 内容为fuck</span></span><br><span class="line">[mua@localhost ~]$ 16hr=fuck</span><br><span class="line">bash: 16hr=fuck: 未找到命令...  <span class="comment">## 变量开头为数字</span></span><br><span class="line">[mua@localhost ~]$ 16hr = fuck</span><br><span class="line">bash: 16hr: 未找到命令...  <span class="comment">## 变量等于号两侧存在空格</span></span><br><span class="line"><span class="comment"># 范例二：当变量内容为fuck&#x27;s name</span></span><br><span class="line">[mua@localhost ~]$ hr=fuck<span class="string">&#x27;s name</span></span><br><span class="line"><span class="string">&gt; ^C ## 单引号与双引号必须要成对，当你按下 enter 后，提示继续输入变量内容</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ hr=&quot;fuck&#x27;</span>s name<span class="string">&quot; ## 成功创建</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ hr=&#x27;fuck&#x27;s name&#x27;</span></span><br><span class="line"><span class="string">&gt; ^C ## 因为前两个单引号已成对，后面就多了一个不成对的单引号，提示继续输入</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ hr=fuck\&#x27;s\ name ## 用跳脱字符成功创建</span></span><br><span class="line"><span class="string"># 范例三：要在 PATH 这个变量当中“累加”:/home/dmtsai/bin 这个目录</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ PATH=<span class="variable">$PATH</span>:/home/mua/bin</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ PATH=&quot;</span><span class="variable">$PATH</span><span class="string">&quot;:/home/mua/bin</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ PATH=<span class="variable">$&#123;PATH&#125;</span>:/home/mua/bin</span></span><br><span class="line"><span class="string"># 范例四：将 hr 的内容多出 &quot;</span><span class="built_in">yes</span><span class="string">&quot; </span></span><br><span class="line"><span class="string">[mua@localhost ~]$ echo <span class="variable">$hryes</span></span></span><br><span class="line"><span class="string">## 没有双引号，变量name 的内容就是 <span class="variable">$nameyes</span> 这个变量</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ echo &quot;</span><span class="variable">$hr</span><span class="string">&quot;yes</span></span><br><span class="line"><span class="string">yes ## 成功添加</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ echo <span class="variable">$&#123;hr&#125;</span>yes</span></span><br><span class="line"><span class="string">yes ## 成功添加，以此例子为标准</span></span><br><span class="line"><span class="string"># 范例五：让刚刚设置的 name=VBird 可以用在下个 shell 的程序</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ hr=fuck ## 赋值变量</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ bash ## 进入子进程</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ echo <span class="variable">$hr</span> </span></span><br><span class="line"><span class="string">## 调用失败</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ exit</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ export hr ## 设置系统环境变量</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ bash </span></span><br><span class="line"><span class="string">[mua@localhost ~]$ echo <span class="variable">$hr</span></span></span><br><span class="line"><span class="string">fuck ## 调用成功</span></span><br><span class="line"><span class="string">[mua@localhost ~]$ exit</span></span><br><span class="line"><span class="string">exit</span></span><br><span class="line"><span class="string"># 范例六：进入到目前核心的模块目录</span></span><br></pre></td></tr></table></figure>

<h3 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h3><blockquote>
<p>数据流:分三种，标准输入流（由键盘输入产生），标准输出流（执行命令的输出日志），标准错误输出流(同理）</p>
</blockquote>
<p><strong>什么是数据流重导向</strong></p>
<p>将本应由键盘输入或输出到屏幕上的数据流重定向到文件或设备上（保存到文件或设备中），称之为数据流重定向</p>
<p><strong>数据流重定向的作用</strong></p>
<ul>
<li>屏幕输出信息需要保存</li>
<li>后台执行程序，不想将日志打在桌面上</li>
<li>区分输出标准输出与标准错误输出处理时</li>
<li>丢弃已知错误信息，<code>2&gt; /dev/null</code></li>
</ul>
<p><strong>代号与表现方式</strong></p>
<ol>
<li>标准输入 （stdin） ：代码为 <code>0</code> ，使用 <code>&lt; </code>或 <code>&lt;&lt;</code> ；</li>
<li>标准输出 （stdout）：代码为 <code>1</code> ，使用 <code>&gt;</code> 或 <code>&gt;&gt;</code> ；</li>
<li>标准错误输出（stderr）：代码为 <code>2</code> ，使用 <code>2&gt;</code> 或 <code>2&gt;&gt;</code> ；</li>
</ol>
<p>区别</p>
<ul>
<li><code>&gt;</code> ：以【覆盖】的方式，将【正确的数据】输出到文件或设备上</li>
<li><code>&gt;&gt;</code>：以【追加】的方式，将【正确的数据】输出到文件或设备上</li>
<li><code>2&gt;</code>：以【覆盖】的方式，将【错误的数据】输出到文件或设备上</li>
<li><code>2&gt;&gt;</code>：以【追加】的方式，将【错误的数据】输出到文件或设备上</li>
</ul>
<p><strong>黑洞 &#x2F;dev&#x2F;null</strong></p>
<p>当需要将某些日志不重要的数据流重定向走，但又不想保存文件占用空间时，重定向数据流 <code>/dev/null</code> 设备上，相当于将数据丢入黑洞</p>
<p>Eg:</p>
<p>将标准输出丢入黑洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mua]<span class="comment"># cat /etc/profile &gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<p>将标准错误输出丢入黑洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost mua]<span class="comment"># find / -name .bashrc 2&gt; /dev/null</span></span><br></pre></td></tr></table></figure>

<p><strong>将stdout与stderr输出到同一文件或设备</strong></p>
<p>分别设置stdout与stderr到同一文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ find / -name .bashrc &gt; /tmp/stdtestlogs1 2&gt; /tmp/stdtestlogs1</span><br></pre></td></tr></table></figure>

<p>输出两者带同一文件中，语法<code>command &gt;[file]&gt;&amp;1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ find / -name .bashrc &amp; /tmp/stdtustlogs2 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>&amp;语法<code>[command]&amp;&gt;[file] </code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ find / -name .bashrc &amp;&gt; /tmp/stdtestlogs3</span><br></pre></td></tr></table></figure>

<p>将所有日志输入黑洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ find / -name .bashrc &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>将错误日志输入黑洞</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ find / -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<p><strong>标准输入流重定向 &lt; 与 &lt;&lt;</strong></p>
<p>将原本由键盘输入的数据，改由文件内容提供（<code>&lt;</code> 表示使用文件提供数据，<code>&lt;&lt;</code> 用来【设置输入结束的字符】）</p>
<p>例如：</p>
<p>将<code>~/.bashrc</code>输出重定向到<code>/tmp/stdintest</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ <span class="built_in">cat</span> &gt; /tmp/stdintest &lt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>设置【输入结束字符】，将一段文字输入到<code>/tmp/stdintest2</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mua@localhost ~]$ <span class="built_in">cat</span> &gt; /tmp/stdintest &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&gt; 这是一条测试</span></span><br><span class="line"><span class="string">&gt; 这是一条测</span></span><br><span class="line"><span class="string">&gt; 这是一条</span></span><br><span class="line"><span class="string">&gt; 这是一</span></span><br><span class="line"><span class="string">&gt; 这是</span></span><br><span class="line"><span class="string">&gt; 这</span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br></pre></td></tr></table></figure>

<p><strong>命令执行的判断依据： ; , &amp;&amp;, ||</strong></p>
<ul>
<li><code>cmd</code> ; <code>cmd</code>(不考虑前者是否执行成功)</li>
</ul>
<p>eg.进行sync同步化再进行关机命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync</span>; <span class="built_in">sync</span>; shutdown -h now</span><br></pre></td></tr></table></figure>

<ul>
<li><code>$?</code> （指令回传值） 与 <code>&amp;&amp;</code> 或 <code>||</code></li>
</ul>
<table>
<thead>
<tr>
<th>执行下达情况</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>cmd1&amp;&amp;cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行（$?&#x3D;0），则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。</td>
</tr>
<tr>
<td>cmd1||cmd2</td>
<td>1. 若 cmd1 执行完毕且正确执行（$?&#x3D;0），则 cmd2 不执行。 2. 若 cmd1 执 行完毕且为错误 （$?≠0），则开始执行 cmd2。</td>
</tr>
</tbody></table>
<p><em>练习</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 先查询有无此目录再创建xixi这个文件</span></span><br><span class="line">[mua@localhost ~]$ <span class="built_in">ls</span> /tmp/abc &amp;&amp; <span class="built_in">touch</span> /tmp/abc/xixi</span><br><span class="line"><span class="built_in">ls</span>: cannot access /tmp/abc: No such file or directory <span class="comment">#查询无</span></span><br><span class="line">[mua@localhost home]$ <span class="built_in">mkdir</span> /tmp/abc <span class="comment"># 创建文件夹</span></span><br><span class="line">[mua@localhost home]$ <span class="built_in">ls</span> /tmp/abc &amp;&amp; <span class="built_in">touch</span> /tmp/abc/xixi <span class="comment">#执行成功</span></span><br><span class="line"><span class="comment">#总结 如果查询不到，就不会执行下一个语句</span></span><br><span class="line"><span class="comment">##总是尝试执行语句</span></span><br><span class="line">[mua@localhost ~]$ <span class="built_in">ls</span> /tmp/abc &amp;<span class="comment">#124;&amp;#124; mkdir /tmp/abc &amp;&amp; /tmp/abc/hehe</span></span><br></pre></td></tr></table></figure>

<p>上条执行判断流程图</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251704834.png" alt="image-20221125170424765" style="zoom: 67%;" />

<p>参考<a href="https://www.cnblogs.com/chengmo/archive/2010/10/20/1855805.html">linux shell数据重定向</a></p>
<h3 id="管线命令pipe"><a href="#管线命令pipe" class="headerlink" title="管线命令pipe"></a>管线命令pipe</h3><p>管道命令的操作符时“|”，它仅能处理经由前面一个指令传出的正确输出信息，也就是 standard output 的信息，对于 stdandard<br>error 信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入 standard input.</p>
<h2 id="Linux正则表达式"><a href="#Linux正则表达式" class="headerlink" title="Linux正则表达式"></a>Linux正则表达式</h2><p><strong>概念：</strong>正则表达式 （Regular Expression, RE, 或称为常规表达式）是通过一些特殊字符的排列，用以“搜寻&#x2F;取代&#x2F;删除”一列或多列文字字串， 简单的说，正则表达式就是用在字串的处理上面的 一项“表示式”。正则表达式并不是一个工具程序， 而是一个字串处理的标准依据，如果想要以正则表达式的方式处理字串，就得要使用支持正则表达式的工具程序才行， 这类的工具程序很多，例如 vi, sed, awk 等等</p>
<ul>
<li>例如</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">mua@fuck:~$ <span class="keyword">grep</span> <span class="string">&#x27;ls&#x27;</span> <span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>*</span><br><span class="line"><span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>accounts-daemon.service:ProtectHome=<span class="keyword">false</span></span><br><span class="line"><span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>accounts-daemon.service:PrivateTmp=<span class="keyword">false</span></span><br><span class="line"><span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>accounts-daemon.service:PrivateUsers=<span class="keyword">false</span></span><br><span class="line"><span class="regexp">/lib/</span>systemd<span class="regexp">/system/</span>alsa-restore.service:# can be switched using a <span class="keyword">file</span> exist check - <span class="regexp">/etc/</span>alsa/state-daemon.conf .</span><br></pre></td></tr></table></figure>

<ul>
<li>正则表达式对于系统管理员的用途</li>
</ul>
<p>由于系统如果在繁忙的情况之下，每天产生的讯息信息会多到你无法想像的地步，运用正则表达式极度简化操作人员从千百行的数据里面找出一行有问题的讯息的效率。</p>
<h3 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h3><p><em><strong>语系对正则表达式的影响</strong></em></p>
<p>文件其实记录的仅有 0 与 1，我们看到的字符文字与数字都是通过编码表转换来的。由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异了。所以使用正则表达式时，需要特别留意当时环境的语系为何， 否则可能会发现与别人不相同的撷取结果。</p>
<ul>
<li>“ LANG&#x3D;C ”语系数据“ 						<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211061012414.png" alt="image-20221106101250300" style="zoom: 67%;" /></li>
</ul>
<p><em><strong>grep 的一些进阶选项</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mua@fuck:~$ grep [-A] [-B] [--color=auto] <span class="string">&#x27;搜寻字串&#x27;</span> filename</span><br><span class="line">选项与参数：</span><br><span class="line">-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；</span><br><span class="line">-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；</span><br><span class="line">--color=auto 可将正确的那个撷取数据列出颜色</span><br></pre></td></tr></table></figure>

<p><em><strong>基础正则表达式练习</strong></em></p>
<ul>
<li>搜寻特定字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mua@fuck:~$  grep -n <span class="string">&#x27;the&#x27;</span> regular_express.txt</span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.^M</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">16:The world &amp;lt;Happy&amp;gt; is the same with &quot;glad&quot;.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">// 反向</span></span><br><span class="line"><span class="string">mua@fuck:~$ grep -vn &#x27;</span>the<span class="string">&#x27; regular_express.txt</span></span><br><span class="line"><span class="string">//不论大小写</span></span><br><span class="line"><span class="string">mua@fuck:~$ grep -in &#x27;</span>the<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">8:I can&#x27;</span>t finish the <span class="built_in">test</span>.^M</span><br><span class="line">9:Oh! The soup taste good.^M</span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.^M</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br><span class="line">16:The world &amp;lt;Happy&amp;gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br></pre></td></tr></table></figure>

<ul>
<li>利用中括号[]来搜寻集合字符</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用字符共通点</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;t[ae]st&#x27; regular_express.txt</span></span><br><span class="line">8:I can<span class="string">&#x27;t finish the test.</span></span><br><span class="line"><span class="string">9:Oh! The soup taste good.</span></span><br><span class="line"><span class="string"># 搜寻字符带有**</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>[^g]oo<span class="string">&#x27; regular_express.txt</span></span><br><span class="line"><span class="string">2:apple is my favorite food.</span></span><br><span class="line"><span class="string">3:Football game is not use feet only.</span></span><br><span class="line"><span class="string">18:google is the best tools for search keyword.</span></span><br><span class="line"><span class="string">19:goooooogle yes!</span></span><br><span class="line"><span class="string">#  搜寻带数字</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>[0-9]<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">5:However, this dress is about $ 3183 dollars.</span></span><br><span class="line"><span class="string">15:You are the best is mean you are the no. 1.</span></span><br><span class="line"><span class="string">//其他写法</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>[[:digit:]]<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string"># 带小写字母</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>[^a-z]oo<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">3:Football game is not use feet only.</span></span><br><span class="line"><span class="string">//其他写法</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>[^[:lower:]]oo<span class="string">&#x27; regular_express.txt </span></span><br></pre></td></tr></table></figure>

<ul>
<li>行首与行尾字符 ^ $</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 句首</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;^the&#x27; regular_express.txt </span></span><br><span class="line">12:the symbol <span class="string">&#x27;*&#x27;</span> is represented as start.</span><br><span class="line"><span class="comment"># 句首为小写</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;^[a-z]&#x27; regular_express.txt </span></span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">4:this dress doesn<span class="string">&#x27;t fit me.</span></span><br><span class="line"><span class="string">10:motorcycle is cheap than car.</span></span><br><span class="line"><span class="string">12:the symbol &#x27;</span>*<span class="string">&#x27; is represented as start.</span></span><br><span class="line"><span class="string">//其他写法</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>^[[:lower:]]<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string"># 开头不是字母</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>^[^a-zA-Z]<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string">1:&quot;Open Source&quot; is a good mechanism to develop programs.</span></span><br><span class="line"><span class="string">21:# I am VBird</span></span><br><span class="line"><span class="string">//其他写法</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>^[^[:alpha:]]<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string"># 以句号作为结尾（用到跳脱字符&#x27;</span>\<span class="string">&#x27;）</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>\.$<span class="string">&#x27; regular_express.txt </span></span><br><span class="line"><span class="string"># 找出空白行</span></span><br><span class="line"><span class="string">root@fuck:/test# grep -n &#x27;</span>^$<span class="string">&#x27; regular_express.txt </span></span><br></pre></td></tr></table></figure>

<ul>
<li>任意一个字符.与重复字符 *</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  .（小数点）：代表“一定有一个任意字符”的意思；</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;g..d&#x27; regular_express.txt </span></span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">16:The world &amp;lt;Happy&amp;gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line"><span class="comment">#  *（星星号）：代表“重复前一个字符， 0 到无穷多次”的意思，为组合形态 </span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;ooo*&#x27; regular_express.txt </span></span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">// 中间间隔</span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;g*g&#x27; regular_express.txt </span></span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line"><span class="comment"># 单个字符 g....g</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;g.*g&#x27; regular_express.txt </span></span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">14:The gd software is a library <span class="keyword">for</span> drafting programs.</span><br><span class="line">16:The world &amp;lt;Happy&amp;gt; is the same with <span class="string">&quot;glad&quot;</span>.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line"><span class="comment"># 任意数字</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;[0-9][0-9]*&#x27; regular_express.txt </span></span><br><span class="line">5:However, this dress is about $ 3183 dollars.</span><br><span class="line">15:You are the best is mean you are the no. 1.</span><br></pre></td></tr></table></figure>
<ul>
<li>限定连续 RE 字符范围 {}(记得添加跳脱字符<code>\&#123;</code>）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找特定范围</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;o\&#123;2\&#125;&#x27; regular_express.txt </span></span><br><span class="line">1:<span class="string">&quot;Open Source&quot;</span> is a good mechanism to develop programs.</span><br><span class="line">2:apple is my favorite food.</span><br><span class="line">3:Football game is not use feet only.</span><br><span class="line">9:Oh! The soup taste good.</span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br><span class="line">19:goooooogle <span class="built_in">yes</span>!</span><br><span class="line"><span class="comment"># 双端界定范围</span></span><br><span class="line">root@fuck:/test<span class="comment"># grep -n &#x27;go\&#123;2,5\&#125;g&#x27; regular_express.txt </span></span><br><span class="line">18:google is the best tools <span class="keyword">for</span> search keyword.</span><br></pre></td></tr></table></figure>

<p><strong>基础正则表达式字符汇整</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211092156739.png" alt="image-20221109215623614" style="zoom: 50%;" />

<p><strong>sed工具</strong></p>
<p><strong>延伸正则表达式</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fuck:/test<span class="comment"># grep -v &#x27;^$&#x27; regular_express.txt | grep -v &#x27;^#&#x27;</span></span><br><span class="line">可以替换为</span><br><span class="line">root@fuck:/test<span class="comment"># egrep -v &#x27;^$|^#&#x27; regular_express.txt </span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211092218361.png" alt="image-20221109221826302" style="zoom: 80%;" />

<h3 id="文件的格式化与相关处理"><a href="#文件的格式化与相关处理" class="headerlink" title="文件的格式化与相关处理"></a><strong>文件的格式化与相关处理</strong></h3><p><strong>格式化打印： printf</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="built_in">printf</span> <span class="string">&#x27;打印格式&#x27;</span> 实际内容</span><br><span class="line">选项与参数：</span><br><span class="line">关于格式方面的几个特殊样式：</span><br><span class="line">\a 警告声音输出</span><br><span class="line">\b 倒退键（backspace）</span><br><span class="line">\f 清除屏幕 （form feed）</span><br><span class="line">\n 输出新的一行</span><br><span class="line">\r 亦即 Enter 按键</span><br><span class="line">\t 水平的 [tab] 按键</span><br><span class="line">\v 垂直的 [tab] 按键</span><br><span class="line">\xNN NN 为两位数的数字，可以转换数字成为字符。</span><br><span class="line">关于 C 程序语言内，常见的变量格式</span><br><span class="line">%ns 那个 n 是数字， s 代表 string ，亦即多少个字符；</span><br><span class="line">%ni 那个 n 是数字， i 代表 <span class="built_in">integer</span> ，亦即多少整数码数；</span><br><span class="line">%N.nf 那个 n 与 N 都是数字， f 代表 floating （浮点），如果有小数码数，</span><br><span class="line">假设我共要十个位数，但小数点有两位，即为 %10.2f</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">root@fuck:/test<span class="comment"># printf &#x27;%s\t s\t %s\t %s\t %s\t \n&#x27; $ (cat printf.txt)</span></span><br></pre></td></tr></table></figure>

<p><strong>awk：好用的数据处理工具</strong></p>
<p>数据操作：<code>awk &#39;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&#39; filename</code></p>
<p>awk 后面接两个单引号并加上大括号 {} 来设置想要对数据进行的处理动作。 awk 可以处理后续接的文件，也可以读取来自前个指令的 standard output。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出前五行登陆者命令</span></span><br><span class="line">root@fuck:/test<span class="comment"># last -n 5</span></span><br><span class="line">mua      tty2         tty2             Thu Nov 10 03:37   still logged <span class="keyword">in</span></span><br><span class="line">reboot   system boot  5.15.0-52-generi Thu Nov 10 03:37   still running</span><br><span class="line">mua      tty2         tty2             Wed Nov  2 05:56 - crash (7+21:41)</span><br><span class="line">reboot   system boot  5.15.0-52-generi Wed Nov  2 05:56   still running</span><br><span class="line">mua      tty2         tty2             Sun Oct 23 01:14 - crash (10+04:41)</span><br><span class="line"><span class="comment">#想要取出帐号与登陆者的 IP ，且帐号与 IP 之间以 [tab] 隔开</span></span><br><span class="line">[dmtsai@study ~]$ last -n 5 &amp;<span class="comment">#124; awk &#x27;&#123;print $1 &quot;\t&quot; $3&#125;&#x27;</span></span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">dmtsai 192.168.1.100</span><br><span class="line">dmtsai Fri</span><br></pre></td></tr></table></figure>

<p><strong><code>awk</code>内置变量</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211131017749.png" alt="image-20221113101742717" style="zoom:67%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#列出每一行的帐号（就是 $1）；</span></span><br><span class="line"><span class="comment">#列出目前处理的行数（就是 awk 内的 NR 变量）</span></span><br><span class="line"><span class="comment">#并且说明，该行有多少字段（就是 awk 内的 NF 变量）</span></span><br><span class="line">[dmtsai@study ~]$ last -n 5&amp;<span class="comment">#124; awk &#x27;&#123;print $1 &quot;\t lines: &quot; NR &quot;\t columns: &quot; NF&#125;&#x27;</span></span><br><span class="line">dmtsai lines: 1 columns: 10</span><br><span class="line">dmtsai lines: 2 columns: 10</span><br><span class="line">dmtsai lines: 3 columns: 10</span><br><span class="line">dmtsai lines: 4 columns: 10</span><br><span class="line">dmtsai lines: 5 columns: 9</span><br></pre></td></tr></table></figure>

<p><strong>逻辑运算字符</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211131019209.png" alt="image-20221113101958177" style="zoom:67%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#逻辑运算上面亦即所谓的大于、小于、等于等判断式上面，习惯上是以“ == ”来表示；</span></span><br><span class="line"><span class="comment">#如果是直接给予一个值，例如变量设置时，就直接使用 = 而已</span></span><br><span class="line"><span class="comment">#假设我要查阅，第三栏小于10 以下的数据，并且仅列出帐号与第三栏</span></span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">cat</span> /etc/passwd &amp;<span class="comment">#124; awk &#x27;&#123;FS=&quot;:&quot;&#125; $3 &amp;lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#x27;</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br><span class="line"><span class="comment">#第一行未正确显示，利用BEGIN设置第二行</span></span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">cat</span> /etc/passwd &amp;<span class="comment">#124; awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &amp;lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#x27;</span></span><br><span class="line">root 0</span><br><span class="line">bin 1</span><br><span class="line">daemon 2</span><br></pre></td></tr></table></figure>

<h3 id="文件比对工具"><a href="#文件比对工具" class="headerlink" title="文件比对工具"></a>文件比对工具</h3><p><strong>diff</strong></p>
<p>同一个套装软件的不同版本之间，比较配置文件与原始文件的差异就可以使用<code>diff</code>命令</p>
<p>第一步将文件设置为一个新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mua@fuck:~$ <span class="built_in">mkdir</span> -p /tmp/testpw &amp;lt;</span><br><span class="line">mua@fuck:~$ <span class="built_in">cd</span> /tmp/testpw/</span><br><span class="line">mua@fuck:/tmp/testpw$ <span class="built_in">cp</span> /etc/passwd passwd.old</span><br><span class="line">mua@fuck:/tmp/testpw$ <span class="built_in">cat</span> /etc/passwd &amp;<span class="comment">#124;sed -e &#x27;4d&#x27; -e &#x27;6c no six line&#x27; &amp;gt;passwd</span></span><br><span class="line"><span class="comment"># 将 /etc/passwd 处理成为一个新的版本，将第四行删除，第六行则取代成为“no six line”，新的文件放置到 /tmp/test 里面，</span></span><br></pre></td></tr></table></figure>

<p><code>diff</code>的用法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ diff [-bBi] from-file to-file</span><br><span class="line">选项与参数：</span><br><span class="line">from-file ：一个文件名，作为原始比对文件的文件名；</span><br><span class="line">to-file ：一个文件名，作为目的比对文件的文件名；</span><br><span class="line">注意，from-file 或 to-file 可以 - 取代，那个 - 代表“Standard input”之意。</span><br><span class="line">-b ：忽略一行当中，仅有多个空白的差异（例如 <span class="string">&quot;about me&quot;</span> 与 <span class="string">&quot;about me&quot;</span> 视为相同</span><br><span class="line">-B ：忽略空白行的差异。</span><br><span class="line">-i ：忽略大小写的不同。</span><br><span class="line"></span><br><span class="line">范例一：比对 passwd.old 与 passwd.new 的差异：</span><br><span class="line">[dmtsai@study testpw]$ diff passwd.old passwd.new</span><br><span class="line">4d3 &amp;lt;==左边第四行被删除 （d） 掉了，基准是右边的第三行</span><br><span class="line">&amp;lt; adm:x:3:4:adm:/var/adm:/sbin/nologin &amp;lt;==这边列出左边（&amp;lt;）文件被删除的那一行内容</span><br><span class="line">6c5 &amp;lt;==左边文件的第六行被取代 （c） 成右边文件的第五行</span><br><span class="line">&amp;lt; <span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync &amp;lt;==左边（&amp;lt;）文件第六行内容</span><br><span class="line">---</span><br><span class="line">&amp;gt; no six line &amp;lt;==右边（&amp;gt;）文件第五行内容</span><br><span class="line"></span><br><span class="line">范例二：比较文件</span><br><span class="line">[mua@localhost testpw]$ diff /etc/rc0.d/ /etc/rc5.d/</span><br><span class="line">只在 /etc/rc0.d/ 存在：K90network</span><br><span class="line">只在 /etc/rc5.d/ 存在：S10network</span><br></pre></td></tr></table></figure>

<p><code>cmp</code>命令</p>
<p><code>cmp</code> 主要也是在比对两个文件，他 主要利用“字节”单位去比对， 因此，当然也可以比对 binary file,diff 主要是以“行”为单位比对， <code>cmp </code>则是以“字节”为单位去比对。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ cmp [-l] file1 file2</span><br><span class="line">选项与参数：</span><br><span class="line">-l ：将所有的不同点的字节处都列出来。因为 cmp 默认仅会输出第一个发现的不同点。</span><br><span class="line"></span><br><span class="line">范例一：用 cmp 比较一下 passwd.old 及 passwd.new</span><br><span class="line">[dmtsai@study testpw]$ cmp passwd.old passwd.new</span><br><span class="line">passwd.old passwd.new differ: char 106, line 4</span><br></pre></td></tr></table></figure>

<p><code>patch</code>命令</p>
<p>patch 这个指令与 diff 可是有密不可分的关系，前面提到，diff 可以用来分辨两个版本之间的差异， 举例来说，刚刚我们所创建的 passwd.old 及 passwd.new 之间就是两个不同版本的文件。 那么，如果要“升级”，就是“先比较先旧版本的差异，并将差异档制作成为补丁文件，再由补丁文件更新旧文件”即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">范例一：以 /tmp/testpw 内的 passwd.old 与 passwd.new 制作补丁文件</span><br><span class="line">[dmtsai@study testpw]$ diff -Naur passwd.old passwd.new &amp;gt; passwd.patch</span><br><span class="line">[dmtsai@study testpw]$ <span class="built_in">cat</span> passwd.patch</span><br><span class="line">--- passwd.old 2015-07-14 22:37:43.322535054 +0800 &amp;lt;==新旧文件的信息</span><br><span class="line">+++ passwd.new 2015-07-14 22:38:03.010535054 +0800</span><br><span class="line">@@ -1,9 +1,8 @@ &amp;lt;==新旧文件要修改数据的界定范围，旧文件在 1-9 行，新文件在 1-8 行</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">-adm:x:3:4:adm:/var/adm:/sbin/nologin &amp;lt;==左侧文件删除</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">-<span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync &amp;lt;==左侧文件删除</span><br><span class="line">+no six line &amp;lt;==右侧新文件加入</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br></pre></td></tr></table></figure>

<p>文件打印工具<code>pr</code></p>
<ul>
<li>用于多打印“文件时间”、“文件文件名”及“页码”三大项目。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost testpw]<span class="comment"># pr passwd.new </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2022-11-17 20:04                    passwd.new                    Page 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/黄蓉</span><br></pre></td></tr></table></figure>

<h3 id="情景运用"><a href="#情景运用" class="headerlink" title="情景运用"></a>情景运用</h3><ul>
<li>通过 grep 搜寻特殊字串，并配合数据流重导向来处理大量的文件搜寻问题。<ul>
<li>目标：正确的使用正则表达式；</li>
<li>前提：需要了解数据流重导向，以及通过子指令 $（command） 来处理文件名的搜寻； 我们简单的以搜寻星号 （*） 来处理下面的任务：<ul>
<li>利用正则表达式找出系统中含有某些特殊关键字的文件，举例来说，找出在 &#x2F;etc 下面含有星号 （*） 的文件与内容：解决的方法必须要搭配万用字符，但是星号本身就是正则表达式的字符，因此需要这样进行：</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost testpw]<span class="comment"># grep &#x27;\*&#x27; /etc/* 2&amp;gt; /dev/null</span></span><br><span class="line">[1] 10332</span><br><span class="line">grep: /etc/abrt: Is a directory</span><br><span class="line">Binary file /etc/aliases.db matches</span><br><span class="line">grep: /etc/alsa: Is a directory</span><br><span class="line">grep: /etc/alternatives: Is a directory</span><br><span class="line">······</span><br></pre></td></tr></table></figure>

<p>如果是想要连同完整的此目录数据，则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ grep <span class="string">&#x27;\*&#x27;</span> $（find /etc -<span class="built_in">type</span> f ） 2&amp;gt; /dev/null</span><br><span class="line"><span class="comment"># 如果只想列出文件名而不要列出内容的话，使用下面的方式来处理即可喔！</span></span><br><span class="line">[dmtsai@study ~]$ grep -l <span class="string">&#x27;\*&#x27;</span> $（find /etc -<span class="built_in">type</span> f ） 2&amp;gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>如果文件数量太多，如同上述的案例，如果要找的是全系统（&#x2F;）呢？可以这样做:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[dmtsai@study ~]$ grep <span class="string">&#x27;\*&#x27;</span> $（find / -<span class="built_in">type</span> f 2&amp;gt; /dev/null ）</span><br><span class="line">-bash: /usr/bin/grep: Argument list too long</span><br></pre></td></tr></table></figure>

<p>由于命令行的内容长度是有限制的，因此当搜寻的对象是整个系统时，上述的指令会发生错误。此时我们可以通过管线命令以及 xargs 来处理。举例来说，让 grep 每次仅能处理 10 个文件名，此时可以这样想:</p>
<ol>
<li>先用 find 去找出文件；</li>
<li>用 xargs 将这些文件每次丢 10 个给 grep 来作为参数处理；</li>
<li>grep 实际开始搜寻文件内容。 所以整个作法就会变成这样：</li>
</ol>
<p><code>[dmtsai@study ~]$ find / -type f 2&gt; /dev/null | xargs -n 10 grep &#39;\*&#39;</code></p>
<p>ps.<strong>获取IP</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost testpw]<span class="comment"># ifconfig ens33 &amp;#124; grep &#x27;inet&#x27; &amp;#124;sed &#x27;s/^.*inet //g&#x27; &amp;#</span></span><br><span class="line">[1] 11088</span><br><span class="line">[root@localhost testpw]<span class="comment"># ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span></span><br><span class="line">        inet 192.168.226.141  netmask 255.255.255.0  broadcast 192.168.226.255</span><br><span class="line">        inet6 fe80::d50b:4c8c:5213:8ae2  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:a6:32:c5  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 2357  bytes 1990618 (1.8 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1396  bytes 150431 (146.9 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"><span class="comment">#将命令指定为myip</span></span><br><span class="line">[root@localhost testpw]<span class="comment"># alias myip=&quot;ifconfig ens33 &amp;#124; grep &#x27;inet&#x27; &amp;#124;sed &#x27;s/^.*inet //g&#x27; &quot;</span></span><br><span class="line">[root@localhost testpw]<span class="comment"># myip</span></span><br><span class="line">[1] 11117</span><br><span class="line">[root@localhost testpw]<span class="comment"># ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Shell-script"><a href="#Shell-script" class="headerlink" title="Shell  script"></a>Shell  script</h2>]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>在线code安装教程</title>
    <url>/2022/09/12/codeinstall/</url>
    <content><![CDATA[<p>##前置条件：</p>
<ol>
<li>云服务器</li>
<li>ssh的连接工具 如<a href="https://www.putty.org/">putty</a>，<a href="https://termius.com/">Termius</a>，mac用户可以直接用终端连接.</li>
</ol>
<h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><p>首先使用你的ssh工具连接服务器</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>输入命令下载codeserver</span><br><span class="line">wget https:<span class="regexp">//gi</span>thub.com<span class="regexp">/coder/</span>code-server<span class="regexp">/releases/</span>download<span class="regexp">/v4.6.1/</span>code-server-<span class="number">4.6</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="regexp">//</span>解压</span><br><span class="line">tar -zxvf code-server-<span class="number">4.6</span>.<span class="number">1</span>-linux-amd64.tar.gz</span><br><span class="line"><span class="regexp">//</span>进入codeserver目录</span><br><span class="line">cd code-server-<span class="number">4.6</span>.<span class="number">1</span>-linux-amd64</span><br><span class="line"><span class="regexp">//</span>设置密码(密码在双引号内)</span><br><span class="line">export PASSWORD=<span class="number">123456</span></span><br><span class="line"><span class="regexp">//</span>启动codeserver</span><br><span class="line">./code-server --port <span class="number">8081</span> --host <span class="number">0.0</span>.<span class="number">0.0</span> --auth password</span><br></pre></td></tr></table></figure>

<p>在浏览器上方输入<code>你的服务器IP:8081</code> 即可进入登录界面</p>
<p>这个时候输入之前设置的密码就可以进入codeserver了</p>
<h2 id="配置Screen进程守护"><a href="#配置Screen进程守护" class="headerlink" title="配置Screen进程守护"></a>配置Screen进程守护</h2><p>之前的步骤有一个问题,就是当你退出ssh进程的时候,你会发现网站进不去了。</p>
<p>因为当ssh进程关闭的时候，会自动清除当前进程。</p>
<p>我们得下载Screen来给codeserver进行进程守护，防止进程自动退出。</p>
<h2 id="安装Screen"><a href="#安装Screen" class="headerlink" title="安装Screen"></a>安装Screen</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>复制适合自己系统的命令安装</span><br><span class="line"><span class="regexp">//</span>Centos系统</span><br><span class="line">yum install screen</span><br><span class="line"><span class="regexp">//</span>Debian/Ubuntu系统</span><br><span class="line">apt-get install screen</span><br></pre></td></tr></table></figure>
<h2 id="保护进程实现后台运行"><a href="#保护进程实现后台运行" class="headerlink" title="保护进程实现后台运行"></a>保护进程实现后台运行</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span>以code_server为名字建立进程</span><br><span class="line">screen -S code_server</span><br><span class="line"><span class="string">//</span>再次输入以下命令</span><br><span class="line"><span class="keyword">cd</span> code-server-4.6.1-linux-amd64</span><br><span class="line">export PASSWORD=123456</span><br><span class="line"><span class="string">./code-server</span> <span class="params">--port</span> 8081 <span class="params">--host</span> 0.0.0.0 <span class="params">--auth</span> password</span><br></pre></td></tr></table></figure>



<p>此时关闭ssh终端,也可以照常进入网页啦！</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2022-09-06-215111.jpg"></p>
<p>微软官方<a href="https://vscode.dev/">请输入链接描述</a></p>
]]></content>
      <categories>
        <category>toy</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>toy</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理应用复习</title>
    <url>/2022/10/25/database/</url>
    <content><![CDATA[<h2 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h2><h3 id="四个基本概念"><a href="#四个基本概念" class="headerlink" title="四个基本概念"></a>四个基本概念</h3><p><strong>数据（DATA）：</strong>描述事物的符号记录称为数据，数据是数据库存储的基本对象。</p>
<p><strong>数据库（DB）：</strong>长期存储在计算机内、有组织、可共享的大量数据的集合。</p>
<p><strong>数据库管理系统（DBMS）：</strong>位于用户和操作系统之间的一层数据管理软件。</p>
<p><strong>数据库系统：</strong>DB+DBMS+APP+DBA（<strong>数据库管理员</strong>）。</p>
<h3 id="数据库管理系统功能"><a href="#数据库管理系统功能" class="headerlink" title="数据库管理系统功能"></a>数据库管理系统功能</h3><ol>
<li>数据定义功能</li>
<li>数据组织、存储和管理</li>
<li>数据操作功能</li>
<li>数据库的事务管理和运行管理</li>
<li>数据库的建立和维护功能</li>
<li>其他功能（通信功能、数据转换功能、互访和互操作功能）</li>
</ol>
<h3 id="文件系统管理数据的特点"><a href="#文件系统管理数据的特点" class="headerlink" title="文件系统管理数据的特点"></a>文件系统管理数据的特点</h3><ol>
<li>数据可以长期保存</li>
<li>由文件系统管理数据</li>
<li>数据共享性差，冗余度大</li>
<li>数据独立性差</li>
</ol>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ol>
<li>数据结构化（与文件系统的本质区别）</li>
<li>数据的共享性高、冗余度低且以扩充</li>
<li>数据独立性高</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<p><strong>需要的数据控制功能</strong></p>
<ol>
<li>数据的安全性保护</li>
<li>数据的完整性检查</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote>
<p>对现实世界数据特征的抽象</p>
</blockquote>
<h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><ol>
<li><strong>实体：</strong>客观并可相互区别的事物。</li>
<li><strong><em>属性</em>：</strong>实体的特征称为属性。</li>
<li><strong>码：</strong>唯一标识实体的属性集称为码。</li>
<li><strong>实体型：</strong>用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li><strong>实体集：</strong>同一类型的实体的集合称为实体集。</li>
<li><strong>联系：</strong>实体内部的联系指组成实体的属性之间的联系，实体之间的联系指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。</li>
</ol>
<h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p><strong>表示：</strong></p>
<ul>
<li>矩形：实体</li>
<li>菱形：外键约束</li>
<li>椭圆：字段</li>
</ul>
<h3 id="三大模型的优缺点"><a href="#三大模型的优缺点" class="headerlink" title="三大模型的优缺点"></a>三大模型的优缺点</h3><p><strong>层次模型（Tree）</strong></p>
<p>概念：1.只有一个结点且没有双亲节点，这个结点称为根结点		2. 根以外的其他结点有且只有一个双亲结点</p>
<p>优点：</p>
<ol>
<li>层次模型的数据结构比较简单清晰</li>
<li>层次数据库的查询效率高</li>
<li>层次数据模型提供了良好的完整性支持</li>
</ol>
<p>缺点：</p>
<ol>
<li>现实世界中很多联系是非层次性的</li>
<li>如果一个结点具有多个双亲结点等，用层次模型表示这类联系就很笨拙，只能通过引入冗余数据（易产生不一致性）或创建非自然的数据结构（引入虚拟结点）来解决。对插入和删除操作的限制比较多，因此应用程序的编写比较复杂</li>
<li>查询子女结点必须通过双亲结点</li>
<li>由于结构严密，层次命令趋于程序化</li>
</ol>
<p><strong>网状模型（Set）</strong></p>
<p>概念：1.允许一个以上的结点无双亲 	2.一个结点可以有多于一个的双亲 </p>
<p>优点：</p>
<ol>
<li>能够更为直接地描述现实世界，如一个结点可以有多个双亲，结点之间可以有多种联系。</li>
<li>具有良好的性能，存取效率较高。<br>缺点：</li>
<li>结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握。</li>
<li>网状模型的DDL、DML复杂，并且要嵌入某一种高级语言（如COBOL、C)中。用户不容易掌握，不容易使用。</li>
<li>由于记录之间的联系是通过存取路径实现的，应用程序在访问数据时必须选择适当的存取路径，因此用户必须了解系统结构的细节，加重了编写应用程序的负担</li>
</ol>
<p><strong>关系模型（二维表）</strong></p>
<p>优点：</p>
<ol>
<li>关系模型与格式化模型不同，它是建立在严格的数学概念的基础上的。</li>
<li>关系模型的概念单一。无论实体还是实体之间的联系都用关系来表示。对数据的检索和更新结果也是关系（即表）。所以其数据结构简单、清晰，用户易懂易用。</li>
<li>关系模型的存取路径对用户透明，从而具有更高的数据独立性、更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。<br> 缺点：</li>
<li>由于存取路径对用户是隐蔽的，查询效率往往不如格式化数据模型。</li>
<li>为了提高性能，数据库管理系统必须对用户的查询请求进行优化，因此增加了开发数据库管理系统的难度。</li>
</ol>
<h3 id="物理模型"><a href="#物理模型" class="headerlink" title="物理模型"></a>物理模型</h3><p>针对逻辑模型的设计，在具体的物理介质（数据库或数据仓库）上实现出来。是面向计算机物理表示的模型，描述了数据在储存介质上的组织结构，它不但与具体的DBMS有关，而且还与操作系统和硬件有关。每一种逻辑数据模型在实现时都有起对应的物理数据模型。DBMS为了保证其独立性与可移植性，大部分物理数据模型的实现工作又系统自动完成，而设计者只设计索引、聚集等特殊结构。</p>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>研究的对象类型的集合。这些对象是数据库的组成成分，数据结构指对象和对象间联系的表达和实现，是对系统静态特征的描述，包括</p>
<ol>
<li>数据本身：类型、内容、性质。例如关系模型中的域、属性、关系</li>
<li>数据之间的联系：数据之间是如何相互关联的。例如关系模型中的主码、外码联系</li>
</ol>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>主要指检索和更新（插入、删除、修改）两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统<strong>动态特性</strong>的描述。</p>
<h4 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h4><p>数据完整性约束是一组完整性规则的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。</p>
<h3 id="三级模式两级映像"><a href="#三级模式两级映像" class="headerlink" title="三级模式两级映像"></a>三级模式两级映像</h3><p><strong>模式的概念</strong></p>
<blockquote>
<p><strong>数据库中全体数据的逻辑结构和特征的描述，仅仅涉及型的描述，不涉及具体的值。</strong></p>
<p><em>型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</em></p>
</blockquote>
<h4 id="三层模式结构"><a href="#三层模式结构" class="headerlink" title="三层模式结构"></a>三层模式结构</h4><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261740103.png" alt="image-20221126174041038" style="zoom:50%;" />

<p><strong>模式：</strong>也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共视图。在数据库系统模式结构中处于中间层，与硬件平台和应用程序无关。一个数据库只有一个模式。</p>
<p><strong>外模式：</strong>也称子模式和用户模式，它是数据库用户（应用程序员与最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。外模式通常是模式的子集，一个数据库可以有很多外模式。</p>
<p><strong>内模式：</strong>也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。例如，记录的存储方式是堆存储、升序&#x2F;降序存储还是聚簇存储；B+树索引还是哈希索引；是否压缩存储，是否加密；数据存储记录结构是定长结构还是边长结构。</p>
<h4 id="两级映像与数据独立性"><a href="#两级映像与数据独立性" class="headerlink" title="两级映像与数据独立性"></a>两级映像与数据独立性</h4><blockquote>
<p>功能：外模式&#x2F;模式映像、模式&#x2F;内模式映像。</p>
</blockquote>
<p>外模式&#x2F;模式映像针对于每一个外模式，定义了外模式与模式的对应关系；模式&#x2F;内模式映像是唯一的，定义了数据全局逻辑结构与存储结构之间的对应关系。</p>
<p><strong>逻辑独立性：</strong></p>
<p>当模式改变时，由DBA对各个外模式&#x2F;模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据逻辑独立性。</p>
<p><strong>物理独立性：</strong></p>
<p>当数据库的存储结构改变时，由DBA对模式&#x2F;内模式映像作出相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性，简称数据物理独立性。</p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系模型三要素"><a href="#关系模型三要素" class="headerlink" title="关系模型三要素"></a>关系模型三要素</h3><p><strong>关系数据结构、关系操作集合、关系完整性约束</strong></p>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><blockquote>
<p>描述现实世界的实体以及实体之间的各种联系的单一结构类型就是关系，站在用户的视角，关系就是一张二维表</p>
</blockquote>
<ol>
<li><p><strong>域：</strong>一组具有相同数据类型的集合</p>
</li>
<li><p><strong>笛卡儿积：</strong>给定的一组域D1，D2，…，Dn，允许其中某些域是相同的，它们的笛卡尔积定义为<br>D1×D2×…×Dn&#x3D;{(d1，d2，…，dn)|di∈Di，i&#x3D;1，2，…，n}<br>其中每一个元素(d1，d2，…，dn)叫做一个n元组，或简称元组，元组中的每一个分量di叫做一个分量。一个域允许的不同取值个数称为这个域的基数。</p>
</li>
<li><p><strong>关系：</strong>D1×D2×…×Dn的子集叫做在域D1，D2，…，Dn上的关系，表示为R(D1，D2，…，Dn)，R表示关系的名字，n是关系的目或度。关系中的每个元素是关系中的元组，用t表示。</p>
<ul>
<li>关系是笛卡尔积的子集</li>
<li><em>候选码：</em>某一属性组的的值能够唯一地标识一个元组，但是它的任何一个真子集不能，则称该属性组为候选码</li>
<li><em>主码：</em>若一个关系有多个候选码，则选定其中一个为主码</li>
<li><em>主属性：</em>候选码的诸属性为主属性，不包含在任何候选码中的属性称为非主属性</li>
<li><em>全码：</em>关系模式的所有属性构成这个关系模式的候选码，称为全码</li>
<li><em>关系类型：</em>基本关系（基本表或基表）、查询表和视图表。基本表是实表；查询表是查询结果对应的表；视图表是导出表，是虚表</li>
<li><em>补充：</em>禁止无限关系，附加属性名来消除关系属性的有序性</li>
</ul>
<p><strong>基本关系的性质：</strong>列同质、异列可同域、行列无序性、候选码唯一性、分量原子性</p>
<ol>
<li>列是同质的，即每一列中的分量是同一类型的数据，来自一个域</li>
<li>不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名</li>
<li>列的顺序无所谓，即列的次序可以任意交换</li>
<li>任意两个元组的候选码不能取相同的值</li>
<li>行的顺序无所谓，即行的次序可以任意交换</li>
<li>分量必须取原子值，即每一个分量都必须是不可分的数据项（最基本的一条）</li>
</ol>
</li>
</ol>
<h4 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h4><ul>
<li>查询操作：选择、投影、连接、除、并、差、交、笛卡尔积</li>
<li>关系代数和关系演算结构化查询语言SQL：DQL、DDL、DML、DCL</li>
</ul>
<h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><ol>
<li><p><strong>实体完整性：</strong>主码不可重复且不为空</p>
</li>
<li><p><strong>参照完整性：</strong></p>
<p>若属性&#x2F;属性组F是基本关系R的外码，它与基本关系S的主码Ks相对应（R与S可以是同一关系），则对于R中每个元组在F上的值必须取空值或S中某个元组的主码值。<br>外码：设F是基本关系R的属性&#x2F;属性集，但不是关系R的码，Ks是基本关系S的主码，如果F与Ks相对应，则称F是R的外码，并称R为参照关系，S为被参照关系或目标关系，R与S可以是同一关系。</p>
</li>
<li><p><strong>用户定义的完整性：</strong></p>
<p>指对关系中每个属性的取值作一个限制(或称为约束)的具体定义。比如 性别属性只能取”男“或”女“ ，再就是年龄的取值范围，可以取值0-130 ，但不能取负数，因为年龄不可能是负数</p>
</li>
</ol>
<h4 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h4><ol>
<li><strong>传统的集合运算</strong>：并、差、交、笛卡尔积</li>
</ol>
<p><strong>笛卡尔乘积：</strong>两个集合相乘的结果。</p>
<p> 集合A{a1,a2,a3} 集合B{b1,b2}<br> 他们的 笛卡尔积 是 A*B &#x3D;{(a1,b1),(a1,b2),(a2,b1),(a2,b2),(a3,b1),(a3,b2)}<br> 任意两个元素结合在一起</p>
<ol start="2">
<li><strong>专门的关系运算</strong>：选择、投影、连接、除</li>
</ol>
<p><strong>选择：</strong>选择又称为限制（Restriction）。它是在关系R中选择满足给定条件的诸元组</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261949804.png" alt="image-20221126194927738" style="zoom: 50%;" />

<p><strong>投影：</strong>对属性列的选择列出,上述投影图可用SQL语句select Sn0 , Sname from 表，就是把需要的字段显示出来即可。</p>
<p><strong>自然连接：</strong>结果列数为二者属性列数之和減去重复列,行数为二者冋名属性列其值相冋的结果元组。笛卡尔积、选择、投影的组合表示可以与自然连接等价。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261952065.png" alt="image-20221126195225014" style="zoom:50%;" />

<p><strong>等值连接：</strong>相当与运算符，可以认为笛卡儿积是无条件连接，其他的是有条件连接。</p>
<p>连接逻辑上是table之间先做笛卡儿积，再做对应选择操作。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211262002063.png" alt="image-20221126200252024" style="zoom:50%;" />

<h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2><h3 id="语法部分–点击即达"><a href="#语法部分–点击即达" class="headerlink" title="语法部分–点击即达"></a><a href="https://dreamin.space/2022/09/09/MySQL/">语法部分–点击即达</a></h3><ol>
<li>综合统一</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>以同一种语法结构提供多种使用方法</li>
<li>语言简洁，易学易用</li>
</ol>
<h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ol>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当利用视图可以更清晰地表达查询</li>
</ol>
<h2 id="易混淆"><a href="#易混淆" class="headerlink" title="易混淆"></a>易混淆</h2><ol>
<li><p>数据库系统的基础是<del>数据库管理系统</del><strong>数据模型</strong></p>
</li>
<li><p>有了模式&#x2F;内模式的映象，可以保证数据和应用程序之间的<del>数据安全性</del><strong>物理独立性</strong></p>
<blockquote>
<p>数据库的模式和内模式定义了数据库中的全局逻辑结构和存储结构之间的关系，当存储逻辑结构改变的时候，数据库管理员会对模式和内模式做相应的改变，保证了程序的<strong>物理独立性</strong></p>
</blockquote>
</li>
<li><p>数据模型中用于描述系统静态特性的是<del>完整性约束</del><strong>数据结构</strong></p>
</li>
<li><p>用树型结构来表示实体之间联系的模型称为<del>网状模型</del><strong>层次模型</strong></p>
</li>
<li><p>DB、DBMS、DBS三者之间的关系：<del>DB包括DBMS和DBS</del><strong>DBS包括DB和DBMS</strong></p>
</li>
</ol>
<blockquote>
<p>DBS(数据库系统)包括DB(数据可)和DBMS(数据库管理系统)</p>
</blockquote>
<ol start="6">
<li>数据模型通常由<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>完整性约束</strong>三要素组成。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/weixin_37545024/article/details/90489308">《数据库系统概论》复习</a></li>
<li><a href="https://blog.51cto.com/u_14540820/5003913">关系模型中三类完整性约束以及解释</a></li>
<li><a href="https://blog.csdn.net/JavaEEKing/article/details/109223552">数据库系统之：关系代数详解-超详细</a></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux toy合集</title>
    <url>/2022/09/15/fucktoy/</url>
    <content><![CDATA[<h1 id="Linux命令神器-The-Fuck"><a href="#Linux命令神器-The-Fuck" class="headerlink" title="Linux命令神器 The Fuck"></a>Linux命令神器 <code>The Fuck</code></h1><p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/example.gif" alt="example"></p>
<p><strong><code>The Fuck</code>是一款能够自动修复你的错误命令行的终端应用。</strong></p>
<p>相信大家每个人都有敲错过命令的时候,把<code>python</code><br>输入成 <code>puthon</code><br>.手速过快把<code>ls -alh</code><br>输入成 <code>ls a-lh</code><br>等等等,这时候是不是想拍一下键盘说一声<code>fuck</code></p>
<h2 id="术前要求"><a href="#术前要求" class="headerlink" title="术前要求"></a>术前要求</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Python</span> (<span class="number">2</span>.<span class="number">7</span>+ or <span class="number">3</span>.<span class="number">3</span>+)</span><br><span class="line"><span class="attribute">pip</span></span><br><span class="line"><span class="attribute">Python</span>-dev</span><br></pre></td></tr></table></figure>

<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p><strong>Mac 下使用 <a href="https://brew.sh/">Homebrew</a> 安装：</strong></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>thefuck</span><br></pre></td></tr></table></figure>

<p><strong>Ubuntu 下安装：</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt <span class="keyword">update</span></span><br><span class="line">sudo apt install <span class="keyword">python3</span>-dev <span class="keyword">python3</span>-pip</span><br><span class="line">sudo pip3 install thefuck</span><br></pre></td></tr></table></figure>

<p><strong>其他操作系统你可以使用 Python 的 pip 安装：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> thefuck</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><strong>最后，不要忘记为 The Fuck 设置 alias</strong></p>
<p>暂时命令</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span> $(thefuck --<span class="keyword">alias</span>)</span><br></pre></td></tr></table></figure>

<p>在文件中永久配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#编辑bashrc配置文件</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment">#在文件尾加入一行给thefuck取别名fuck</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(thefuck --alias fuck)</span>&quot;</span></span><br><span class="line"><span class="comment">#使生效</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>最后就可以痛快的使用啦！附上<a href="https://github.com/nvbn/thefuck"><code>TheFuck</code>官方链接</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote>
<p>其实<code>TheFuck</code>的原理就是规则匹配（正则表达式），如果找到匹配规则的命令，则创建一个命令给用户选择或直接运行。</p>
</blockquote>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">cat_dir - 当你尝试cat目录的时候，用<span class="keyword">ls</span>替换cat;</span><br><span class="line"><span class="keyword">cd</span>_correction – 拼写检查和纠正失败的<span class="keyword">cd</span>命令；</span><br><span class="line"><span class="keyword">cd</span>_mkdir – 在进入目录之前创建目录；</span><br><span class="line"><span class="keyword">cd</span>_parent – 更改 <span class="keyword">cd</span>.. 为<span class="keyword">cd</span> <span class="string">..</span>；</span><br><span class="line">dry – 修复类似的重复问题：git git push；</span><br><span class="line">fix_alt_space – 用空格字符代替Alt + Space；</span><br><span class="line"><span class="comment"># 还有很多可以参考https://github.com/nvbn/thefuck#how-it-works</span></span><br></pre></td></tr></table></figure>

<h2 id="ls的翻篇小火车sl"><a href="#ls的翻篇小火车sl" class="headerlink" title="ls的翻篇小火车sl"></a>ls的翻篇小火车<code>sl</code></h2><p><strong>敲下以下命令</strong></p>
<p><strong>Ubantu</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> apt-<span class="meta">get</span> install <span class="built_in">sl</span></span><br></pre></td></tr></table></figure>

<p><strong>CentOs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install sl </span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205546460.png" alt="image-20221005205546460"></p>
<p>嘟嘟嘟嘟~~就会看到一个小火车，从你屏幕缓缓驰过….</p>
<p>还可以配合fuck使用就是</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">root@iZ2ze2p9tolfgje8qghiy0Z: sudo aptget install sl</span><br><span class="line">sudo: aptget: command not found</span><br><span class="line">root@iZ2ze2p9tolfgje8qghiy0Z:~<span class="comment"># fuck</span></span><br><span class="line">sudo apt-get install sl [enter/↑/↓/ctrl+c]</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading <span class="keyword">state</span> information... Done</span><br></pre></td></tr></table></figure>

<h2 id="反向装逼-tac"><a href="#反向装逼-tac" class="headerlink" title="反向装逼 tac"></a>反向装逼 <code>tac</code></h2><p> <strong>Ubantu</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install tac</span><br></pre></td></tr></table></figure>

<p><strong>CentOs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install tac</span><br></pre></td></tr></table></figure>

<p><em>用cat看代码时</em></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205556042.png" alt="image-20221005205556042"></p>
<p><em>tac呢</em></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205604369.png" alt="image-20221005205604369"></p>
<h2 id="自己是黑客-jpg"><a href="#自己是黑客-jpg" class="headerlink" title="自己是黑客.jpg"></a>自己是黑客.jpg</h2><p> <strong>Ubantu</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install cmatrix</span><br></pre></td></tr></table></figure>

<p><strong>CentOs</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install cmatrix</span><br></pre></td></tr></table></figure>

<p>安装好后只要在命令行输入</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cmatrix</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005205611298.png" alt="image-20221005205611298"></p>
<p>Wow~</p>
<p>只要按Ctrl+C就可以退出，适合当息屏显示</p>
<h2 id="谨慎使用fork"><a href="#谨慎使用fork" class="headerlink" title="谨慎使用fork"></a>谨慎使用<code>fork</code></h2><p>根据你的shell，选择如下2个命令中的1个，一条命令弄死Linux：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="meta">:() &#123; :|:&amp;</span> &#125;;:</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">.() &#123; .<span class="string">|.&amp; &#125;;.</span></span><br></pre></td></tr></table></figure>

<p>接着就可以重启啦</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>toy</tag>
      </tags>
  </entry>
  <entry>
    <title>基于腾讯云的Typora图床</title>
    <url>/2022/09/10/maBed/</url>
    <content><![CDATA[<h2 id="术前准备"><a href="#术前准备" class="headerlink" title="术前准备"></a>术前准备</h2><ul>
<li><p>安装好 <em>Typora</em> ： <a href="https://pan.xunlei.com/s/VNB_VLRHiLk6wUoyXr4mCWM6A1">提取码：h9bb</a>    <em>PicGo</em>  ：<a href="https://pan.xunlei.com/s/VNB_WALBOdxS0Hkp49VZlZT_A1">提取码：k77e</a></p>
</li>
<li><p>环境配置 <em>nodejs</em>：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p>
</li>
<li><p><em>Gitee</em> 账户：<a href="https://gitee.com/">https://gitee.com/</a></p>
</li>
</ul>
<h2 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h2><h3 id="01-配置完nodejs"><a href="#01-配置完nodejs" class="headerlink" title="01.配置完nodejs"></a>01.配置完<em>nodejs</em></h3><figure class="highlight plaintext"><figcaption><span>--version</span></figcaption><table><tr><td class="code"><pre><span class="line">C:\&gt;node --version</span><br><span class="line">v16.17.0</span><br><span class="line">C:\&gt;npm --verison</span><br><span class="line">8.15.0</span><br></pre></td></tr></table></figure>

<h3 id="02-配置腾讯云对象储存"><a href="#02-配置腾讯云对象储存" class="headerlink" title="02.配置腾讯云对象储存"></a>02.配置腾讯云对象储存</h3><p><strong>创建储存桶</strong></p>
<ul>
<li>点击 <code>储存桶列表</code>-&gt; <code>创建储存桶</code> -&gt; <em>进行以下配置</em></li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210751246.png" alt="image-20221005210751246"></p>
<ul>
<li>访问权限选择<strong>公有读私有写</strong>，否则图片无法读取，其他的根据自己往下填写就可以。 地域建议离你所在的位置越近越好。</li>
</ul>
<h3 id="03-获取密钥"><a href="#03-获取密钥" class="headerlink" title="03.获取密钥"></a>03.获取密钥</h3><ul>
<li>腾讯云头像–&gt;<a href="https://cloud.tencent.com/product/cam?from=10680">访问管理</a>–&gt; API密钥管理，创建密钥，就会生成 <strong>APPID、SecretId和SecretKey</strong></li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210756892.png" alt="image-20221005210756892"></p>
<h3 id="04-PicGo配置"><a href="#04-PicGo配置" class="headerlink" title="04.PicGo配置"></a>04.<em>PicGo</em>配置</h3><ul>
<li>点击<code>图床设置</code>-&gt; <code>腾讯云COS</code>-&gt; 填写好刚刚的密钥和存储桶的名称，记得<strong>设置COS版本为V5</strong></li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210801870.png" alt="image-20221005210801870"></p>
<ul>
<li>自定义域名和存储路径未进行CDN加速可默认为空</li>
</ul>
<p><strong>上传测试</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210812201.png" alt="image-20221005210812201"></p>
<p><strong>查看文件是否有保存</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210807383.png" alt="image-20221005210807383"></p>
<h3 id="05-Typora配置"><a href="#05-Typora配置" class="headerlink" title="05.Typora配置"></a>05.Typora配置</h3><ul>
<li>点击 <code>文件</code>-&gt;  <code>偏好设置</code> -&gt; <code>图像</code></li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210821839.png" alt="image-20221005210821839"></p>
<ul>
<li>如上图配置即可使用</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://blog.csdn.net/haojie_duan/article/details/120400386">https://blog.csdn.net/haojie_duan/article/details/120400386</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1834573">https://cloud.tencent.com/developer/article/1834573</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>基于青龙面板薅JD羊毛</title>
    <url>/2022/10/05/qinglong/</url>
    <content><![CDATA[<h2 id="术前准备"><a href="#术前准备" class="headerlink" title="术前准备"></a>术前准备</h2><ul>
<li><p><strong>云服务器一台</strong>（记得开放8888以及5700端口）</p>
</li>
<li><p><strong>点击<a href="https://www.bt.cn/new/download.html">安装宝塔Linux</a></strong></p>
</li>
</ul>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="1-进入宝塔面板"><a href="#1-进入宝塔面板" class="headerlink" title="1.进入宝塔面板"></a>1.进入宝塔面板</h3><p>点击<code>软件商店</code>-&gt;<code>搜索docker</code>-&gt;<code>点击安装</code></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006140520473.png" alt="image-20221006140520473" style="zoom: 50%;" />

<h3 id="2-拉取青龙镜像"><a href="#2-拉取青龙镜像" class="headerlink" title="2.拉取青龙镜像"></a>2.拉取青龙镜像</h3><p>选完安装面板和设置IP后一路回车到底</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://ghproxy.com/https://raw.githubusercontent.com/shidahuilang/QL-/main/lang1.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006140528809.png" alt="image-20221006140528809" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006140534814.png" alt="image-20221006140534814" style="zoom:50%;" />

<h3 id="3-添加拉库命令"><a href="#3-添加拉库命令" class="headerlink" title="3.添加拉库命令"></a>3.添加拉库命令</h3><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006140538948.png" alt="image-20221006140538948" style="zoom:50%;" />

<p>添加一个定时任务,定时拉库命令,就可以定时更新仓库。可设置为 <code>0 */12 * * *</code> 每天0点和12点运行一次更新。</p>
<p><strong>KingRan库【集合库，推荐</strong>】</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/KingRan/</span>KR.git <span class="string">&quot;jd_|jx_|jdCookie&quot;</span> <span class="string">&quot;activity|backUp&quot;</span> <span class="string">&quot;^jd[^_]|USER|utils|function|sign|sendNotify|ql|magic|JDJR&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Faker3【集合库】</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/shufflewzc/</span>faker3.git <span class="string">&quot;jd_|jx_|gua_|jddj_|jdCookie&quot;</span> <span class="string">&quot;activity|backUp&quot;</span> <span class="string">&quot;^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator&quot;</span> <span class="string">&quot;main&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>yyds【集合库】</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">YYDS</span><br><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/okyyds/yy</span>ds.git <span class="string">&quot;jd_|jx_|gua_|jddj_|jdCookie&quot;</span> <span class="string">&quot;activity|backUp&quot;</span> <span class="string">&quot;^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator&quot;</span> <span class="string">&quot;master&quot;</span></span><br><span class="line"></span><br><span class="line">YYDS_Pure</span><br><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/okyyds/yy</span>dspure.git <span class="string">&quot;jd_|jx_|gua_|jddj_|jdCookie&quot;</span> <span class="string">&quot;activity|backUp&quot;</span> <span class="string">&quot;^jd[^_]|USER|function|utils|sendNotify|ZooFaker_Necklace.js|JDJRValidator_|sign_graphics_validate|ql|JDSignValidator&quot;</span> <span class="string">&quot;master&quot;</span></span><br><span class="line">【注意】拉库前请打开青龙面板-配置文件 第<span class="number">18</span>行 GithubProxyUrl=<span class="string">&quot;&quot;</span> 双引号中的内容删除。</span><br></pre></td></tr></table></figure>

<p><strong>smiek2121【开卡，建议】</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/smiek2121/</span>scripts.git <span class="string">&quot;gua_&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js|cleancart_activity.js|jdCookie.js|sendNotify.js&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>ccwav大佬的通知增强版和CK检测【建议】</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>不包含sendNotify:</span><br><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ccwav/</span>QLScript2.git <span class="string">&quot;jd_&quot;</span> <span class="string">&quot;sendNotify|NoUsed&quot;</span> <span class="string">&quot;ql&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>包含sendNotify:</span><br><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/ccwav/</span>QLScript2.git <span class="string">&quot;jd_&quot;</span> <span class="string">&quot;NoUsed&quot;</span> <span class="string">&quot;ql|sendNotify&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>【zero205】【集合库，拉KR即可】</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ql repo https:<span class="regexp">//gi</span>thub.com<span class="regexp">/zero205/</span>JD_tencent_scf.git <span class="string">&quot;jd_|jx_|jdCookie&quot;</span> <span class="string">&quot;backUp|icon&quot;</span> <span class="string">&quot;^jd[^_]|USER|sendNotify|sign_graphics_validate|JDJR|JDSign|ql&quot;</span> <span class="string">&quot;main&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-添加京东COOKIE"><a href="#4-添加京东COOKIE" class="headerlink" title="4.添加京东COOKIE"></a>4.添加京东COOKIE</h3><p>提取COOKIE软件地址：<a href="https://pan.xunlei.com/s/VNBvHoZT5uASNqnZyeN7x_fFA1">提取码7yxt</a></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261122197.png" alt="image-20221126112205023" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006140547643.png" alt="image-20221006140547643" style="zoom:67%;" />

<h2 id="添加依赖-重要"><a href="#添加依赖-重要" class="headerlink" title="添加依赖(重要)"></a>添加依赖(重要)</h2><p><strong>进入<code>依赖管理</code>-&gt;<code>新建依赖</code></strong></p>
<p>1.<em>NodeJs</em></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">NodeJs里面所需依赖 添加依赖---&gt;选择自动拆分，把以下内容全部复制到名称里，之后点击确定</span><br><span class="line">ts-md5</span><br><span class="line">@types/<span class="keyword">node</span></span><br><span class="line"><span class="title">prettytable</span></span><br><span class="line"><span class="keyword">node</span><span class="title">-telegram-bot-api</span></span><br><span class="line">tslib</span><br><span class="line">ql</span><br><span class="line">common</span><br><span class="line">fs</span><br><span class="line">typescript</span><br><span class="line">axios</span><br><span class="line">png-js</span><br><span class="line">axios</span><br><span class="line">ws@<span class="number">7.4</span>.<span class="number">3</span></span><br><span class="line">crypto-js</span><br><span class="line">jieba</span><br><span class="line">global-agent</span><br><span class="line">jsdom -g</span><br><span class="line">moment</span><br><span class="line">form-data</span><br><span class="line"><span class="keyword">date</span>-fns</span><br><span class="line"><span class="keyword">node</span><span class="title">-jsencrypt</span></span><br><span class="line">require</span><br><span class="line">js-base64</span><br><span class="line">tough-cookie</span><br><span class="line">json5</span><br><span class="line">jsdom</span><br><span class="line">dotenv</span><br><span class="line">qs</span><br></pre></td></tr></table></figure>

<p>2.<em>Python3</em></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">P<span class="function"><span class="title">ython3</span>依赖 添加依赖---&gt;</span>选择自动拆分，把以下内容全部复制到名称里，之后点击确定</span><br><span class="line">ping3</span><br><span class="line">canvas</span><br><span class="line">requests</span><br><span class="line">jieba</span><br><span class="line">PyExecJS</span><br><span class="line">httpx</span><br></pre></td></tr></table></figure>

<p>3.<em>Linux</em></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Linux依赖 添加依赖---&gt;选择自动拆分，把以下内容全部复制到名称里，之后点击确定</span><br><span class="line">lxml</span><br><span class="line"><span class="keyword">bizMsg</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bizCode</span></span><br><span class="line"><span class="keyword"></span>gcc</span><br><span class="line">python-devel</span><br><span class="line">aiohttp</span><br><span class="line">magic</span><br></pre></td></tr></table></figure>

<p>*ps:*一些定时规则</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">*/5 * * * * ?    <span class="comment">#每隔 5 秒执行一次</span></span><br><span class="line">0 */1 * * * ?    <span class="comment">#每隔 1 分钟执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>2<span class="number"> 1 </span>* ? *    <span class="comment">#每月 1 日的凌晨 2 点执行一次</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? *    <span class="comment">#MON-FRI 周一到周五每天上午 10：15 执行</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? 6L    <span class="comment">#2002-2006 2002 年至 2006 年的每个月的最后一个星期五上午 10:15 执行</span></span><br><span class="line">0<span class="number"> 0 </span>23 * * ?    <span class="comment">#每天 23 点执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>1 * * ?    <span class="comment">#每天凌晨 1 点执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>1<span class="number"> 1 </span>* ?     <span class="comment">#每月 1 日凌晨 1 点执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>23 L * ?    <span class="comment">#每月最后一天 23 点执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>1 ? * L    <span class="comment">#每周星期天凌晨 1 点执行一次</span></span><br><span class="line">0 26,29,33 * * * ?    <span class="comment">#在 26 分、29 分、33 分执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>0,13,18,21 * * ?    <span class="comment">#每天的 0 点、13 点、18 点、21 点都执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>10,14,16 * * ?    <span class="comment">#每天上午 10 点，下午 2 点，4 点执行一次</span></span><br><span class="line">0 0/30 9-17 * * ?    <span class="comment">#朝九晚五工作时间内每半小时执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>12 ? * WED    <span class="comment">#每个星期三中午 12 点执行一次</span></span><br><span class="line">0<span class="number"> 0 </span>12 * * ?    <span class="comment">#每天中午 12 点触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? * *    <span class="comment">#每天上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 * * ?    <span class="comment">#每天上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 * * ? *    <span class="comment">#每天上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 * * ?    <span class="comment">#2005 2005 年的每天上午 10:15 触发</span></span><br><span class="line">0 *<span class="number"> 14 </span>* * ?    <span class="comment">#每天下午 2 点到 2:59 期间的每 1 分钟触发</span></span><br><span class="line">0 0/5<span class="number"> 14 </span>* * ?    <span class="comment">#每天下午 2 点到 2:55 期间的每 5 分钟触发</span></span><br><span class="line">0 0/5 14,18 * * ?    <span class="comment">#每天下午 2 点到 2:55 期间和下午 6 点到 6:55 期间的每 5 分钟触发</span></span><br><span class="line">0 0-5<span class="number"> 14 </span>* * ?    <span class="comment">#每天下午 2 点到 2:05 期间的每 1 分钟触发</span></span><br><span class="line">0 10,44<span class="number"> 14 </span>?<span class="number"> 3 </span>WED    <span class="comment">#每年三月的星期三的下午 2:10 和 2:44 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? * MON-FRI    <span class="comment">#周一至周五的上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10<span class="number"> 15 </span>* ?    <span class="comment">#每月 15 日上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 L * ?    <span class="comment">#每月最后一日的上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? * 6L    <span class="comment">#每月的最后一个星期五上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? * 6L    <span class="comment">#2002-2005 2002 年至 2005 年的每月的最后一个星期五上午 10:15 触发</span></span><br><span class="line">0<span class="number"> 15 </span>10 ? * 6<span class="comment">#3    #每月的第三个星期五上午 10:15 触发</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员的软件抽屉(Windows)</title>
    <url>/2022/09/26/softbox/</url>
    <content><![CDATA[<h2 id="工具篇-强烈推荐安装"><a href="#工具篇-强烈推荐安装" class="headerlink" title="工具篇(强烈推荐安装)"></a>工具篇(强烈推荐安装)</h2><h3 id="以打包"><a href="#以打包" class="headerlink" title="以打包"></a>以打包</h3><p>迅雷网盘<a href="https://pan.xunlei.com/s/VND5y3hj863AQVp7dM7UTo0DA1">提取码：atsp</a></p>
<blockquote>
<p> <a href="https://geekuninstaller.com/">Geek Uninstaller</a></p>
</blockquote>
<ul>
<li>小巧（2 MB ）、绿色（无需安装）、易用（单文件）的卸载工具。</li>
<li>卸载完成，Geek Uninstaller 会自动扫描残留的文件（夹）和注册表项目。</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210331754.png" alt="image-20221005210331754"></p>
<blockquote>
<p>Gism++</p>
</blockquote>
<p>Windows 上最强大的系统工具，简洁好用。用来清理电脑垃圾再好不过</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210337740.png" alt="image-20221005210337740"></p>
<blockquote>
<p>图吧工具箱</p>
</blockquote>
<p>整合了大量硬件检测的工具，这不比那个经常抽烟的鲁大师好多了。</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210346337.png" alt="image-20221005210346337"></p>
<blockquote>
<p>Snipaste</p>
</blockquote>
<p>史上最好用的截图软件，功能丰富，用了你就知道了。</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210352208.png" alt="image-20221005210352208"></p>
<blockquote>
<p>FSCapture</p>
</blockquote>
<p>属于录屏软件的一股清流吧，大小仅为5.4M，功能却十分齐全！</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210402012.png" alt="image-20221005210402012"></p>
<blockquote>
<p>TrafficMonitor</p>
</blockquote>
<p>用来监控现在电脑的各种硬件状态，直接在任务栏显示，简洁清楚。</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210410408.png" alt="image-20221005210410408"></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221005210415503.png" alt="image-20221005210415503"></p>
<h2 id="程序员的软件抽屉（Windows）"><a href="#程序员的软件抽屉（Windows）" class="headerlink" title="程序员的软件抽屉（Windows）"></a>程序员的软件抽屉（Windows）</h2><h3 id="杀毒软件（不需要"><a href="#杀毒软件（不需要" class="headerlink" title="杀毒软件（不需要"></a>杀毒软件（不需要</h3><p>2202年，都已经Windows11了，其实不太需要杀毒软件了，自带的 Windows defender已经足矣。</p>
<p>如果硬要装一个，那么最推荐的应该是火绒了</p>
<blockquote>
<p><a href="https://www.huorong.cn/">火绒安全</a></p>
</blockquote>
<p>相比国内一众病毒（🐧安全管家，361安全卫视，金山中毒吧）</p>
<ul>
<li>火绒不会有广告弹窗等任何打扰用户的行为，也不会在安装包中随意捆绑其他软件。</li>
<li>强悍、干净、轻巧的火绒可以让你安全、安静、自由地使用电脑。</li>
<li>在专注的同时保留了基本的防护，家长控制，U盘保护等等，还有很多扩展工具。</li>
</ul>
<p>引用 <a href="https://www.jb51.net/softjc/802578.html">脚本之家</a> <a href="https://blog.k8s.li/fuck-chinese-software.html#Windows">木子的博客</a></p>
<h3 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h3><p>作为一个程序员，装电脑系统对于我们来说应该是家常便饭，这里给大家推荐国产神器。</p>
<blockquote>
<p> <a href="http://www.wepe.com.cn/download.html">微PE</a></p>
</blockquote>
<ul>
<li><p>没有杂七杂八的功能，安装系统什么的足够使用。不会给你夹带私货什么的，比较放心食用。</p>
</li>
<li><p>不带捆绑，配合<a href="https://msdn.itellyou.cn/">MSDN我告诉你</a>直接还你一个干净的桌面</p>
</li>
<li><p>体积较小，方便安装</p>
</li>
</ul>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>一款浏览器好不好，首先看它的首页。国产没一个干净又卫生的，都是一堆广告捆绑，所以不推荐使用任何一款国产浏览器，包括手机上的浏览器。</p>
<blockquote>
<p><a href="https://www.google.com/chrome/">Chrome</a>(强烈推荐)</p>
</blockquote>
<ul>
<li>大部分浏览器（其实除了下面这款）都是基于浏览器基于Chromium，网页兼容性显而易见</li>
<li>没有任何广告，干净又卫生，页面简洁，业界大牛</li>
<li>当然缺点就是，账号同步404，你懂</li>
</ul>
<blockquote>
<p><a href="https://www.firefox.com.cn/">Firefox</a>(国际版)</p>
</blockquote>
<ul>
<li>国内版有私货，所以下载国际版，删除一些页面访问减速</li>
<li>为非营利性组织所维护的浏览器，不会太担心访问记录被相关机构审查</li>
<li>同步功能比Chrome好用</li>
</ul>
<blockquote>
<p>Edge(无奈之举)</p>
</blockquote>
<ul>
<li>比国产好用就是了</li>
</ul>
<h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>对于 Windows 10&#x2F;11 用户来讲，使用 Windows 默认的拼音&#x2F;五笔输入法再好不过了。少安装一些软件也就少了一些维护的成本。</p>
<h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><p>依旧不推荐国产压缩软件，广告满天飞，捆绑一堆严重拖慢电脑速度的fw</p>
<blockquote>
<p><a href="https://www.7-zip.org/">7-Zip</a></p>
</blockquote>
<ul>
<li>免费且开源，UI比较简陋，个人在用的一款，体积很小巧，功能很强大。</li>
</ul>
<blockquote>
<p> <a href="https://cn.bandisoft.com/bandizip/">Bandizip</a></p>
</blockquote>
<ul>
<li>轻巧、快速、免费、好看的解压缩软件。</li>
<li>最喜欢它的「自动解压」功能：不用再担心解压出一堆散乱文件或双层文件夹。</li>
</ul>
<h3 id="PDF阅读器"><a href="#PDF阅读器" class="headerlink" title="PDF阅读器"></a>PDF阅读器</h3><p>微软自带的edge其实已经很不错，还自带修改功能，但是这里推荐一款。</p>
<blockquote>
<p> <a href="https://www.sumatrapdfreader.org/free-pdf-reader.html">Sumatra PDF</a></p>
</blockquote>
<ul>
<li><p>软件小巧轻量，精简流畅，十分推荐这款 PDF 阅读软件</p>
</li>
<li><p>支持的格式也比较多 <strong>PDF, ePub, MOBI, CHM, XPS, DjVu, CBZ, CBR</strong></p>
</li>
</ul>
<h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p>其实国产迅雷很不错，但无奈不开会员还给你限速，开了会员还有广告</p>
<blockquote>
<p> <a href="https://www.baiduyun.wiki/zh-cn/idm.html#%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E7%89%B9%E5%88%AB%E8%AE%BE%E7%BD%AE">IDM</a></p>
</blockquote>
<p>什么是多线程下载？打个比方，现在要接满 1 桶水，浏览器下载时只能开 1 个水龙头，接满 1 桶水时间为 1 小时。多线程下载器可以 32 个水龙头同时接水，接满 1 桶水时间缩短到 2 分钟，足足快了 32 倍。</p>
<blockquote>
<p> <a href="https://github.com/qbittorrent/qBittorrent">qBittorrent</a></p>
</blockquote>
<p>没有杂七杂八的幺蛾子，轻量简洁。也可以使用它的 <a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition/releases">增强版</a> 。</p>
<blockquote>
<blockquote>
<ol>
<li><a href="https://www.qbittorrent.org/download.php">qBittorrent</a> (<strong>Win</strong>&#x2F;<strong>Linux</strong>&#x2F;<strong>Mac</strong>)</li>
<li>推荐: <a href="https://sourceforge.net/projects/qbittorrent/files/">3.3.16</a> 及其 <a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition/releases">增强版</a></li>
<li><a href="http://www.bittorrent.com/">BitTorrent</a> (<strong>Win</strong>&#x2F;Mac&#x2F;Android)</li>
<li><a href="https://deluge-torrent.org/">Deluge</a> (<strong>Linux</strong>&#x2F;<strong>Mac</strong>&#x2F;Win)</li>
<li><a href="https://transmissionbt.com/">Transmission</a> (<strong>Mac</strong>&#x2F;<strong>Linux</strong>&#x2F;Win)</li>
<li><a href="https://github.com/rakshasa/rtorrent">rtorrent</a>+<a href="https://github.com/Novik/ruTorrent">RuTorrent</a> (<strong>Linux</strong>)</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<h4 id="Aira2"><a href="#Aira2" class="headerlink" title="Aira2"></a>Aira2</h4></blockquote>
<p><a href="https://p3terx.com/archives/aria2-started-guide.html">Aria2 新手入门教程</a> </p>
<h3 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h3><blockquote>
<h4 id="PotPlayer"><a href="#PotPlayer" class="headerlink" title="PotPlayer"></a>PotPlayer</h4></blockquote>
<p>最牛逼的视频播放工具，不过需要一番调教之后才能发挥它巨大的潜力，使用默认的配置很渣。</p>
<ul>
<li>[<a href="https://vcb-s.com/archives/7228">VCB-Studio 科普教程 2.2] 基于 PotPlayer 和 madVR 的播放器教程（已更新 XySubFilter)</a></li>
<li>[<a href="https://vcb-s.com/archives/5610">VCB-Studio 科普教程 2.1] madVR 渲染器配置教程（2016.08.13 更新）</a></li>
<li>[<a href="https://vcb-s.com/archives/4567">VCB-Studio 科普教程 5] 那些播放器教程背后的知识</a></li>
<li><a href="https://vcb-s.com/archives/4384">VCB-Studio 科普教程 1.2 PotPlayer 播放器教程（入门篇</a></li>
</ul>
<blockquote>
<p>MPV</p>
</blockquote>
<p>mpv 是著名开源项目 MPlayer 的分支，因其对最新软硬件平台、视频标准以及各种高画质选项的支持而广受好评，也是目前非 Windows 平台上高画质播放器的不二选择。</p>
<ul>
<li>[<a href="https://vcb-s.com/archives/7594">VCB-Studio 科普教程 2.3] 跨平台播放器 mpv 配置入门</a></li>
</ul>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>toy</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度的分析</title>
    <url>/2022/11/25/timeComplexity/</url>
    <content><![CDATA[<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p><strong>事后分析估算方法</strong></p>
<p>当执行程序时，想要计算时间最比较容易联想到的方法就是拿个定时器进行计时，但是这个方法有个缺陷：就是机器性能问题很影响计算的时间，两台不同机器运算的时间结果天差地别，所以我们需要采用下面所说的方法更可科学的估算出算法的执行时间。</p>
<p><strong>事后分析估算方法</strong></p>
<p>计算机程序在计算机上运行所消耗的时间取决于下列因素：</p>
<ul>
<li>算法采用的策略和方案</li>
<li><del>编译产生的代码质量</del></li>
<li>问题的输入规模（输入量的多少）</li>
<li><del>机器执行指令的速度</del></li>
</ul>
<p>抛开上面的软硬件（程序员无法干预）的问题，那么我们可以知道一个软件的运行时间就是依赖于算法的好坏的问题的输入规模。如果算法固定，那么算法的执行时间就只和问题的输入规模有关系了。</p>
<p>EG.分析下面两个算法的执行次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用一层for循环来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用等差数列来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上我们不难分析，同样的一个等差和的算法，两个程序执行的次数并不相同，第一个执行了n次，而第二个只执行了1次，当n足够大时，第二个算法的运行速度远远高于另一个的速度，这个时候就体现了一个优秀算法将大大优化程序的运行时间。</p>
<p>要分析时间复杂度（也即程序运行的时间）的时候我们只需要关心核心操作的次数和输入规模的关联情况。<code>sum += i;</code>和<code>sum = (n+1)*n/2;</code>很明显为程序的核心计算部分，所以我们可以得出第一个<code>sun += i</code> 执行了n次，所以时间复杂度为O(n)，而<code>sum = (n+1)*n/2;</code>执行了1次，则时间复杂度为O(1)。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252114396.png" alt="image-20221125211412336" style="zoom:33%;" />

<h4 id="函数渐进增长"><a href="#函数渐进增长" class="headerlink" title="函数渐进增长"></a>函数渐进增长</h4><p>下面给出算法测试来计算不同函数执行次数的问题。</p>
<blockquote>
<p>EG1：假设测试输入规模都是n，分别执行四个算法，可得到下面结果</p>
</blockquote>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252130586.png" alt="image-20221125213058541"></p>
<p>可以看出，前期时候某些算法的执行次数可以优于其他算法，但是到n取一定大小时，可以渐进增大</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252138943.png" alt="image-20221125213804883" style="zoom:50%;" />

<p>由此图可以得出结论：<strong>随着输入规模的增大，算法的操作次数趋同，常数操作可以忽略不计。</strong></p>
<blockquote>
<p>EG2：引入平方根的算法次数分析</p>
</blockquote>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252132884.png" alt="image-20221125213213838"></p>
<p>可以看出：次方才是影响算法执行次数的最大因素</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252155016.png" alt="image-20221125215539955" style="zoom:50%;" />

<p>由此图可以得出结论：<strong>随着输入规模的增大，与最高次项相乘的常数可以忽略。</strong></p>
<blockquote>
<p>EG3：不同次方根的执行次数</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252202991.png" alt="image-20221125220243943" style="zoom: 67%;" />

<p>由此图可以得出结论：<strong>最高次项的指数大的，随着n的增长，结果也会增长特别快。</strong></p>
<blockquote>
<p>EG4:函数不同次幂的情况</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252206239.png" alt="image-20221125220634188" style="zoom: 50%;" />

<p>由此图可以得出结论：<strong>算法函数的最高次幂越小，算法效率越高。</strong></p>
<h5 id="总结-sake"><a href="#总结-sake" class="headerlink" title="总结:sake:"></a>总结:sake:</h5><blockquote>
<p>算法随着输入规模的增长量增大，可以有以下规则</p>
</blockquote>
<ol>
<li><p>常数可以忽略</p>
</li>
<li><p>最高次幂的常数因子可以忽略</p>
</li>
<li><p>最高次幂越小，算法效率越高</p>
</li>
</ol>
<h4 id="大O记法"><a href="#大O记法" class="headerlink" title="大O记法"></a>大O记法</h4><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T()n随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作：T(n)&#x3D;O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。</p>
<p>我们需要明确一个事情：执行次数&#x3D;执行时间</p>
<p>用大写O()来体现算法时间复杂度的记法，我们称之为大O记法,下面给出例子：</p>
<blockquote>
<p>EG1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EG2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i; <span class="comment">//执行了n次</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>EG3</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//执行了1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum += i; <span class="comment">//执行了n^2次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>忽略输入输出语句的执行次数，当输入规模为n时，三个算法の执行次数为：</p>
<p>EG1：3次</p>
<p>EG2：n+3次</p>
<p>EG3：n^2+3次</p>
<p>通过<strong>函数渐进增长</strong>的分析，大O阶的表示法有以下几个规则可以使用：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数中，只保留高阶项</li>
<li>如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数</li>
</ol>
<p>所以，以上算法的大O记法为：</p>
<p>EG1：O(1)</p>
<p>EG2：O(n)</p>
<p>EG3：O(n^2)</p>
<h5 id="常见大O阶"><a href="#常见大O阶" class="headerlink" title="常见大O阶"></a>常见大O阶</h5><p><strong>线性阶</strong></p>
<p>一般含有非嵌套循环，线性阶随着输入规模的扩大，对应计算的次数呈直线增长。</p>
<blockquote>
<p>EG 时间复杂度为O(n)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>平方阶</strong></p>
<p>一般嵌套循环属于这种时间复杂度</p>
<blockquote>
<p>EG 时间复杂度为O(n^2)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                sum += j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>立方阶</strong></p>
<p>三层嵌套循环术语这种时间复杂度</p>
<blockquote>
<p>EG 时间复杂度为O(n^3)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    sum += j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对数阶</strong></p>
<p>看下面程序，每次sum*2之后，就距离n更近一步，因为是2^sum&#x3D;n,所以得到x&#x3D;log(2)n,所以这个循环的时间复杂度为O(logn)</p>
<blockquote>
<p>EG 时间复杂度为O(logn)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt; n) &#123;</span><br><span class="line">            sum = sum * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于对数阶，随着n的增大，不管底数为多少，他们的增长趋势是一样的，所以忽略底数</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261201078.png" alt="image-20221126120145984" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211261214740.png" alt="image-20221126121404669" style="zoom:50%;" />

<p><strong>常数阶</strong></p>
<p>一般不涉及循环操作的都是常数阶，因为不会随着n的增长而增加操作次数。</p>
<blockquote>
<p>EG 时间复杂度为O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h5><table>
<thead>
<tr>
<th>描述</th>
<th>增长的数量级</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>常数级别</td>
<td>1</td>
<td>普通语句</td>
<td>两数相加</td>
</tr>
<tr>
<td>对数级别</td>
<td>log(n)</td>
<td>二分策略</td>
<td>二分查找</td>
</tr>
<tr>
<td>线性级别</td>
<td>n</td>
<td>循环</td>
<td>找出最大元素</td>
</tr>
<tr>
<td>线性对数</td>
<td>Nlog(n)</td>
<td>分治思想</td>
<td>归并排序</td>
</tr>
<tr>
<td>平方级别</td>
<td>n^2</td>
<td>双层循环</td>
<td>检查所有元素对</td>
</tr>
<tr>
<td>立方级别</td>
<td>n^3</td>
<td>三层循环</td>
<td>检查所有三元组</td>
</tr>
<tr>
<td>指数级别</td>
<td>2^n</td>
<td>穷举查找</td>
<td>检查所有子集</td>
</tr>
</tbody></table>
<blockquote>
<p>复杂程度从低到高为 O(1)&lt;O(logn)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)</p>
</blockquote>
<p>从前面的折线图不难看出，随着输入规模的增大，时间成本会急剧增大，所以当算法的时间复杂度为平方、立方或者更复杂时，我们可以认为该算法为不可取的，需要进行优化。</p>
<h4 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h4><blockquote>
<p>EG判断下面循环执行的次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> ?;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == arr[i])&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该循环执行了&quot;</span>+i+<span class="string">&quot;次&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最好情况</strong></p>
<p>​		查找的第一次数字就是期望的数字，那么算法的时间复杂度为O(1)</p>
<p><strong>最坏情况</strong></p>
<p>​		查找的最后一个数字才是期望的数字，那么算法的时间复杂度为O(n)</p>
<p><strong>平均情况</strong></p>
<pre><code>     任何数字查找的平均成本时O(n/2)
</code></pre>
<p>最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，不然提到的运行时间都指的是<strong>最坏</strong>情况下的运行时间。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/10/10/network/</url>
    <content><![CDATA[<h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h2><p><strong>网络协议</strong></p>
<p>协议 (protocol) 定义了在两个或多个通信实体之间交换的报文的格式和顺 序，以及报文发送和或接收一条报文或其他事件所采取的动作</p>
<p>掌握计算机网络领域知识的过程就是理解网络协议的构成原理和工作方式的过程。</p>
<p><strong>网络边缘</strong></p>
<p>处于互联网的边缘，与因特网相连的计算机和其他设备称为端系统。包括了桌面计算机、服务器、和移动计算机。</p>
<p>网络核心&lt;——&gt;主机 互相连接</p>
<p>端系统（主机）</p>
<ul>
<li>运行应用程序</li>
<li>如Web、email</li>
</ul>
<p>C&#x2F;S模式</p>
<ul>
<li>客户端向服务器请求、接收服务</li>
</ul>
<p>对等(peer-peer)模式（迅雷P2P</p>
<ul>
<li>没有专门的服务器</li>
</ul>
<h3 id="网络核心：电路交换"><a href="#网络核心：电路交换" class="headerlink" title="网络核心：电路交换"></a><strong>网络核心：电路交换</strong></h3><p> 端到端的资源被分配给从源端 到目标端的呼叫 “call”</p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006205931503.png" alt="image-20221006205931503"></p>
<p>图中，每段链路有4条线路： </p>
<ul>
<li><p>该呼叫采用了上面链路的第2 个线路，右边链路的第1个线路（piece） </p>
</li>
<li><p>独享资源：不同享 </p>
<p>每个呼叫一旦建立起来就能够 保证性能 </p>
<p>如果呼叫没有数据发送，被分配 的资源就会被浪费 (no sharing) </p>
<p>通常被传统电话网络采用k</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221006195008733.png" style="zoom:33%;" />

<p>为呼叫预留端-端资源 </p>
<ul>
<li>链路带宽、交换能力 </li>
<li>专用资源：不共享 </li>
<li>保证性能 </li>
<li>要求建立呼叫连</li>
</ul>
<p><strong>电路交换不适合计算机之间的通信</strong></p>
<ul>
<li>连接建立时间长</li>
<li>计算机之间的通信有突发性，如果使用线路交 换，则浪费的片较多  <ul>
<li>即使这个呼叫没有数据传递，其所占据的片也不能 够被别的呼叫使用</li>
</ul>
</li>
</ul>
<h3 id="网络核心：分组交换"><a href="#网络核心：分组交换" class="headerlink" title="网络核心：分组交换"></a><strong>网络核心：分组交换</strong></h3><ul>
<li>以分组为单位储存<ul>
<li>网络带宽资源不再分分为一个个片，传输时使用全部带宽</li>
<li>主机之间传输的数据被分为一 个个分组</li>
</ul>
</li>
<li>资源共享，按需使用<ul>
<li>存储-转发：分组每次移 动一跳<ul>
<li>在转发之前，节点必须收到 整个分组</li>
<li>延迟比线路交换要大</li>
<li>排队时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>分组交换 vs. 电路交换</strong></p>
<p>分组交换是“突发数据的胜利者？”</p>
<ul>
<li>适合于对突发式数据传输<ul>
<li>资源共享</li>
<li>简单，不必建立呼叫</li>
</ul>
</li>
<li>过度使用会造成网络拥塞：分组延时和丢失<ul>
<li>对可靠地数据传输需要协议来约束：拥塞控制</li>
</ul>
</li>
</ul>
<p><strong>分组交换网络：存储-转发</strong></p>
<ul>
<li>分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分为<ol>
<li>数据报网络<ul>
<li>分组的目标地址决定下一跳</li>
<li>在不同的阶段，路由可以改变</li>
</ul>
</li>
<li>虚电路网络：<ul>
<li>每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</li>
<li>在呼叫建立时决定路径，在整个呼叫中路径保持不变</li>
<li>路由器维持每个呼叫的状态信息</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="数据报的工作原理"><a href="#数据报的工作原理" class="headerlink" title="数据报的工作原理"></a><strong>数据报的工作原理</strong></h3><ul>
<li>在通信之前,无须建立起一个连接,有数据就传输</li>
<li>每一个分组都独立路由(路径不一样,可能会失序)</li>
<li>路由器根据分组的目标地址进行路由</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007102959687.png" alt="image-20221007102959687"></p>
<p><strong>接入网和物理媒体</strong></p>
<ul>
<li><p>住宅接入：modem</p>
</li>
<li><p>接入网: digital subscriber line (DSL)</p>
</li>
<li><p>物理媒体：同轴电缆、光纤</p>
</li>
</ul>
<h3 id="网络结构和ISP"><a href="#网络结构和ISP" class="headerlink" title="网络结构和ISP"></a><strong>网络结构和ISP</strong></h3><ul>
<li><p>ISPs (Internet Service Providers)：因特网服务提供商</p>
</li>
<li><p>中心：第一层ISP（如UUNet, BBN&#x2F;Genuity, Sprint,  AT&amp;T）国家&#x2F;国际覆盖，速率极高</p>
<ul>
<li>直接与其他第一层ISP相吃连</li>
<li>与大量的第二层ISP和其他客户网络相连</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007114949144.png" alt="image-20221007114949144" style="zoom:50%;" />

<ul>
<li>第二层ISP: 更小些的 (通常是区域性的) ISP<ul>
<li>与一个或多个第一层ISPs，也可能与其他第二层ISP</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007115043389.png" alt="image-20221007115043389" style="zoom:50%;" />

<ul>
<li>第三层ISP与其他本地ISP<ul>
<li>接入网 (与端系统最近)</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007115135198.png" alt="image-20221007115135198" style="zoom: 50%;" />

<ul>
<li>ISP之间的连接<ul>
<li>POP：高层ISP面向客户网络的接入点，涉及费用结算<ul>
<li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li>
</ul>
</li>
<li>对等接入：2个ISP对等互接，不涉及费用结算</li>
<li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算</li>
<li>ICP：自己部署专用网络，同时和各级ISP连接</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/image-20221007115555904.png" alt="image-20221007115555904" style="zoom:67%;" />

<h3 id="分组延时"><a href="#分组延时" class="headerlink" title="分组延时"></a><strong>分组延时</strong></h3><p>节点处理延时：nodal processing</p>
<ul>
<li>通常是微秒数量级或更</li>
</ul>
<p>排队延时：queueing</p>
<ul>
<li>取决于拥塞程度</li>
</ul>
<p>传输延时：transmission </p>
<ul>
<li>&#x3D; L&#x2F;R, 对低速率的链路而言很大（如拨号），通常为微秒级 到毫秒级</li>
</ul>
<p>传播延时：propagation</p>
<ul>
<li>几微秒到几百毫秒</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210091652256.png" alt="image-20221009165208210" style="zoom:50%;" />

<p><strong>分组丢失</strong></p>
<ul>
<li>链路的队列缓冲区容量有限</li>
<li>当分组到达一个满的队列时，该分组将会丢失 </li>
<li>丢失的分组可能会被前一个节点或源端系统重传，或根本不重传</li>
</ul>
<p> Ps: TTL的概念:ICMP包的转发次数（跳数）,最大值是255,每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL&#x3D;0的IP包并向IP包的发送者发送 ICMP time exceeded消息</p>
<p><strong>吞吐量</strong></p>
<p>在源端和目标端之间传输的速率（数据量&#x2F;单位时间）</p>
<ul>
<li><p><em>瞬间吞吐量:</em> 在一个时间点的速率</p>
</li>
<li><p><em>平均吞吐量:</em> 在一个长时间内平均</p>
</li>
<li><p>瓶颈链路：端到端路径上，限制端到端吞吐的链路</p>
</li>
</ul>
<h3 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h3><p><strong>服务和服务访问点</strong></p>
<ul>
<li><p>服务：低层实体向上层实体提供它们之间的通信的能力</p>
</li>
<li><p>原语（API）：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的—形式</p>
</li>
<li><p>服务访问点 SAP (Services Access Point) ：上层使用下层提供的服务通过层间的接口—地点 Ps : 传输层端口SAP</p>
</li>
</ul>
<p><strong>服务与协议</strong></p>
<ul>
<li><p>服务(Service)：低层实体向上层实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直</p>
</li>
<li><p>协议(protocol) ：对等层实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平</p>
</li>
</ul>
<p>关系</p>
<ul>
<li>本层协议的实现要靠下层提供的服务来实现 </li>
<li>本层实体通过协议为上层提供更高级</li>
</ul>
<p><strong>数据单元</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210100948378.png" alt="image-20221010094835303" style="zoom:33%;" />
$$
关系：一对多、一对一、多对多
$$
**Internet 协议栈**

<ul>
<li><p>应用层: 网络应用 </p>
<ul>
<li>为人类用户或者其他应用进程提供网络应用服务 </li>
<li>FTP, SMTP, HTTP,DNS</li>
</ul>
</li>
<li><p>传输层: 主机之间的数据传输 </p>
<ul>
<li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信 </li>
<li>TCP, UDP</li>
</ul>
</li>
<li><p>网络层: 为数据报从源到目的选择路由 </p>
<ul>
<li>主机主机之间的通信，端到端通信，不可靠 </li>
<li>IP, 路由协议</li>
</ul>
</li>
<li><p>链路层: 相邻网络节点间的数据传输 </p>
<ul>
<li>2个相邻2点的通信，点到点通信，可靠或不可靠 </li>
<li>点对对协议PPP, 802.11(Wi-Fi), Ethernet</li>
</ul>
</li>
<li><p>物理层: 在线路上传送bit</p>
</li>
</ul>
<p><strong>参考模型</strong></p>
<ul>
<li><p>表示层: 允许应用解释传输的 数据  eg. 加密，压缩，机 器相关的表示转换</p>
</li>
<li><p>会话层: 数据交换的同步，检查点，恢复</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210101330723.png" alt="image-20221010133003673" style="zoom:33%;" />

<p><strong>协议数据单元</strong></p>
<ul>
<li>应用层：报文(message) </li>
<li>传输层：报文段(segment)：TCP段，UDP数据报 </li>
<li>网络层：分组packet（如果无连接方式：数据报 datagram） </li>
<li>数据链路层：帧(frame) </li>
<li>物理层：位(bit)</li>
</ul>
<h3 id="Internet历史"><a href="#Internet历史" class="headerlink" title="Internet历史"></a>Internet历史</h3><ul>
<li><p><strong>早期（1960年以前的）网络</strong></p>
<ul>
<li>线路交换网络 </li>
<li>线路交换的特性使得其不适合计算机之间的通信 <ul>
<li>线路建立时间过长 </li>
<li>独享方式占用通信资源，不适合突发性很强的计算机之间的通信 </li>
<li>可靠性不高：非常不适合军事通信</li>
</ul>
</li>
<li>三个小组独立地开展分组交换的研究</li>
</ul>
</li>
<li><p><strong>1961-1972: 早期的分组交换概念</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210111533731.png" alt="image-20221011153340655" style="zoom:50%;" />
</li>
<li><p><strong>1972-1980: 专用网络和网络互联</strong></p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210111534382.png" alt="image-20221011153431328" style="zoom:50%;" />

<ul>
<li><strong>1980-1990: 体系结构变化, 网络数量激增，应用丰富</strong></li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210111535086.png" alt="image-20221011153514037" style="zoom:50%;" />

<ul>
<li><strong>1990, 2000’s: 商业化, Web, 新的应用</strong></li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210111537020.png" alt="image-20221011153738964" style="zoom:50%;" />

<ul>
<li><strong>2005-现在</strong></li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210111556676.png" alt="image-20221011155618628" style="zoom:50%;" />

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>组成角度看什么是互联网 </p>
<ul>
<li><p>边缘：端系统（包括应用）+接入网 </p>
</li>
<li><p>核心：网络交换设备+通信链路 </p>
</li>
<li><p>协议：对等层实体通信过程中遵守的规则的集合 </p>
<ul>
<li>语法，语义，时序</li>
</ul>
</li>
</ul>
<p>为了实现复杂的网络功能，采用分层方式设计、实现和调试 </p>
<ul>
<li>应用层，传输层，网络层，数据链路层，物理层 </li>
<li>协议数据单位：  报文，报文段，分组，帧，位</li>
</ul>
<p>从 服务角度看互联网 </p>
<ul>
<li><p>通信服务基础设施 </p>
<ul>
<li>提供的通信服务：面向连接 无连接</li>
</ul>
</li>
<li><p>应用</p>
</li>
</ul>
<p>应用之间的交互 </p>
<ul>
<li>C&#x2F;S模式 </li>
<li>P2P模式</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>网络应用的原理：网络应用协议的概念和实现方面</p>
<ul>
<li>传输层的服务模型</li>
<li>客户-服务器模式</li>
<li>对等模式(peer-to-peer)</li>
<li>内容分发网络</li>
</ul>
<p>网络应用的实例：互联网流行的应用层协议</p>
<ul>
<li>HTTP</li>
<li>FTP</li>
<li>SMTP &#x2F; POP3 &#x2F; IMAP</li>
<li>DNS</li>
</ul>
<p>编程：网络应用程序</p>
<ul>
<li>Socket API</li>
</ul>
<h3 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a><strong>应用架构</strong></h3><ul>
<li>客户-服务器模式（C&#x2F;S:client&#x2F;server）</li>
<li>对等模式(P2P:Peer To Peer)</li>
<li>混合体：客户-服务器和对等体系</li>
</ul>
<p><strong>客户-服务器（C&#x2F;S）体系结构</strong></p>
<ul>
<li><p>服务器:<br>一直运行<br>固定的IP地址和周知的端口号（约定）</p>
<p>扩展性：服务器场</p>
<ul>
<li>数据中心进行扩展 </li>
<li>扩展性差</li>
</ul>
</li>
<li><p>客户端:<br> 主动与服务器通信<br> 与互联网有间歇性的连接<br> 可能是动态IP 地址<br> 不直接与其它客户</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210212145666.png" alt="image-20221021214513597" style="zoom: 50%;" />

<p><strong>对等体（P2P）体系结构</strong></p>
<ul>
<li>（几乎）没有一直运行的服务器</li>
<li>任意端系统之间可以进行通信</li>
<li>每一个节点既是客户端又是服务器<ul>
<li>自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求</li>
</ul>
</li>
<li>参与的主机间歇性连接且可以改变IP 地址 <ul>
<li>难以管理</li>
<li>例子: Gnutella，迅雷</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210212146714.png" alt="image-20221021214616664" style="zoom:50%;" />

<p><strong>C&#x2F;S和P2P体系结构的混合体</strong></p>
<p>Napster<br>文件搜索：集中 </p>
<ul>
<li>主机在中心服务器上注册其资源 </li>
<li>主机向中心服务器查询资源位置<br>文件传输：P2P</li>
<li>任意Peer节点之间<br>即时通信<br>在线检测：集中</li>
<li>当用户上线时，向中心服务器注册其IP地址</li>
<li>用户与中心服务器联系，以找到其在线好友的位置<br>两个用户之间聊天：P2P</li>
</ul>
<p><strong>进程通信</strong></p>
<p>进程：在主机上运行的应用程序</p>
<ul>
<li>在同一个主机内，使用进程间通信机制通信（操作系统定义）</li>
<li>不同主机，通过交换报文（Message）来通信<ul>
<li>使用OS提供的通信服务</li>
<li>按照应用协议交换报文 <ul>
<li>借助传输层提供的服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>客户端进程</th>
<th>服务端进程</th>
</tr>
</thead>
<tbody><tr>
<td>发起通信的进程</td>
<td>等待连接的进程</td>
</tr>
</tbody></table>
<p><strong>分布式进程通信需要解决的问题</strong></p>
<blockquote>
<p>进程标示和寻址问题（服务用户）</p>
</blockquote>
<ul>
<li>对进程进行编址（addressing）</li>
<li>进程为了接收报文，必须有一个标识	即：SAP（发送也需要标示）<ul>
<li>主机：唯一的 32位IP地址 <ul>
<li>仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很多应用进程在运行</li>
</ul>
</li>
<li>所采用的传输层协议：TCP or UDP</li>
<li>端口号（Port Numbers）</li>
</ul>
</li>
<li>一些知名端口号的例子：<ul>
<li>HTTP: TCP 80 Mail: TCP25 ftp:TCP 2</li>
</ul>
</li>
<li>一个进程：用IP+port标示 端节点</li>
<li>本质上，一对主机进程之间的通信由2个端节点构成</li>
</ul>
<blockquote>
<p>传输层提供的服务-需要穿过层间的信息</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221041373.png" alt="image-20221022104125324" style="zoom:50%;" />

<p>层间接口必须要携带的信息 </p>
<ul>
<li>要传输的报文（对于本层来说：SDU） </li>
<li>谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口 </li>
<li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号<br>传输层实体（tcp或者udp实体）根据这些信息进行TCP报文段（UDP数据报）的封装</li>
<li>源端口号，目标端口号，数据等 </li>
<li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li>
</ul>
<blockquote>
<p>传输层提供的服务-层间信息的代表</p>
</blockquote>
<p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p>
<ul>
<li>用个代号标示通信的双方或者单方：socket</li>
<li>就像OS打开文件返回的句柄一样<ul>
<li>对句柄的操作，就是对文件的操作</li>
</ul>
</li>
<li>TCP socket： <ul>
<li>TCP服务，两个进程之间的通信需要之前要建立连接 <ul>
<li>两个进程通信会持续一段时间，通信关系稳定</li>
</ul>
</li>
<li>可以用一个整数表示两个应用实体之间的通信关系，本地标示</li>
<li>穿过层间接口的信息量最小</li>
<li>TCP socket：源IP,源端口，目标IP，目标IP,目标端口</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221051745.png" alt="image-20221022105129685" style="zoom:50%;" />

<blockquote>
<p>传输层提供的服务-层间信息代码</p>
</blockquote>
<p>UDP socket： </p>
<ul>
<li>UDP服务，两个进程之间的通信需要之前无需建立连接 <ul>
<li>每个报文都是独立传输的 </li>
<li>前后报文可能给不同的分布式进程</li>
</ul>
</li>
<li>因此，只能用一个整数表示本应用实体的标示 <ul>
<li>因为这个报文可能传给另外一个分布式进程 ·1</li>
</ul>
</li>
<li>穿过层间接口的信息大小最小</li>
<li>UDP socket：本IP,本端口</li>
<li>但是传输 报文时：必须要提供对方IP，port <ul>
<li>接收报文时： 传输层需要上传对方的IP，port</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221056915.png" alt="image-20221022105628862" style="zoom:50%;" />

<p><em>套接字（Socket）</em></p>
<ul>
<li><p>进程向套接字发送报文或从套接字接收报文</p>
</li>
<li><p>套接字 &lt;-&gt; 门户 </p>
<ul>
<li>发送进程将报文推出门户，发送进程依赖于传输层设施在另外一侧的门将报文交付给接受进程   </li>
<li>接收进程从另外一端的门户收到报文（依赖于传输层设施)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221058709.png" alt="image-20221022105821666" style="zoom:50%;" /></li>
</ul>
<blockquote>
<p>如何使用传输层提供的服务实现应用</p>
</blockquote>
<ul>
<li>定义应用层协议：报文格式，解释，时序等</li>
<li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li>
</ul>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul>
<li><p>定义了：运行在不同端系统上的应用进程如何相互交换报文</p>
<ul>
<li>交换的报文类型：请求和应答报文</li>
<li>各种报文类型的语法：报文中的各个字段及其描述 </li>
<li>字段的语义：即字段取值的含义 </li>
<li>进程何时、如何发送报文及对报文进行响应的规则</li>
</ul>
</li>
<li><p>应用协议仅仅是应用的一个组成部分 </p>
<ul>
<li>Web应用：HTTP协议，web客户端，web服务器，HTML</li>
</ul>
</li>
</ul>
<p><em>公开协议：</em>由RFC文档定义允许互操作</p>
<ul>
<li>如HTTP, SMTP</li>
</ul>
<p><em>专用（私有）协议：</em>协议不公开</p>
<ul>
<li>如：Skype</li>
</ul>
<p><strong>Internet 传输层提供的服务</strong></p>
<p>TCP 服务：</p>
<ul>
<li>可靠的传输服务</li>
<li>流量控制：发送方不会淹没接受方</li>
<li>拥塞控制：当网络出现拥塞时，能抑制发送方</li>
<li>不能提供的服务：时间保证、最小吞吐保证和安全</li>
<li>面向连接：要求在客户端进程和服务器进程之间建立连接</li>
</ul>
<p>UDP 服务：</p>
<ul>
<li>不可靠数据传输</li>
<li>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接</li>
</ul>
<blockquote>
<p> UDP存在的必要性</p>
</blockquote>
<ul>
<li>能够区分不同的进程，而IP服务不能 <ul>
<li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li>
</ul>
</li>
<li>无需建立连接，省去了建立连接时间，适合事务性的应用</li>
<li>不做可靠性的工作，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用 <ul>
<li>因为为了实现可靠性（准确性、保序等），必须付出时间代<br>价（检错重发）</li>
</ul>
</li>
<li>没有拥塞控制和流量控制，应用能够按照设定的速度发送数据 <ul>
<li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<p><strong>Internet应用及其应用层协议和传输协议</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221117829.png" alt="image-20221022111719774" style="zoom:50%;" />

<p><strong>安全TCP</strong><br>TCP &amp; UDP </p>
<ul>
<li>都没有加密</li>
<li>明文通过互联网传输，甚至密码<br>SSL</li>
<li>在TCP上面实现，提供加密的TCP连接</li>
<li>私密性</li>
<li>数据完整性</li>
<li>端到端的鉴</li>
</ul>
<p>SSL在应用层</p>
<ul>
<li>应用采用SSL库，SSL库使用TCP通信<br>SSL socket API</li>
<li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li>
</ul>
<h3 id="Web-与-HTTP"><a href="#Web-与-HTTP" class="headerlink" title="Web 与 HTTP"></a>Web 与 HTTP</h3><p>术语</p>
<ul>
<li>Web页：由一些对象组成</li>
<li>对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等</li>
<li>Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）</li>
<li>通过URL对每个对象进行引用 <ul>
<li>访问协议，用户</li>
</ul>
</li>
</ul>
<p>URL格式:</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221125044.png" alt="image-20221022112518993" style="zoom:50%;" />

<p><strong>响应时间模型</strong></p>
<p>往返时间RTT（round-trip time）：一个小的分组从客户端到服务器，在回到客户端的时间（传输时间忽略）<br>响应时间：</p>
<ul>
<li>一个RTT用来发起TCP连接</li>
<li>一个 RTT用来HTTP请求并等待HTTP响应</li>
<li>文件传输时间<br>共：2RTT+传输时间</li>
</ul>
<p>基础：(<a href="https://dreamin.space/2022/09/12/Http/">Http基础 | Drzone (dreamin.space)</a>)</p>
<p><strong>用户-服务器状态：cookies</strong></p>
<p>大多数主要的门户网站使用 cookies<br>4个组成部分：</p>
<ol>
<li>在HTTP响应报文中有一个cookie的首部行</li>
<li>在HTTP请求报文含有一个cookie的首部行</li>
<li>在用户端系统中保留有一个cookie文件，由用户的浏览器管理</li>
<li>在Web站点有一个后端数据库</li>
</ol>
<p><strong>Cookies：维护状态</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221211939.png" alt="image-20221022121158868" style="zoom:50%;" />

<p>Cookies能带来什么：</p>
<ul>
<li><p>用户验证</p>
</li>
<li><p>购物车</p>
</li>
<li><p>推荐</p>
</li>
<li><p>用户状态 (Web e-mail)</p>
</li>
</ul>
<p>Cookies与隐私：</p>
<ul>
<li><p>Cookies允许站点知道许多关于用户的信息</p>
</li>
<li><p>可能将它知道的东西卖给第三方</p>
</li>
<li><p>使用重定向和cookie的搜索引擎还能知道用户更多的信息</p>
</li>
<li><p>如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式</p>
</li>
<li><p>广告公司从站点获得信息</p>
</li>
</ul>
<p><em>如何维持状态：</em></p>
<ul>
<li><p>协议端节点：在多个事务上，发送端和接收端维持状态</p>
</li>
<li><p>cookies: http报文携带状态信息</p>
</li>
</ul>
<p><strong>Web缓存 (代理服务器)</strong></p>
<p>目标：不访问原始服务器，就满足客户的请求。</p>
<ul>
<li><p>用户设置浏览器： 通过缓存访问Web</p>
</li>
<li><p>浏览器将所有的HTTP请求发给缓存 </p>
<ul>
<li>在缓存中的对象：缓存直接返回对象 </li>
<li>如对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221610265.png" alt="image-20221022161046155" style="zoom: 33%;" />

<ul>
<li>缓存既是客户端又是服务器</li>
<li>通常缓存是由ISP安装 (大学、公司、居民区ISP)</li>
</ul>
<blockquote>
<p>为什么要使用Web缓存</p>
</blockquote>
<ul>
<li>降低客户端的请求响应时间</li>
<li>可以大大减少一个机构内部网络与Internet接入链路上的流量</li>
<li>互联网大量采用了缓存：<br>可以使较弱的ICP也能够有效提供内容</li>
</ul>
<blockquote>
<p> Ps. 百分之八十的人访问了百分之二十的互联网内容，提高运输层带宽的成本远远高于部署Web本地缓存服务器</p>
</blockquote>
<p><strong>条件GET方法</strong></p>
<p>①目标：如果缓存器中的对象拷贝是最新的，就不要发送对象<br>②缓存器: 在HTTP请求中指定缓存拷贝的日期<br>If-modified-since:<br><date><br>③服务器: 如果缓存拷贝陈旧，则响应报文没包含对象:<br>HTTP&#x2F;1.0 304 Not<br>Modified</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221618319.png" alt="image-20221022161851247" style="zoom:33%;" />

<h3 id="FTP与Email"><a href="#FTP与Email" class="headerlink" title="FTP与Email"></a><strong>FTP与Email</strong></h3><p><strong>FTP: 文件传输协议</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221632734.png" alt="image-20221022163203692" style="zoom:50%;" />

<ul>
<li>向远程主机上传输文件或从远程主机接收文件</li>
<li>客户&#x2F;服务器模式 <ul>
<li>客户端：发起传输的一方</li>
<li>服务器：远程主机</li>
</ul>
</li>
<li>ftp: RFC 959</li>
<li>ftp服务器：端口号为21</li>
</ul>
<p><strong>FTP: 控制连接与数据连接分开</strong></p>
<ul>
<li>FTP客户端与FTP服务器通过端口21联系，并使用TCP为传输协议</li>
<li>客户端通过控制连接获得身份确认</li>
<li>客户端通过控制连接发送命令浏览远程目录</li>
<li>收到一个文件传输命令时，服务器打开一个到客户端的数据连接</li>
<li>一个文件传输完成后，服务器关闭连接</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210221634235.png" alt="image-20221022163410194" style="zoom: 50%;" />

<ul>
<li>服务器打开第二个TCP数据连接用来传输另一个文件</li>
<li>控制连接： 带外（ “out of band” ）传送</li>
<li>FTP服务器维护用户的状态信息：当前路径、用户帐户与控制连接对应</li>
</ul>
<p><strong>FTP命令、响应</strong></p>
<p><em>命令样例：</em></p>
<ul>
<li>在控制连接上以ASCII文本方式传送</li>
<li>USER username </li>
<li>PASS password</li>
<li>LIST：请服务器返回远程主机当前目录的文件列表</li>
<li>RETR filename：从远程主机的当前目录检索文件<br>(gets)</li>
<li>STOR filename：向远程主机的当前目录存放文件<br>(puts)</li>
</ul>
<p><em>返回码样例：</em></p>
<ul>
<li>状态码和状态信息 (同HTTP)</li>
<li>331 Username OK, password required</li>
<li>125 data connection already open; transfer starting</li>
<li>425 Can’t open data connection</li>
<li>452 Error writing file</li>
</ul>
<p><strong>电子邮件（Email）</strong></p>
<p>邮件服务器</p>
<ul>
<li>邮箱中管理和维护发送给用户的邮件</li>
<li>输出报文队列保持待发送邮件报文</li>
<li>邮件服务器之间的SMTP协议：发送email报文<ul>
<li>客户：发送方邮件服务器 </li>
<li>服务器：接收端邮件服务器</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210270959381.png" alt="image-20221027095903421" style="zoom:50%;" />

<p><strong>SMTP</strong></p>
<ul>
<li>使用TCP在客户端和服务器之间传送报文，端口号为25</li>
<li>直接传输：从发送方服务器到接收方服务器</li>
<li>传输的3个阶段<ul>
<li>握手</li>
<li>传输报文</li>
<li>关闭</li>
</ul>
</li>
<li>命令&#x2F;响应交互<ul>
<li>命令：ASCII文本</li>
<li>响应：状态码和状态信息</li>
</ul>
</li>
<li>报文必须为7位ASCII</li>
</ul>
<blockquote>
<p>特点</p>
</blockquote>
<ul>
<li>SMTP使用持久连接</li>
<li>SMTP要求报文（首部和主体）为7位ASCII编码</li>
<li>SMTP服务器使用CRLF.CRLF决定报文的尾部</li>
</ul>
<p>与HTTP比较：</p>
<ul>
<li>HTTP：拉（pull）</li>
<li>SMTP：推（push）</li>
<li>二者都是ASCII形式的命令&#x2F;响应交互、状态码</li>
<li>HTTP：每个对象封装在各自的响应报文中</li>
<li>SMTP：多个对象包含在一个报文中</li>
</ul>
<p><strong>邮件报文格式</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271010009.png" alt="image-20221027101028919" style="zoom: 50%;" />

<p>多媒体拓展</p>
<ul>
<li>MIME：多媒体邮件扩展（multimedia mail extension）, RFC 2045, 2056</li>
<li>在报文首部用额外的行申明MIME内容类</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271014185.png" alt="image-20221027101405139" style="zoom: 50%;" />

<p><strong>POP3协议</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271017668.png" alt="image-20221027101712614" style="zoom:50%;" />

<p><strong>POP3与IMAP</strong></p>
<p>POP3</p>
<p>(本地管理文件夹)</p>
<ul>
<li>先前的例子使用 “下载并删除”模式。<ul>
<li>如果改变客户机，Bob不能阅读邮件</li>
</ul>
</li>
<li>“下载并保留”：不同客户机上为报文的拷贝</li>
<li>POP3在会话中是无状态的</li>
</ul>
<p>IMAP</p>
<p>(远程管理文件夹)</p>
<ul>
<li>IMAP服务器将每个报文与一个文件夹联系起来</li>
<li>允许用户用目录来组织报文</li>
<li>允许用户读取报文组件</li>
<li>IMAP在会话过程中保留<br>  用户状态： <ul>
<li>目录名、报文ID与目录名之间映射</li>
</ul>
</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>DNS（Domain Name System）的必要性</strong></p>
<ul>
<li>IP地址标识主机、路由器</li>
<li>但IP地址不好记忆，不便人类使用(没有意义)</li>
<li>人类一般倾向于使用一些有意义的字符串来标识Internet上的设备<br>例如：<a href="mailto:&#x71;&#x7a;&#x68;&#x65;&#x6e;&#103;&#x40;&#x75;&#x73;&#116;&#99;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#x6e;">&#x71;&#x7a;&#x68;&#x65;&#x6e;&#103;&#x40;&#x75;&#x73;&#116;&#99;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#x6e;</a> 所在的邮件服务器<br><a href="http://www.ustc.edu.cn/">www.ustc.edu.cn</a> 所在的web服务器</li>
<li>存在着“字符串”—IP地址的转换的必要性</li>
<li>人类用户提供要访问机器的“字符串”名称</li>
<li>由DNS负责转换成为二进制的网络地址</li>
</ul>
<blockquote>
<p>DNS系统需要解决的问题</p>
</blockquote>
<ul>
<li>问题1：如何命名设备<ul>
<li>用有意义的字符串：好记，便于人类用使用</li>
<li>解决一个平面命名的重名问题：层次化命名</li>
</ul>
</li>
<li>问题2：如何完成名字到IP地址的转换<ul>
<li>分布式的数据库维护和响应名字查询</li>
</ul>
</li>
<li>问题3：如何维护：增加或者删除一个域，需要在域名系统中做哪些工作</li>
</ul>
<p><strong>DNS(Domain Name System)的历史</strong></p>
<ul>
<li>ARPANET的名字解析解决方案<ul>
<li>主机名：没有层次的一个字符串（一个平面）</li>
<li>存在着一个（集中）维护站：维护着一张 主机名-IP地址的映射文件：Hosts.txt</li>
<li>每台主机定时从维护站取文件</li>
</ul>
</li>
<li>ARPANET解决方案的问题</li>
<li>当网络中主机数量很大时</li>
<li>没有层次的主机名称很难分配</li>
<li>文件的管理、发布、查找都很麻烦</li>
</ul>
<p><strong>DNS(Domain Name System)总体思路和目标</strong></p>
<ul>
<li>DNS的主要思路<ul>
<li>分层的、基于域的命名机制</li>
<li>若干分布式的数据库完成名字到IP地址的转换</li>
<li>运行在UDP之上端口号为53的应用服务</li>
<li>核心的Internet功能，但以应用层协议实现  在网络边缘处理复杂性</li>
</ul>
</li>
<li>DNS主要目的：<ul>
<li>实现主机名-IP地址的转换(name&#x2F;IP translate)</li>
<li>其它目的<ul>
<li>主机别名到规范名字的转换：Host aliasing</li>
<li>邮件服务器别名到邮件服务器的正规名字的转换：Mail server aliasing</li>
<li>负载均衡：Load Distribution</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>DNS名字空间(The DNS Name Space)</strong></p>
<p>DNS域名结构</p>
<ul>
<li>一个层面命名设备会有很多重名</li>
<li>NDS采用层次树状结构的 命名方法</li>
<li>Internet 根被划为几百个顶级域(top lever domains)<ul>
<li>通用的(generic)<br>.com; .edu ; .gov ; .int ; .mil ; .net ; .org ; .firm ; .hsop ; .web ; .arts ; .rec ;<br>+国家的(countries)<br>.cn ; .us ; .nl ; .jp</li>
</ul>
</li>
<li>每个(子)域下面可划分为若干子域(subdomains)</li>
<li>树叶是主</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271055314.png" alt="image-20221027105515254" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271100862.png" alt="image-20221027110023799" style="zoom:50%;" />

<ul>
<li><p>域名的管理</p>
<ul>
<li>一个域管理其下的子域<br> .jp 被划分为 ac.jp co.jp</li>
</ul>
<p> .cn 被划分为 edu.cn com.cn</p>
<ul>
<li>创建一个新的域，必须征得它所属域的同意</li>
</ul>
</li>
<li><p>域与物理网络无关</p>
<ul>
<li>域遵从组织界限，而不是物理网络<ul>
<li>一个域的主机可以不在一个网络 </li>
<li>一个网络的主机不一定在一个域</li>
</ul>
</li>
<li>域的划分是逻辑的，而不是物理</li>
</ul>
</li>
</ul>
<p><strong>名字服务器(Name Server)</strong></p>
<ul>
<li>一个名字服务器的问题<ul>
<li>可靠性问题：单点故障</li>
<li>扩展性问题：通信容量</li>
<li>维护问题：远距离的集中式数据库</li>
</ul>
</li>
<li>区域(zone)<ul>
<li>区域的划分有区域管理者自己决定</li>
<li>将DNS名字空间划分为互不相交的区域，每个区域都是树的一部分</li>
<li>名字服务器： <ul>
<li>每个区域都有一个名字服务器：维护着它所管辖区域的权威信息(authoritative record)</li>
<li>名字服务器允许被放置在区域之外，以保障可靠</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271107892.png" alt="image-20221027110737818" style="zoom:50%;" />

<p>权威DNS服务器：组织机构的DNS服务器，提供组织机构服务器（如Web和mail）可访问的主机和IP之间的映射，组织机构可以选择实现自己维护或由某个服务提供商来维护</p>
<p><strong>TLD服务器</strong></p>
<ul>
<li>顶级域(TLD)服务器：负责顶级域名（如com, org, net, edu和gov）和所有国家级的顶级域名（如cn, uk, fr, ca, jp ）<ul>
<li>Network solutions 公司维护com TLD服务器</li>
<li>Educause公司维护edu TLD服务器</li>
</ul>
</li>
</ul>
<p><strong>区域名字服务器维护资源记录</strong></p>
<ul>
<li>资源记录(resource records)<ul>
<li>作用：维护 域名-IP地址(其它)的映射关系</li>
<li>位置：Name Server的分布式数据库中</li>
</ul>
</li>
<li>RR格式: (domain_name, ttl, type,class,Value)<ul>
<li>Domain_name: 域名</li>
<li>Ttl: time to live : 生存时间(权威，缓冲记录)</li>
<li>Class 类别 ：对于Internet，值为IN</li>
<li>Value 值：可以是数字，域名或ASCII串</li>
<li>Type 类别：资源记录的类型—见下页</li>
</ul>
</li>
</ul>
<p><strong>DNS记录</strong></p>
<p>DNS ：保存资源记录(RR)的分布式数据库</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271115926.png" alt="image-20221027111542866" style="zoom:50%;" />

<p><strong>资源记录</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271132989.png" alt="image-20221027113224909" style="zoom:50%;" />

<p>DNS大致工作过程</p>
<ul>
<li>应用调用 解析器(resolver)</li>
<li>解析器作为客户 向Name Server发出查询报文（封装在UDP段中）</li>
<li>Name Server返回响应报文(name&#x2F;ip)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271139873.png" alt="image-20221027113954828" style="zoom:50%;" />

<p><strong>本地名字服务器（Local Name Server）</strong></p>
<ul>
<li>并不严格属于层次结构</li>
<li>每个ISP (居民区的ISP、公司、大学）都有一个本地DNS服务器<ul>
<li>也称为“默认名字服务器”</li>
</ul>
</li>
<li>当一个主机发起一个DNS查询时，查询被送到其本地DNS服务器<ul>
<li>起着代理的作用，将查询转发到层次结构中</li>
</ul>
</li>
</ul>
<p><strong>名字服务器(Name Server)</strong></p>
<ul>
<li>名字解析过程<ul>
<li>目标名字在Local Name Server中<ul>
<li>情况1：查询的名字在该区域内部</li>
<li>情况2：缓存(cashing)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当与本地名字服务器不能解析名字时，联系根名字服务器顺着根-TLD一直找到权威名字服务器。</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271142467.png" alt="image-20221027114248425" style="zoom: 50%;" />

<p><strong>递归查询</strong></p>
<ul>
<li>名字解析负担都放在当前联络的名字服务器上</li>
<li>问题：根服务器的负担太重</li>
<li>解决： 迭代查询(iterated queries)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271147623.png" alt="image-20221027114731574" style="zoom: 50%;" />

<p><strong>迭代查询</strong></p>
<ul>
<li>主机cis.poly.edu 想知道主机 gaia.cs.umass.edu的IP地址<ul>
<li><p>根（及各级域名）服务器返回的不是查询结果，而是下一个NS的地址</p>
</li>
<li><p>后由权威名字服务器给出解析结果</p>
</li>
<li><p>当前联络的服务器给出可以联系的服务器的名字</p>
<p>“我不知道这个名字，但可以向这个服务器请求”</p>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271156706.png" alt="image-20221027115618660" style="zoom: 50%;" />

<p><em>DNS协议：查询和响应报文的报文格式相同</em></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271159768.png" alt="image-20221027115915717" style="zoom: 50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210271159759.png" alt="image-20221027115951702" style="zoom:50%;" />

<p><strong>提高性能：缓存</strong></p>
<ul>
<li>一旦名字服务器学到了一个映射，就将该映射缓存起来</li>
<li>根服务器通常都在本地服务器中缓存着<ul>
<li>根服务器不用经常被访问</li>
</ul>
</li>
<li>目的：提高效率</li>
<li>可能存在的问题：如果情况变化，缓存结果和权威资源记录不一致</li>
<li>解决方案：TTL（默认2天）</li>
</ul>
<p><strong>维护问题：新增一个域</strong></p>
<ul>
<li>在上级域的名字服务器中增加两条记录，指向这个新增的子域的域名和域名服务器的地址</li>
<li>在新增子域 的名字服务器上运行名字服务器，负责本域的名字解析： 名字-&gt;IP地址<br>例子：在com域中建立一个“Network Utopia”</li>
<li>到注册登记机构注册域名networkutopia.com<ul>
<li>需要向该机构提供权威DNS服务器（基本的、和辅助的）的名字和IP地址</li>
<li>登记机构在com TLD服务器中插入两条RR记录: (networkutopia.com,dns1.networkutopia.com, NS)<br>(dns1.networkutopia.com, 212.212.212.1, A)</li>
</ul>
</li>
<li>在networkutopia.com的权威服务器中确保有<ul>
<li>用于Web服务器的 <a href="http://www.networkuptopia.com/">www.networkuptopia.com</a> 的类型为A的记录</li>
<li>用于邮件服务器mail.networkutopia.com的类型为MX的记</li>
</ul>
</li>
</ul>
<p><strong>攻击DNS</strong></p>
<p>DDoS 攻击</p>
<ul>
<li>对根服务器进行流量轰炸攻击：发送大量ping<ul>
<li>没有成功</li>
<li>原因１：根目录服务器配置了流量过滤器，防火墙</li>
<li>原因２：Local DNS 服务器缓存了TLD服务器的IP地址, 因此无需查询根服务器</li>
</ul>
</li>
<li>向TLD服务器流量轰炸攻击：发送大量查询<ul>
<li>可能更危险</li>
<li>效果一般，大部分DNS缓存了TLD</li>
</ul>
</li>
</ul>
<p>重定向攻击</p>
<ul>
<li>中间人攻击<ul>
<li>截获查询，伪造回答，从而攻击某个（DNS回答指定的IP）站点</li>
</ul>
</li>
<li>DNS中毒<ul>
<li>发送伪造的应答给DNS服务器，希望它能够缓存这个虚假的结果</li>
</ul>
</li>
<li>技术上较困难：分布式截获和伪造利用DNS基础设施进行DDoS</li>
<li>伪造某个IP进行查询， 攻击这个目标IP</li>
<li>查询放大，响应报文比查询报文大</li>
<li>效果有限</li>
</ul>
<h3 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h3><p><strong>纯P2P架构</strong></p>
<ul>
<li>没有（或极少）一直运行的服务器</li>
<li>任意端系统都可以直接通信</li>
<li>利用peer的服务能力</li>
<li>Peer节点间歇上网，每次IP地址都有可能变化</li>
</ul>
<p>例子:</p>
<ul>
<li>文件分发 (BitTorrent)</li>
<li>流媒体(KanKan)</li>
<li>VoIP (Skype)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210290949818.png" alt="image-20221029094951733" style="zoom:50%;" />

<p><em>文件分发: C&#x2F;S vs P2P</em></p>
<blockquote>
<p>从一台服务器分发文件（大小F）到N个peer需要多少时间？</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291014883.png" alt="image-20221029101421842" style="zoom: 67%;" />


<p><strong>文件分发时间: C&#x2F;S模式</strong></p>
<p>服务器传输： 都是由服务器发送给peer，服务器必须顺序传输（上载）N个文件拷贝:</p>
<ul>
<li>发送一个copy: F&#x2F;Us</li>
<li>发送N个copy： NF&#x2F;Us</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291011901.png" alt="image-20221029101124855" style="zoom: 50%;" />

<ul>
<li>客户端: 每个客户端必须下载一个文件拷贝</li>
<li>d(min) &#x3D; 客户端最小的下载速率</li>
<li>下载带宽最小的客户端下载的时间：F&#x2F;d(min)</li>
</ul>
<p>文件下载耗时（随着N线性增长）<br>Dc-s &gt; max{NF&#x2F;us,,F&#x2F;dmin</p>
<p><strong>文件分发时间: P2P模式</strong></p>
<ul>
<li>服务器传输：最少需要上载一份拷贝<ul>
<li>发送一个拷贝的时间：F&#x2F;us</li>
</ul>
</li>
<li>客户端: 每个客户端必须下载一个拷贝<ul>
<li>最小下载带宽客户单耗时：: F&#x2F;dmin</li>
</ul>
</li>
<li>客户端: 所有客户端总体下载量NF<ul>
<li>最大上载带宽是：us+Sui</li>
<li>除了服务器可以上载，其他所有的peer节点都可以上载</li>
</ul>
</li>
</ul>
<p>文件下载耗时（分子随着N线性变化，每个节点需要下载，整体下载量随着N增大，分母也是如此,随着peer节点的增多 每个peer也带了服务能力）<br>DP2P &gt; max{F&#x2F;us,,F&#x2F;dmin,,NF&#x2F;(us + Sui)}</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291048048.png" alt="image-20221029104814996" style="zoom:50%;" />

<p><strong>P2P文件分发： BitTorrent</strong></p>
<ul>
<li>文件被分为一个个块256KB</li>
<li>网络中的这些peers发送接收文件块，相互服务</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291059943.png" alt="image-20221029105916875" style="zoom:50%;" />

<ul>
<li>Peer加入torrent: <ul>
<li>一开始没有块，但是将会通过其他节点处累积文件块</li>
<li>向跟踪服务器注册，获得peer节点列表，和部分peer节点构成邻居关系 (“连接”)</li>
</ul>
</li>
<li>当peer下载时，该peer可以同时向其他节点提供上载服务</li>
<li>Peer可能会变换用于交换块的peer节点</li>
<li>扰动churn: peer节点可能会上线或者下线</li>
<li>一旦一个peer拥有整个文件，它会（自私的）离开或者保留（利他主义）在torrent中</li>
</ul>
<p><strong>BitTorrent: 请求，发送文件块</strong></p>
<p>请求块：</p>
<ul>
<li>在任何给定时间，不同peer节点拥有一个文件块的子集</li>
<li>周期性的，Alice节点向邻居询问他们拥有哪些块的信息</li>
<li>Alice向peer节点请求它希望的块，稀缺的块</li>
</ul>
<p>发送块：一报还一报 tit-for-tat</p>
<ul>
<li>Alice向4个peer发送块，这些块向它自己提供最大带宽的服务<ul>
<li>其他peer被Alice阻塞 (将不会从Alice处获得服务)</li>
<li>每10秒重新评估一次：前4位</li>
</ul>
</li>
<li>每个30秒：随机选择其他peer节点，向这个节点发送块<ul>
<li>“优化疏通” 这个节点</li>
<li>新选择的节点可以加入这个top</li>
</ul>
</li>
</ul>
<blockquote>
<p>BitTorrent: tit-for-tat</p>
</blockquote>
<p>(1) Alice “优化疏通” Bob<br>(2) Alice 变成了Bob的前4位提供者; Bob答谢Alice<br>(3) Bob 变成了Alice的前4提供者</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291104005.png" alt="image-20221029110439941" style="zoom:50%;" />

<blockquote>
<p>两大问题：</p>
</blockquote>
<ul>
<li>如何定位所需资源</li>
<li>如何处理对等方的加入与离开</li>
</ul>
<blockquote>
<p>可能的方案</p>
</blockquote>
<ul>
<li>集中</li>
<li>分散</li>
<li>半分散</li>
</ul>
<p><strong>P2P：集中式目录</strong><br>最初的“Napster”设计</p>
<ol>
<li>当对等方连接时，它告知中心服务器：</li>
</ol>
<ul>
<li>IP地址</li>
<li>内容</li>
</ul>
<ol start="2">
<li>Alice查询 “双截棍.MP3”</li>
<li>Alice从Bob处请求文件</li>
</ol>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291107182.png" alt="image-20221029110754130" style="zoom:50%;" />

<blockquote>
<p>存在的问题：文件传输是分散的，而定位内容则是高度集中的</p>
</blockquote>
<ul>
<li>单点故障</li>
<li>性能瓶颈</li>
<li>侵犯版权</li>
</ul>
<p><strong>查询洪泛：Gnutella</strong></p>
<ul>
<li>全分布式<ul>
<li>没有中心服务器</li>
</ul>
</li>
<li>开放文件共享协议</li>
<li>许多Gnutella客户端实现了Gnutella协议<ul>
<li>类似HTTP有许多的浏览器</li>
</ul>
</li>
</ul>
<p>覆盖网络：图</p>
<ul>
<li>如果X和Y之间有一个TCP连接，则二者之间存在一条边</li>
<li>所有活动的对等方和边就是覆盖网络</li>
<li>边并不是物理链路</li>
<li>给定一个对等方，通常所连接的节点少于10个</li>
</ul>
<p><strong>Gnutella：协议</strong></p>
<ul>
<li>在已有的TCP连接上发送查询报文</li>
<li>对等方转发查询报文</li>
<li>以反方向返回查询命中报文</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291114139.png" alt="image-20221029111411086" style="zoom:50%;" />

<p>可扩展性：限制范围的洪泛查询</p>
<p><strong>Gnutella：对等方加入</strong></p>
<p>   1.对等方X必须首先发现某些已经在覆盖网络中的其他对等方：使用可用对等方列表</p>
<ul>
<li>自己维持一张对等方列表（经常开机的对等方的IP）联系维持列表的Gnutella站点</li>
</ul>
<ol start="2">
<li>X接着试图与该列表上的对等方建立TCP连接，直到与某个对等方Y建立连接</li>
<li>X向Y发送一个Ping报文，Y转发该Ping报文</li>
<li>所有收到Ping报文的对等方以Pong报文响应IP地址、共享文件的数量及总字节数</li>
<li>X收到许多Pong报文，然后它能建立其他TCP连接</li>
</ol>
<p><strong>利用不匀称性：KaZaA</strong></p>
<ul>
<li>每个对等方要么是一个组长，要么隶属于一个组长<ul>
<li>对等方与其组长之间有TCP连接</li>
<li>组长对之间有TCP连接</li>
</ul>
</li>
<li>组长跟踪其所有的孩子的内容</li>
<li>组长与其他组长联系<ul>
<li>转发查询到其他组长</li>
<li>获得其他组长的数据拷贝</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291134187.png" alt="image-20221029113407144" style="zoom:50%;" />

<p><strong>KaZaA：查询</strong></p>
<ul>
<li>每个文件有一个散列标识码和一个描述符</li>
<li>客户端向其组长发送关键字查询</li>
<li>组长用匹配进行响应：<ul>
<li>对每个匹配：元数据、散列标识码和IP地址</li>
</ul>
</li>
<li>如果组长将查询转发给其他组长，其他组长也可以匹配进行响应</li>
<li>客户端选择要下载的文件<ul>
<li>向拥有文件的对等方发送一个带散列标识码的HTTP请求</li>
</ul>
</li>
</ul>
<p><strong>Kazaa小技巧</strong></p>
<ul>
<li>请求排队<ul>
<li>限制并行上载的数量</li>
<li>确保每个被传输的文件从上载节点接收一定量的带宽</li>
</ul>
</li>
<li>激励优先权<ul>
<li>鼓励用户上载文件</li>
<li>加强系统的扩展性</li>
</ul>
</li>
<li>并行下载<ul>
<li>从多个对等方下载同一个文件的不同部分<ul>
<li>HTTP的字节范围首部</li>
<li>更快地检索</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Distributed Hash Table (DHT)</p>
</blockquote>
<ul>
<li>哈希表</li>
<li>DHT方案</li>
<li>环形DHT以及覆盖网络</li>
<li>Peer波</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p><strong>存储视频的流化服务</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291556188.png" alt="image-20221029155627137" style="zoom:50%;" />

<p><strong>多媒体流化服务：DASH</strong></p>
<ul>
<li><p>DASH: Dynamic, Adaptive Streaming over HTTP</p>
</li>
<li><p>服务器:</p>
<ul>
<li>将视频文件分割成多个块</li>
<li>每个块独立存储，编码于不同码率（8-10种）</li>
<li>告示文件（manifest file）: 提供不同块的URL</li>
</ul>
</li>
<li><p>客户端:</p>
<ul>
<li>先获取告示文件</li>
<li>周期性地测量服务器到客户端的带宽</li>
<li>查询告示文件,在一个时刻请求一个块，HTTP头部指定字节范围<ul>
<li>如果带宽足够，选择最大码率的视频块</li>
<li>会话中的不同时刻，可以切换请求不同的编码块 (取决于当时的可用带宽)</li>
</ul>
</li>
</ul>
</li>
<li><p>“智能”客户端: 客户端自适应决定</p>
<ul>
<li>什么时候去请求块 (不至于缓存挨饿，或者溢出)</li>
<li>请求什么编码速率的视频块 (当带宽够用时，请求高质量的视频块)</li>
<li>哪里去请求块 (可以向离自己近的服务器发送URL，或者向高可用带宽的服务器请求)</li>
</ul>
</li>
</ul>
<p><strong>Content Distribution Networks</strong></p>
<blockquote>
<p>服务器如何通过网络向上百万用户同时流化视频内容?</p>
</blockquote>
<p>1.单个的、大的超级服务中心“mega-server”</p>
<ul>
<li>服务器到客户端路径上跳数较多，瓶颈链路的带宽小导致停顿</li>
<li>“二八规律”决定了网络同时充斥着同一个视频的多个拷贝，效率低（付费高、带宽浪费、效果差）</li>
<li>单点故障点，性能瓶颈</li>
<li>周边网络的拥塞</li>
</ul>
<p>评述：相当简单，但是这个方法不可扩展</p>
<p>2.通过CDN，全网部署缓存节点，存储服务内容，就近为用户提供服务，提高用户体验</p>
<ul>
<li><p>enter deep: 将CDN服务器深入到许多接入网</p>
<ul>
<li>更接近用户，数量多，离用户近，管理困难</li>
<li>Akamai, 1700个位置</li>
</ul>
</li>
<li><p>bring home: 部署在少数(10个左右)关键位置，如将服务器簇安装于POP附近（离若干1stISP POP较近）</p>
<ul>
<li>采用租用线路将服务器簇连接起来</li>
<li>Limelight</li>
</ul>
</li>
<li><p>CDN: 在CDN节点中存储内容的多个拷贝<br>• e.g. Netflix stores copies of MadMen</p>
</li>
<li><p>用户从CDN中请求内容<br>• 重定向到最近的拷贝，请求内容<br>• 如果网络路径拥塞，可能选择不同的拷贝</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291608197.png" alt="image-20221029160806137" style="zoom:67%;" />

<p>OTT 挑战: 在拥塞的互联网上复制内容</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291609698.png" alt="image-20221029160951642" style="zoom: 50%;" />

<ul>
<li>从哪个CDN节点中获取内容？–最近的</li>
<li>用户在网络拥塞时的行为？</li>
<li>在哪些CDN节点中存储什么内容？</li>
</ul>
<p>案例   1.<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291720097.png" alt="image-20221029172037028" style="zoom:50%;" /></p>
<p>案例   2.<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291721404.png" alt="image-20221029172146337" style="zoom: 50%;" /></p>
<h3 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h3><p><strong>Socket编程</strong></p>
<p>应用进程使用传输层提供的服务才能够交换报文，实现应用协议，实现应用</p>
<ul>
<li>TCP&#x2F;IP：应用进程使用Socket API访问传输服务</li>
<li>地点：界面上的SAP(Socket） 方式：Socket API</li>
<li>目标: 学习如何构建能借助sockets进行通信的C&#x2F;S应用程序</li>
<li>socket: 分布式应用进程之间的门，传输层协议提供的端到端服务接口</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291729027.png" alt="image-20221029172912971" style="zoom:50%;" />

<p>2种传输层服务的socket类型:</p>
<ul>
<li>TCP: 可靠的、字节流的服务</li>
<li>UDP: 不可靠（数据UDP数据报）服务</li>
</ul>
<h4 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h4><p>套接字：应用进程与端到端传输协议（TCP或UDP）之间的门户<br>TCP服务：从一个进程向另一个进程可靠地传输字节流</p>
<p>服务器首先运行，等待连接建立</p>
<p>1：服务器进程必须先处于运行状态</p>
<ul>
<li>创建欢迎socket</li>
<li>和本地端口捆绑</li>
<li>在欢迎socket上阻塞式等待接收用户的连接</li>
</ul>
<p>客户端主动和服务器建立连接：</p>
<p>2：创建客户端本地套接字（隐式捆绑到本地port）</p>
<ul>
<li>指定服务器进程的IP地址和端口号，与服务器进程连接</li>
</ul>
<p>3 ：当与客户端连接请求到来时</p>
<ul>
<li>服务器接受来自用户端的请求，解除阻塞式等待，返回一个新的socket（与欢迎socket不一样），与客户端通信<ul>
<li>允许服务器与多个客户端通信</li>
<li>使用源IP和源端口来区分不同的客户端</li>
</ul>
</li>
</ul>
<p>4：连接API调用有效时，客户端P与服务器建立了TCP连接</p>
<p>从应用程序的角度<br>TCP在客户端和服务器进程之间提供了可靠的、字节流（管道）服务</p>
<p>C&#x2F;S模式的应用样例:</p>
<ol>
<li>客户端从标准输入装置读取一行字符，发送给服务器</li>
<li>服务器从socket读取字符</li>
<li>服务器将字符转换成大写，然后返回给客户端</li>
<li>客户端从socket中读取一行字符，然后打印出来</li>
</ol>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210291741987.png" alt="image-20221029174116934" style="zoom: 50%;" />

<p><strong>TCP Socket交互</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210292017493.png" alt="image-20221029201725425" style="zoom:50%;" />

<h4 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h4><p>UDP: 在客户端和服务器之间没有连接</p>
<p>• 没有握手<br>• 发送端在每一个报文中明确地指定目标的IP地址和端口号<br>• 服务器必须从收到的分组中提取出发送端的IP地址和端口号</p>
<p>UDP: 传送的数据可能乱序，也可能丢失</p>
<p>进程视角看UDP服务<br>UDP 为客户端和服务器提供不可靠的字节组的传送服务</p>
<p><strong>UDP Socket交互</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210292018020.png" alt="image-20221029201810960" style="zoom:50%;" />

<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="传输服务和协议"><a href="#传输服务和协议" class="headerlink" title="传输服务和协议"></a>传输服务和协议</h3><ul>
<li>为运行在不同主机上的应用进程提供逻辑通信</li>
<li>传输协议运行在端系统<ul>
<li>发送方：将应用层的报文分成报文段，然后传递给网络层</li>
<li>接收方：将报文段重组成报文，然后传递给应用层</li>
</ul>
</li>
<li>有多个传输层协议可供应用选择<ul>
<li>Internet: TCP和UDP</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210310937690.png" alt="image-20221031093703610" style="zoom:50%;" />

<p><strong>传输层 vs. 网络层</strong></p>
<ul>
<li>网络层服务：主机之间的逻辑通信</li>
<li>传输层服务：进程间的逻辑通信</li>
<li>依赖于网络层的服务<ul>
<li>延时、带宽</li>
</ul>
</li>
<li>并对网络层的服务进行增强<ul>
<li>数据丢失、顺序混乱、加密</li>
</ul>
</li>
</ul>
<p>有些服务是可以加强的：不可靠 -&gt; 可靠；安全 但有些服务是不可以被加强的：带宽，延迟</p>
<p><strong>Internet传输层协议</strong></p>
<ul>
<li>可靠的、保序的传输： TCP <ul>
<li>多路复用、解复用</li>
<li>拥塞控制</li>
<li>流量控制</li>
<li>建立连接</li>
</ul>
</li>
<li>不可靠、不保序的传输：UDP <ul>
<li>多路复用、解复用</li>
<li>没有为尽力而为的IP服务添加更多的其它额外服务</li>
</ul>
</li>
<li>都不提供的服务： <ul>
<li>延时保证</li>
<li>带宽保证</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210310947300.png" alt="image-20221031094738240" style="zoom:50%;" />

<h3 id="多路复用-x2F-解复用"><a href="#多路复用-x2F-解复用" class="headerlink" title="多路复用&#x2F;解复用"></a>多路复用&#x2F;解复用</h3><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210310950989.png" alt="image-20221031095058919" style="zoom:50%;" />

<p><strong>多路解复用工作原理</strong></p>
<ul>
<li>解复用作用：TCP或者UDP实体采用哪些信息，将报文段的数据部分交给正确的socket，而交给正确的进程</li>
<li>主机收到IP数据报<ul>
<li>每个数据报有源IP地址和目标地址</li>
<li>每个数据报承载一个传输层报文段</li>
<li>每个报文段有一个源端口号和目标端口号(特定应用有著名的端口号)</li>
</ul>
</li>
<li>主机联合使用IP地址和端口号将报文段发送给合适的套接字</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210310955625.png" alt="image-20221031095552570" style="zoom:50%;" />

<p><strong>无连接(UDP)多路解复用</strong></p>
<ul>
<li><p>创建套接字：<br>服务器端：<br>serverSocket&#x3D;socket(PF_INET, SOCK_DGRAM,0);<br>bind(serverSocket, &amp;sad, sizeof(sad));<br>serverSocket和Sad指定的端口号捆绑</p>
<p>客户端：<br>ClientSocket&#x3D;socket(PF_INET, SOCK_DGRAM,0);<br>没有Bind,ClientSocket和OS为之分配的某个端口号捆绑（客户端使用什么端口号无所谓，客户端主动找服务器）</p>
</li>
<li><p>在接收端，UDP套接字用二元组标识 (目标IP地址、目标端口号)</p>
</li>
<li><p>当主机收到UDP报文段：</p>
<ul>
<li>检查报文段的目标端口号</li>
<li>用该端口号将报文段定位给套接字</li>
</ul>
</li>
<li><p>如果两个不同源IP地址&#x2F;源端口号的数据报，但是有相同的目标IP地址和端口号，则被定位到相同的套接字</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311021870.png" alt="image-20221031102117822" style="zoom:50%;" />

<p><strong>无连接的多路解复用</strong></p>
<ul>
<li>当主机接收到UDP段时：<ul>
<li>检查UDP段中的目标端口号</li>
<li>将UDP段交给具备那个端口号的套接字</li>
</ul>
</li>
</ul>
<p>→ 具备相同目标IP地址和目标端口号，即使是源IP地址 或&#x2F;且源端口号的IP数据报，将会被传到相同的目标UDP套接字上</p>
<p><strong>无连接多路复用:例子</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311026377.png" alt="image-20221031102603306" style="zoom: 33%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311026146.png" alt="image-20221031102648079" style="zoom: 33%;" />

<p><strong>面向连接(TCP)的多路复用</strong></p>
<ul>
<li><p>TCP套接字:四元组本地标识：</p>
<ul>
<li>源IP地址</li>
<li>源端口号</li>
<li>目的IP地址</li>
<li>目的端口号</li>
</ul>
</li>
<li><p>解复用：接收主机用这四个值来将数据报定位到合适的套接字</p>
</li>
<li><p>服务器能够在一个TCP端口上同时支持多个TCP套接字：</p>
<ul>
<li>每个套接字由其四元组标识（有不同的源IP和源PORT）</li>
</ul>
</li>
<li><p>Web服务器对每个连接客户端有不同的套接字</p>
<ul>
<li>非持久对每个请求有不同的套接字</li>
</ul>
</li>
</ul>
<p>例子</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311234702.png" alt="image-20221031123410630" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311235443.png" alt="image-20221031123514382" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311236021.png" alt="image-20221031123613959" style="zoom:50%;" />

<p><strong>面向连接的多路复用：多线程Web Server</strong></p>
<ul>
<li>一个进程下面可能有多个线程：由多个线程分别为客户提供服务</li>
<li>在这个场景下，还是根据4元组决定将报文段内容同一个进程下的不同线程</li>
<li>解复用到不同线</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202210311237135.png" alt="image-20221031123759084" style="zoom:50%;" />

<h3 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h3><p><strong>UDP: User Datagram Protocol</strong></p>
<ul>
<li><p>“no frills,” “bare bones”Internet传输协议</p>
</li>
<li><p>“尽力而为”的服务，报文段可能</p>
<ul>
<li>丢失</li>
<li>送到应用进程的报文段乱序</li>
</ul>
</li>
<li><p>无连接：</p>
<ul>
<li>UDP发送端和接收端之间没有握手</li>
<li>每个UDP报文段都被独立地处理</li>
</ul>
</li>
<li><p>UDP 被用于:</p>
<ul>
<li>流媒体（丢失不敏感，速率敏感、应用可控制传输速率</li>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
<li><p>在UDP上可行可靠传输: </p>
<ul>
<li>在应用层增加可靠性</li>
<li>应用特定的差错恢复</li>
</ul>
</li>
</ul>
<p><strong>UDP：用户数据报协议</strong></p>
<p>为什么要有UDP?</p>
<ul>
<li>不建立连接 （会增加延时）</li>
<li>简单：在发送端和接收端没有连接状态</li>
<li>报文段的头部很小(开销小)</li>
<li>无拥塞控制和流量控制：<br>UDP可以尽可能快的发送报文段<ul>
<li>应用-&gt;传输的速率&#x3D; 主机-&gt;网络的速率</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211020921235.png" alt="image-20221102092138167" style="zoom:50%;" />

<p><strong>UDP校验和</strong><br>目标： 检测在被传输报文段中的差错 (如比特反转)</p>
<p>发送方：</p>
<ul>
<li>将报文段的内容视为16比特的整数</li>
<li>校验和：报文段的加法和 （1的补运算）</li>
<li>发送方将校验和放在UDP的校验和字段</li>
</ul>
<p>接收方：</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查计算出的校验和与校验和字段的内容是否相等：<ul>
<li>不相等––检测到差错</li>
<li>相等––没有检测到差错，但也许还是有差错<ul>
<li>残存错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Internet校验和的例子</strong></p>
<ul>
<li>注意：当数字相加时，在最高位的进位要回卷，再加到结果上<br>例子：两个16比特的整数相加</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211020924702.png" alt="image-20221102092426653" style="zoom:50%;" />

<ul>
<li>目标端：校验范围+校验和&#x3D;1111111111111111 通过校验<ul>
<li>否则没有通过校验<br>注：求和时，必须将进位回卷到结果上</li>
</ul>
</li>
</ul>
<h3 id="可靠数据传输（rdt）的原理"><a href="#可靠数据传输（rdt）的原理" class="headerlink" title="可靠数据传输（rdt）的原理"></a>可靠数据传输（rdt）的原理</h3><ul>
<li>rdt在应用层、传输层和数据链路层都很重要</li>
<li>是网络Top 10问题之一</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211020928265.png" alt="image-20221102092819204" style="zoom:50%;" />

<ul>
<li>信道的不可靠特点决定了可靠数据传输协议（ rdt ）的复杂性</li>
</ul>
<p><strong>可靠数据传输：问题描述</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211020928381.png" alt="image-20221102092857315" style="zoom:50%;" />

<p>我们将：</p>
<ul>
<li>渐增式地开发可靠数据传输协议（ rdt ）的发送方和接收方</li>
<li>只考虑单向数据传输<ul>
<li>但控制信息是双向流动的！</li>
</ul>
</li>
<li>双向的数据传输问题实际上是2个单向数据传输问题的综合</li>
<li>使用有限状态机 (FSM) 来描述发送方和接收方</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021633795.png" alt="image-20221102163330725" style="zoom: 50%;" />

<p><strong>Rdt1.0： 在可靠信道上的可靠数据传输</strong></p>
<ul>
<li>下层的信道是完全可靠的<ul>
<li>没有比特出错</li>
<li>没有分组丢失</li>
</ul>
</li>
<li>发送方和接收方的FSM<ul>
<li>发送方将数据发送到下层信道</li>
<li>接收方从下层信道接收数据</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021636939.png" alt="image-20221102163626882" style="zoom:50%;" />

<p><strong>Rdt2.0：具有比特差错的信道</strong></p>
<ul>
<li>下层信道可能会出错：将分组中的比特翻转<ul>
<li>用校验和来检测比特差错</li>
</ul>
</li>
<li>问题：怎样从差错中恢复：<ul>
<li>确认(ACK)：接收方显式地告诉发送方分组已被正确接收</li>
<li>否定确认( NAK): 接收方显式地告诉发送方分组发生了差错<ul>
<li>发送方收到NAK后，发送方重传分组</li>
</ul>
</li>
</ul>
</li>
<li>rdt2.0中的新机制：采用差错控制编码进行差错检测<ul>
<li>发送方差错控制编码、缓存</li>
<li>接收方使用编码检错</li>
<li>接收方的反馈：控制报文（ACK，NAK）：接收方-&gt;发送方</li>
<li>发送方收到反馈相应的动作</li>
</ul>
</li>
</ul>
<p><strong>rdt2.0：FSM描述</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021643144.png" alt="image-20221102164349084" style="zoom: 50%;" />

<p><strong>rdt2.0：没有差错时的操作</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021644882.png" alt="image-20221102164436821" style="zoom:50%;" />

<p><strong>rdt2.0：有差错时</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021646390.png" alt="image-20221102164643326" style="zoom:50%;" />

<p><strong>rdt2.0的致命缺陷！-&gt; rdt2.1</strong></p>
<p>如果ACK&#x2F;NAK出错？</p>
<ul>
<li>发送方不知道接收方发生了什么事情！</li>
<li>发送方如何做？<ul>
<li>重传？可能重复</li>
<li>不重传？可能死锁(或出错)</li>
</ul>
</li>
<li>需要引入新的机制<ul>
<li>序号</li>
</ul>
</li>
</ul>
<p>处理重复：</p>
<ul>
<li>发送方在每个分组中加入序号</li>
<li>如果ACK&#x2F;NAK出错，发送方重传当前分组</li>
<li>接收方丢弃（不发给上层）重复分组</li>
</ul>
<blockquote>
<p>发送方发送一个分组，然后等待接收方的应答</p>
</blockquote>
<p><strong>rdt2.1：发送方处理出错的ACK&#x2F;NAK</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021650282.png" alt="image-20221102165023222" style="zoom:50%;" />

<p><strong>rdt2.1：接收方处理出错的ACK&#x2F;NAK</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021652810.png" alt="image-20221102165230749" style="zoom:50%;" />

<p><strong>rdt2.1：讨论</strong></p>
<p>发送方：</p>
<ul>
<li>在分组中加入序列号</li>
<li>两个序列号（0，1）就足够了<ul>
<li>一次只发送一个未经确认的分组</li>
</ul>
</li>
<li>必须检测ACK&#x2F;NAK是否出错（需要EDC ）</li>
<li>状态数变成了两倍<ul>
<li>必须记住当前分组的序列号为0还是1</li>
</ul>
</li>
</ul>
<p>接收方：</p>
<ul>
<li>必须检测接收到的分组是否是重复的<ul>
<li>状态会指示希望接收到的分组的序号为0还是1</li>
</ul>
</li>
<li>注意：接收方并不知道发送方是否正确收到了其ACK&#x2F;NAK<ul>
<li>没有安排确认的确认</li>
<li>具体解释见下页</li>
</ul>
</li>
</ul>
<p><strong>rdt2.1的运行</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021656390.png" alt="image-20221102165625325" style="zoom:50%;" />

<p>接收方不知道它最后发送的ACK&#x2F;NAK是否被正确地收到</p>
<ul>
<li>发送方不对收到的ack&#x2F;nak给确认，没有所谓的确认的确认;</li>
<li>接收方发送ack，如果后面接收方收到的是：<ul>
<li>老分组p0？则ack 错误</li>
<li>下一个分组？P1，ack正确</li>
</ul>
</li>
</ul>
<p><strong>rdt2.2：无NAK的协议</strong></p>
<ul>
<li>功能同rdt2.1，但只使用ACK(ack 要编号）</li>
<li>接收方对最后正确接收的分组发ACK，以替代NAK<ul>
<li>接收方必须显式地包含被正确接收分组的序号</li>
</ul>
</li>
<li>当收到重复的ACK（如：再次收到ack0）时，发送方与收到NAK采取相同的动作：重传当前分组</li>
<li>为后面的一次发送多个数据单位做一个准备<ul>
<li>一次能够发送多个</li>
<li>每一个的应答都有：ACK，NACK；麻烦</li>
<li>使用对前一个数据单位的ACK，代替本数据单位的nak</li>
<li>确认信息减少一半，协议处理简单</li>
</ul>
</li>
</ul>
<p><strong>NAK free</strong><br><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021722635.png" alt="image-20221102172247583" style="zoom: 50%;" /></p>
<p><strong>rat2.2的运行</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021723801.png" alt="image-20221102172335742" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021724803.png" alt="image-20221102172401750" style="zoom:50%;" />

<p><strong>rdt2.2：发送方和接收方片断</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021725004.png" alt="image-20221102172508937" style="zoom:50%;" />

<p><strong>rdt3.0：具有比特差错和分组丢失的信道</strong></p>
<p>新的假设：下层信道可能会丢失分组（数据或ACK）</p>
<ul>
<li>会死锁</li>
<li>机制还不够处理这种状况：<ul>
<li>检验和</li>
<li>序列</li>
<li>ACK</li>
<li>重传</li>
</ul>
</li>
</ul>
<p>方法：发送方等待ACK一段合理的时间</p>
<ul>
<li>发送端超时重传：如果到时没有收到ACK-&gt;重传</li>
<li>问题：如果分组（或ACK ）只是被延迟了：<ul>
<li>重传将会导致数据重复，但利用序列号已经可以处理这个问题</li>
<li>接收方必须指明被正确接收的序列号</li>
</ul>
</li>
<li>需要一个倒计数定时器</li>
</ul>
<p><strong>rdt3.0 发送方</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021837972.png" alt="image-20221102183736909" style="zoom:50%;" />

<p><strong>rdt3.0的运行</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021838486.png" alt="image-20221102183813423" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021839516.png" alt="image-20221102183932446" style="zoom:50%;" />

<ul>
<li>过早超时（延迟的ACK）也能够正常工作；但是效率较低，一半的分组和确认是重复的；</li>
<li>设置一个合理的超时时间也是比较重要的</li>
</ul>
<p><strong>rdt3.0的性能</strong></p>
<ul>
<li>rdt3.0可以工作，但链路容量比较大的情况下，性能很差<ul>
<li>链路容量比较大，一次发一个PDU 的不能够充分利用链路的传输能力</li>
</ul>
</li>
<li>例：1 Gbps的链路，15 ms端-端传播延时，分组大小为1kB</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021845822.png" alt="image-20221102184532769" style="zoom:50%;" />

<ul>
<li>U sender：利用率 – 忙于发送的时间比例</li>
<li>每30ms发送1KB的分组 -&gt; 270kbps&#x3D;33.75kB&#x2F;s 的吞吐量（在1 Gbps 链路上）</li>
<li>瓶颈在于：网络协议限制了物理资源</li>
</ul>
<p><strong>rdt3.0：停-等操作</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021853688.png" alt="image-20221102185328621"></p>
<p><strong>流水线：提高链路利用率</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021854892.png" alt="image-20221102185401828"></p>
<ul>
<li>增加n,能提高链路利用率</li>
<li>但当达到某个n,其u&#x3D;100%时,无法再通过增加n，提高利用率</li>
<li>瓶颈转移了-&gt;链路带宽</li>
</ul>
<p><strong>流水线协议</strong><br>流水线：允许发送方在未得到对方确认的情况下一次发送多个分组</p>
<ul>
<li>必须增加序号的范围:用多个bit表示分组的序号</li>
<li>在发送方&#x2F;接收方要有缓冲区<ul>
<li>发送方缓冲：未得到确认，可能需要重传;</li>
<li>接收方缓存：上层用户取用数据的速率≠接收到的数据速率；接收到的数据可能乱序，排序交付（可靠）</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211021855594.png" alt="image-20221102185534537" style="zoom:50%;" />

<ul>
<li>两种通用的流水线协议：回退</li>
</ul>
<p><strong>通用：滑动窗口(slide window)协议</strong></p>
<ul>
<li>发送缓冲区<ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送</li>
<li>功能：用于存放已发送，但是没有得到确认的分组</li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li>发送缓冲区的大小：一次最多可以发送多少个未经确认的分组<ul>
<li>停止等待协议&#x3D;1</li>
<li>流水线协议&gt;1，合理的值，不能很大，链路利用率不能够超100%</li>
</ul>
</li>
<li>发送缓冲区中的分组<ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去;</li>
<li>已经发送出去的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
</ul>
<p><strong>发送窗口滑动过程-相对表示方法</strong></p>
<ul>
<li>采用相对移动方式表示，分组不动</li>
<li>可缓冲范围移动，代表一段可以发送的权力</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022153563.png" alt="image-20221102215314499" style="zoom:50%;" />

<p><strong>滑动窗口(slide window)协议</strong></p>
<ul>
<li>发送窗口：发送缓冲区内容的一个范围<ul>
<li>那些已发送但是未经确认分组的序号构成的空间</li>
</ul>
</li>
<li>发送窗口的最大值&lt;&#x3D;发送缓冲区的值</li>
<li>一开始：没有发送任何一个分组<ul>
<li>后沿&#x3D;前沿</li>
<li>之间为发送窗口的尺寸&#x3D;0</li>
</ul>
</li>
<li>每发送一个分组，前沿前移一个单位</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022154459.png" alt="image-20221102215432413" style="zoom:50%;" />

<p><strong>发送窗口的移动-&gt;前沿移动</strong></p>
<ul>
<li>发送窗口前沿移动的极限：不能够超过发送缓冲区</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022155232.png" alt="image-20221102215529182" style="zoom:50%;" />

<ul>
<li>发送窗口前沿移动的极限：不能够超过发送缓冲区</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022156198.png" alt="image-20221102215602152" style="zoom: 50%;" />

<p><strong>发送窗口的移动-&gt;后沿移动</strong></p>
<ul>
<li>发送窗口后沿移动<ul>
<li>条件：收到老分组的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动的极限：不能够超过前沿</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022157232.png" alt="image-20221102215715182" style="zoom:50%;" />

<ul>
<li>发送窗口后沿移动<ul>
<li>条件：收到老分组(后沿)的确认</li>
<li>结果：发送缓冲区罩住新的分组，来了分组可以发送</li>
<li>移动的极限：不能超过前沿</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022158214.png" alt="image-20221102215819158" style="zoom:50%;" />

<ul>
<li>滑动窗口技术<ul>
<li>发送窗口 (sending window)</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022218133.png" alt="image-20221102221827058"></p>
<p><strong>滑动窗口(slide window)协议-接收窗口</strong></p>
<ul>
<li>接收窗口 (receiving window)&#x3D;接收缓冲区</li>
<li>接收窗口用于控制哪些分组可以接收；<ul>
<li>只有收到的分组序号落入接收窗口内才允许接收</li>
<li>若序号在接收窗口之外，则丢弃；</li>
</ul>
</li>
<li>接收窗口尺寸Wr&#x3D;1，则只能顺序接收；</li>
<li>接收窗口尺寸Wr&gt;1 ，则可以乱序接收<ul>
<li>但提交给上层的分组，要按序</li>
</ul>
</li>
<li>例子：Wr＝1，在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022221492.png" alt="image-20221102222119437" style="zoom:50%;" />

<ul>
<li>接收窗口的滑动和发送确认<ul>
<li>滑动：<ul>
<li>低序号的分组到来，接收窗口移动</li>
<li>高序号分组乱序到，缓存但不交付（因为要实现rdt，不允许失序），不滑动</li>
</ul>
</li>
<li>发送确认：<ul>
<li>接收窗口尺寸&#x3D;1：发送连续收到的最大的分组确认（累计确认）</li>
<li>接收窗口尺寸&gt;1：到分组，发送那个分组的确认（非累计确认）</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022225870.png" alt="image-20221102222555812" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022226669.png" alt="image-20221102222657613" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022227196.png" alt="image-20221102222736124" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022228899.png" alt="image-20221102222851814" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211022229763.png" alt="image-20221102222935693" style="zoom:50%;" />

 

<p><strong>GBN协议和SR协议的异同</strong></p>
<ul>
<li>相同之处<ul>
<li>发送窗口&gt;1</li>
<li>一次能够可发送多个未经确认的分组</li>
</ul>
</li>
<li>不同之处<ul>
<li>GBN :接收窗口尺寸&#x3D;1<ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如：0,1,2,3,4,1未成功，234都发送出去了，要返回1再发送；GB1</li>
</ul>
</li>
</ul>
</li>
<li>SR: 接收窗口尺寸&gt;1<ul>
<li>接收端：可以乱序接收</li>
<li>发送端：发送0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发，选择性发送1</li>
</ul>
</li>
</ul>
<p><strong>流水线协议：总结</strong></p>
<p>Go-back-N:</p>
<ul>
<li>发送端最多在流水线中有N个未确认的分组</li>
<li>接收端只是发送累计型确认cumulative ack<ul>
<li>接收端如果发现gap，不确认新到来的分组</li>
</ul>
</li>
<li>发送端拥有对最老的未确认分组的定时器<ul>
<li>只需设置一个定时器</li>
<li>当定时器到时时，重传所有未确认分组</li>
</ul>
</li>
</ul>
<p><strong>GBN：发送方扩展的FSM</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031101379.png" alt="image-20221103110139283" style="zoom:50%;" />

<p><strong>GBN：接收方扩展的FSM</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031103693.png" alt="image-20221103110354638" style="zoom:50%;" />
+ 只发送ACK：对顺序接收的最高序号的分组
  + 可能会产生重复的ACK
  + 只需记住expectedseqnum；接收窗口=1
    + 只一个变量就可表示接收窗口
+ 对乱序的分组：
  + 丢弃（不缓存） -> 在接收方不被缓存！
  + 对顺序接收的最高序号的分组进行确认-累计确认

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031112757.png" alt="image-20221103111216709" style="zoom:50%;" />

<p><strong>运行中的GBN</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031113486.png" alt="image-20221103111319392" style="zoom: 50%;" />

<p><strong>选择重传SR</strong></p>
<ul>
<li>接收方对每个正确接收的分组，分别发送ACKn（非累积确认）<ul>
<li>接收窗口&gt;1<ul>
<li>可以缓存乱序的分组</li>
</ul>
</li>
<li>终将分组按顺序交付给上层</li>
</ul>
</li>
<li>发送方只对那些没有收到ACK的分组进行重发-选择性重发<ul>
<li>发送方为每个未确认的分组设定一个定时器</li>
</ul>
</li>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
<p><strong>选择重传</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031116042.png" alt="image-20221103111658976" style="zoom:50%;" />

<p><strong>选择重传SR的运行</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031117198.png" alt="image-20221103111749132" style="zoom:50%;" />

<p><strong>对比GBN和SR</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031118708.png" alt="image-20221103111826652" style="zoom:50%;" />
+ 适用范围
  + 出错率低：比较适合GBN，出错非常罕见，没有必要用复杂的SR，为罕见的事件做日常的准备和复杂处理
+ 链路容量大（延迟大、带宽大）：比较适合SR而不是GBN，一点出错代价太大

<p><strong>窗口的最大尺寸</strong></p>
<ul>
<li>GBN: 2^n-1</li>
<li>SR:2^(n-1)<br>例如：n&#x3D;2; 序列号：0,1,2,3<ul>
<li>GBN&#x3D;3</li>
<li>SR&#x3D;2 <img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031122834.png" alt="image-20221103112228760" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<p>SR的例子：</p>
<ul>
<li>接收方看不到二者的区别！</li>
<li>将重复数据误认为新数据 (a)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031123646.png" alt="image-20221103112305589" style="zoom:50%;" />

<h3 id="面向连接的传输：-TCP"><a href="#面向连接的传输：-TCP" class="headerlink" title="面向连接的传输： TCP"></a>面向连接的传输： TCP</h3><p><strong>TCP：概述</strong></p>
<ul>
<li>点对点：<ul>
<li>一个发送方，一个接收方</li>
</ul>
</li>
<li>可靠的、按顺序的字节流：<ul>
<li>没有报文边界</li>
</ul>
</li>
<li>管道化（流水线）：<ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li>发送和接收缓存</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031125622.png" alt="image-20221103112547571" style="zoom:50%;" />

<ul>
<li>全双工数据：<ul>
<li>在同一连接中数据流双向流动</li>
<li>MSS：最大报文段大小</li>
</ul>
</li>
<li>面向连接：<ul>
<li>在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量</li>
</ul>
</li>
<li>有流量控制：<ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<p><strong>TCP报文段结构</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031127913.png" alt="image-20221103112749842" style="zoom:50%;" />

<p><strong>TCP 序号, 确认号</strong></p>
<p>序号：</p>
<ul>
<li><p>报文段首字节的在字节流的编号<br>确认号:</p>
</li>
<li><p>期望从另一方收到的下一个字节的序号</p>
</li>
<li><p>累积确认</p>
</li>
</ul>
<p>Q:接收方如何处理乱序的报文段-没有规定</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031130498.png" alt="image-20221103113009442" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031130222.png" alt="image-20221103113053163" style="zoom:50%;" />

<p><strong>TCP往返延时（RTT）和超时</strong><br>Q： 怎样设置TCP超时？</p>
<ul>
<li>比RTT要长<ul>
<li>但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li>不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失反应太慢，消极</li>
</ul>
<p>Q：怎样估计RTT？</p>
<ul>
<li><p>SampleRTT：测量从报文段发出到收到确认的时间</p>
<ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li><p>SampleRTT会变化，因此估计的RTT应该比较平滑</p>
<ul>
<li>对几个最近的测量值求平均，而不是仅用当前的SampleRTT</li>
</ul>
</li>
<li><p>指数加权移动平均</p>
</li>
<li><p>过去样本的影响呈指数衰减</p>
</li>
<li><p>推荐值：α &#x3D; 0.125</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211031137200.png" alt="image-20221103113726141" style="zoom:50%;" />

<p>设置置超时</p>
<ul>
<li>EstimtedRTT + 安全边界时间<ul>
<li>EstimatedRTT变化大 (方差大) 较大的安全边界时间</li>
</ul>
</li>
<li>SampleRTT会偏离EstimatedRTT多远</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042151755.png" alt="image-20221104215119677" style="zoom:50%;" />

<p><strong>TCP：可靠数据传输</strong></p>
<ul>
<li><p>TCP在IP不可靠服务的基础上建立了rdt</p>
<ul>
<li>管道化的报文段<ul>
<li>GBN or SR</li>
</ul>
</li>
<li>累积确认（像GBN）</li>
<li>单个重传定时器（像GBN）</li>
<li>是否可以接受乱序的，没有规范</li>
</ul>
</li>
<li><p>通过以下事件触发重传</p>
<ul>
<li>超时（只重发那个最早的未确认段：SR）</li>
<li>重复的确认<ul>
<li>例子：收到了ACK50,之后又收到3个ACK50</li>
</ul>
</li>
</ul>
</li>
<li><p>首先考虑简化的TCP发送方：</p>
<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042158687.png" alt="image-20221104215850584" style="zoom:50%;" />

<p><strong>TCP发送方事件</strong></p>
<p>从应用层接收数据：</p>
<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号</li>
<li>如果还没有运行，启动定时器<ul>
<li>定时器与最早未确认的报文段关联</li>
<li>过期间隔：TimeOutInterval</li>
</ul>
</li>
</ul>
<p>超时：</p>
<ul>
<li>重传后沿最老的报文段</li>
<li>重新启动定时</li>
</ul>
<p>收到确认：</p>
<ul>
<li>如果是对尚未确认的报文段确认<ul>
<li>更新已被确认的报文序号</li>
<li>如果当前还有未被确认的报文段，重新启动定时器</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042218435.png" alt="image-20221104221826359" style="zoom: 50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042220153.png" alt="image-20221104222009049" style="zoom: 50%;" />

<p><strong>TCP:重传</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042220945.png" alt="image-20221104222054850" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042224698.png" alt="image-20221104222436621" style="zoom: 50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042225399.png" alt="image-20221104222518297" style="zoom:50%;" />

<p><strong>快速重传</strong></p>
<ul>
<li>超时周期往往太长：<ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li>通过重复的ACK来检测报文段丢失<ul>
<li>发送方通常连续发送大量报文段</li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042226060.png" alt="image-20221104222651998" style="zoom: 50%;" />

<ul>
<li>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段：<ul>
<li>快速重传：在定时器过时之前重发报文段</li>
<li>它假设跟在被确认的数据后面的数据丢失了<ul>
<li>第一个ACK是正常的</li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段<br>收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大段丢失了</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042228508.png" alt="image-20221104222826437" style="zoom:33%;" />

<p><strong>快速重传算法</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042228660.png" alt="image-20221104222856582" style="zoom:50%;" />

<p><strong>TCP 流量控制</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042230429.png" alt="image-20221104223000333" style="zoom:50%;" />

<ul>
<li>接收方在其向发送方的TCP段头部的rwnd字段“通告”其空闲buffer大小<ul>
<li>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节)</li>
<li>很多操作系统自动调整RcvBuffer</li>
</ul>
</li>
<li>发送方限制未确认(“in-flight”)字节的个数≤接收方发送过来的 rwnd 值</li>
<li>保证接收方不会被淹没</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042231423.png" alt="image-20221104223124358" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211042231282.png" alt="image-20221104223157199" style="zoom: 33%;" />

<p><strong>TCP连接管理</strong></p>
<p>在正式交换数据之前，发送方和接收方握手建立通信关系:</p>
<ul>
<li>同意建立连接（每一方都知道对方愿意建立连接）</li>
<li>同意连接参数</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051157248.png" alt="image-20221105115749166" style="zoom:50%;" />

<p><strong>同意建立连接</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051201640.png" alt="image-20221105120102569" style="zoom:50%;" />

<p>Q:在网络中，2次握手建立连接总是可行吗？</p>
<ul>
<li>变化的延迟（连接请求的段没有丢，但可能超时）</li>
<li>由于丢失造成的重传 (e.g. req_conn(x))</li>
<li>报文乱序</li>
<li>相互看不到对方</li>
</ul>
<p><strong>同意建立连接</strong><br>2次握手的失败场景：</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051202859.png" alt="image-20221105120239765" style="zoom: 33%;" />

<p><strong>TCP 3次握手</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051208663.png" alt="image-20221105120828580" style="zoom:50%;" />

<p><strong>3次握手解决：半连接和接收老数据问题</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051211619.png" alt="image-20221105121121523" style="zoom:50%;" />

<p><strong>TCP 3次握手: FSM</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051212495.png" alt="image-20221105121219414" style="zoom:50%;" />

<p><strong>TCP: 关闭连接</strong></p>
<ul>
<li>客户端，服务器分别关闭它自己这一侧的连接<ul>
<li>发送FIN bit &#x3D; 1的TCP段</li>
</ul>
</li>
<li>一旦接收到FIN，用ACK回应<ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发送</li>
</ul>
</li>
<li>可以处理同时的FIN交</li>
</ul>
<p><strong>TCP: 关闭连接</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051228725.png" alt="image-20221105122845642" style="zoom:50%;" />

<p><strong>经典例子：红军和白军</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051237946.png" alt="image-20221105123707847" style="zoom: 33%;" />

<h3 id="拥塞控制原理拥塞控制原理"><a href="#拥塞控制原理拥塞控制原理" class="headerlink" title="拥塞控制原理拥塞控制原理"></a>拥塞控制原理拥塞控制原理</h3><p><strong>拥塞:</strong></p>
<ul>
<li><p>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力”</p>
</li>
<li><p>与流量控制不同</p>
</li>
<li><p>拥塞的表现:</p>
<ul>
<li>分组丢失 (路由器缓冲区溢出)</li>
<li>分组经历比较长的延迟(在路由器的队列中排队)</li>
</ul>
</li>
<li><p>网络中前10位的问题!</p>
</li>
</ul>
<p><strong>拥塞的原因&#x2F;代价: 场景1</strong></p>
<ul>
<li>2个发送端，2个接收端</li>
<li>一个路由器，具备无限大的缓冲</li>
<li>输出链路带宽：R </li>
<li>没有重传</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051613230.png" alt="image-20221105161321155" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051614870.png" alt="image-20221105161409809" style="zoom:50%;" />

<p><strong>拥塞的原因&#x2F;代价: 场景2</strong></p>
<ul>
<li>一个路由器，有限的缓冲</li>
<li>分组丢失时，发送端重传<ul>
<li>应用层的输入&#x3D;应用层输出:λlin &#x3D; λout</li>
<li>传输层的输入包括重传: λin&gt;&#x3D;λin</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051617530.png" alt="image-20221105161744466" style="zoom:50%;" />

<p>理想化: 发送端有完美的信息<br>发送端知道什么时候路由器的缓冲是可用的<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051635545.png" alt="image-20221105163407611" style="zoom: 33%;" /></p>
<ul>
<li>只在缓冲可用时发送</li>
<li>不会丢失:λ’in&#x3D;λin</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051635753.png" alt="image-20221105163515689" style="zoom:50%;" />

<p>理想化: 掌握丢失信息分组可以丢失，在路由器由于缓冲器满而被丢弃</p>
<ul>
<li>如果知道分组丢失了，发送方重传分组</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051639605.png" alt="image-20221105163957545" style="zoom:50%;" />

<p>理想化: 掌握丢失信息分组可以丢失，在路由器由于缓冲器满而被丢弃<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051641941.png" alt="image-20221105164155891" style="zoom: 33%;" /></p>
<ul>
<li>如果发送端知道分组丢失了，发送方重传分组</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051643127.png" alt="image-20221105164316066" style="zoom:50%;" />

<p>现实情况: 重复</p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051648732.png" alt="image-20221105164808682" style="zoom:33%;" /></li>
<li>发送端最终超时，发送第2个拷贝，2个分组都被传出</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051648179.png" alt="image-20221105164832116" style="zoom:50%;" />

<p>现实情况: 重复</p>
<ul>
<li>分组可能丢失，由于缓冲器满而被丢弃</li>
<li>发送端最终超时，发送第2个拷贝，2个分组都传到<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051651101.png" alt="image-20221105165101048" style="zoom:33%;" /></li>
</ul>
<p>拥塞的“代价”:</p>
<ul>
<li>为了达到一个有效输出，网络需要做更多的工作（重传）</li>
<li>没有必要的重传，链路中包括了多个分组的拷贝<ul>
<li>是那些没有丢失，经历的时间比较长（拥塞状态）但是超时的分组</li>
<li>降低了的“goodput”</li>
</ul>
</li>
</ul>
<p><strong>拥塞的原因&#x2F;代价: 场景3</strong></p>
<ul>
<li>4个发送端</li>
<li>多重路径</li>
<li>超时&#x2F;重传</li>
</ul>
<p>Q:当λin - λ’in增加时，会发生什么?<br>A:当红色的λ’in增加时，所有到来的蓝色分组都在最上方的队列中丢弃了，蓝色吞吐-&gt;0</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051654402.png" alt="image-20221105165412338" style="zoom:50%;" />

<p>又一个拥塞的代价:  </p>
<ul>
<li>当分组丢失时，任何“关于这个分组的上游传输能力” 都被浪费了</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051655350.png" alt="image-20221105165508292" style="zoom:50%;" />

<p><strong>2种常用的拥塞控制方法:</strong></p>
<p>端到端拥塞控制:</p>
<ul>
<li>没有来自网络的显式反馈</li>
<li>端系统根据延迟和丢失事件推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
<p>网络辅助的拥塞控制:</p>
<ul>
<li>路由器提供给端系统以反馈信息</li>
<li>单个bit置位，显示有拥塞 (SNA, DECbit, TCP&#x2F;IP ECN, ATM)</li>
<li>显式提供发送端可以采用的速率</li>
</ul>
<p><strong>ATM ABR 拥塞控制</strong></p>
<p>ABR: available bit rate:</p>
<ul>
<li>“弹性服务” </li>
<li>如果发送端的路径“轻载”<ul>
<li>发送方使用可用带宽</li>
</ul>
</li>
<li>如果发送方的路径拥塞了<ul>
<li>发送方限制其发送的速度到一个最小保障速率上</li>
</ul>
</li>
</ul>
<p>RM (资源管理) 信元:</p>
<ul>
<li>由发送端发送,在数据信元中间隔插入</li>
<li>RM信元中的比特被交换机设置 (“网络辅助”) <ul>
<li>NI bit: no increase in rate (轻微拥塞)速率不要增加了</li>
<li>CI bit: congestion indication 拥塞指示</li>
</ul>
</li>
<li>发送端发送的RM 信元被接收端返回, 接收端不做任何改变</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051714633.png" alt="image-20221105171424574" style="zoom:50%;" />

<ul>
<li>在RM信元中的2个字节 ER (explicit rate)字段<ul>
<li>拥塞的交换机可能会降低信元中ER的值</li>
<li>发送端发送速度因此是最低的可支持速率</li>
</ul>
</li>
<li>数据信元中的EFCI bit: 被拥塞的交换机设置成1<ul>
<li>如果在管理信元RM前面的数据信元EFC被设置成了1, 接收端在返回的RM信元中设置CI bit</li>
</ul>
</li>
</ul>
<h3 id="TCP-拥塞控制：机制"><a href="#TCP-拥塞控制：机制" class="headerlink" title="TCP 拥塞控制：机制"></a>TCP 拥塞控制：机制</h3><ul>
<li>端到端的拥塞控制机制</li>
<li>路由器不向主机有关拥塞的反馈信息<ul>
<li>路由器的负担较轻</li>
<li>符合网络核心简单的TCP&#x2F;IP架构原则</li>
</ul>
</li>
<li>端系统根据自身得到的信息，判断是否发生拥塞，从而采取动作</li>
</ul>
<p>拥塞控制的几个问题</p>
<ul>
<li>如何检测拥塞<ul>
<li>轻微拥塞</li>
<li>拥塞</li>
</ul>
</li>
<li>控制策略<ul>
<li>在拥塞发送时如何动作，降低速率<ul>
<li>轻微拥塞，如何降低</li>
<li>拥塞时，如何降低</li>
</ul>
</li>
</ul>
</li>
<li>在拥塞缓解时如何动作，增加速率</li>
</ul>
<p><strong>TCP 拥塞控制：拥塞感知</strong></p>
<p>​	发送端如何探测到拥塞?</p>
<ul>
<li>某个段超时了（丢失事件 ）：拥塞<ul>
<li>超时时间到，某个段的确认没有来</li>
<li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大</li>
<li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小</li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对的</li>
</ul>
</li>
<li>有关某个段的3次重复ACK：轻微拥塞<ul>
<li>段的第1个ack，正常，确认绿段，期待红段</li>
<li>段的第2个重复ack，意味着红段的后一段收到了，蓝段乱序到达</li>
<li>段的第2、3、4个ack重复，意味着红段的后第2、3、4个段收到了，橙段乱序到达，同时红段丢失的可能性很大（后面3个段都到了，红段都没到）</li>
<li>网络这时还能够进行一定程度的传输，拥塞但情况要比第一种好</li>
</ul>
</li>
</ul>
<p><strong>TCP拥塞控制：速率控制方法</strong><br>如何控制发送端发送的速率</p>
<ul>
<li>维持一个拥塞窗口的值：CongWin</li>
<li>发送端限制已发送但是未确认的数据量（的上限）:<br>LastByteSent-LastByteAcked &lt;&#x3D; CongWin</li>
<li>从而粗略地控制发送方的往网络中注入的速率</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051809425.png" alt="image-20221105180955367" style="zoom:33%;" />

<ul>
<li>CongWin是动态的，是感知到的网络拥塞程度的函数<ul>
<li>超时或者3个重复ack，CongWin↓<ul>
<li>超时时：CongWin降为1MSS,进入SS阶段然后再倍增到CongWin&#x2F;2（每个RTT），从而进入CA阶段</li>
<li>3个重复ack ：CongWin降为CongWin&#x2F;2,CA阶段</li>
</ul>
</li>
<li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑<ul>
<li>SS阶段：加倍增加(每个RTT)</li>
<li>CA阶段：线性增加(每个RTT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>TCP拥塞控制和流量控制的联合动作</strong><br>联合控制的方法:</p>
<ul>
<li>发送端控制发送但是未确认的量同时也不能够超过接收窗口，满足流量控制要求<ul>
<li>SendWin&#x3D;min{CongWin, RecvWin}</li>
<li>同时满足 拥塞控制和流量控</li>
</ul>
</li>
</ul>
<p><strong>TCP 拥塞控制：策略概述</strong><br>拥塞控制策略:</p>
<ul>
<li>慢启动</li>
<li>AIMD：线性增、乘性减少</li>
<li>超时事件后的保守策略</li>
</ul>
<p><strong>TCP 慢启动</strong></p>
<ul>
<li>连接刚建立, CongWin &#x3D; 1 MSS<ul>
<li>如: MSS &#x3D; 1460bytes &amp; RTT &#x3D; 200 msec</li>
<li>初始速率 &#x3D; 58.4kbps</li>
</ul>
</li>
<li>可用带宽可能&gt;&gt; MSS&#x2F;RTT<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
</li>
<li>当连接开始时，指数性增加发送速率，直到发生丢失的事件<ul>
<li>启动初值很低</li>
<li>但是速度很快</li>
</ul>
</li>
<li>当连接开始时，指数性增加（每个RTT）发送速率直到发生丢失事件<ul>
<li>每一个RTT， CongWin加倍</li>
<li>每收到一个ACK时，CongWin加1（why）</li>
<li>慢启动阶段：只要不超时或3个重复ack，一个RTT， CongWin加倍</li>
</ul>
</li>
<li>总结: 初始速率很慢，但是加速却是指数性的<ul>
<li>指数增加，SS时间很短，长期来看可以忽略</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051939966.png" alt="image-20221105193920904" style="zoom: 50%;" />

<p><strong>TCP 拥塞控制：AIMD</strong></p>
<p>乘性减:<br>丢失事件后将CongWin降为1，将CongWin&#x2F;2作为阈值，进入慢启动阶段（倍增直到CongWin&#x2F;2）<br>加性增：<br>当CongWin&gt;阈值时，一个RTT如没有发生丢失事件 ,将CongWin加1MSS: 探测</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051950220.png" alt="image-20221105195041151" style="zoom:50%;" />

<ul>
<li><p>当收到3个重复的ACKs:</p>
<ul>
<li>CongWin 减半</li>
<li>窗口（缓冲区大小）之后线性增长</li>
</ul>
</li>
<li><p>当超时事件发生时:</p>
</li>
<li><p>CongWin被设置成 1 MSS，进入SS阶段</p>
</li>
<li><p>之后窗口指数增长</p>
</li>
<li><p>增长到一个阈值（上次发生拥塞的窗口的一半）时，再线性增加</p>
<p>思路</p>
</li>
<li><p>3个重复的ACK表示网络还有一定的段传输能力</p>
</li>
<li><p>超时之前的3个重复的ACK表示“警报”</p>
</li>
</ul>
<p><strong>改进</strong></p>
<blockquote>
<p>Q:什么时候应该将指数性增长变成线性？</p>
</blockquote>
<p>A:在超时之前，当CongWin变成上次发生超时的窗口的一半</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211051956349.png" alt="image-20221105195642281" style="zoom:50%;" />

<p>实现:</p>
<ul>
<li>变量：Threshold </li>
<li>出现丢失，Threshold设置成 CongWin的1&#x2F;2</li>
</ul>
<p><strong>总结: TCP拥塞控制</strong></p>
<ul>
<li>当CongWin＜Threshold, 发送端处于慢启动阶段（slow-start）, 窗口指数性增长.</li>
<li>当CongWin〉Threshold, 发送端处于拥塞避免阶段（congestion-avoidance）, 窗口线性增长.</li>
<li>当收到三个重复的ACKs (triple duplicate ACK),Threshold设置成 CongWin&#x2F;2， CongWin&#x3D;Threshold+3.</li>
<li>当超时事件发生时timeout, Threshold&#x3D;CongWin&#x2F;2CongWin&#x3D;1 MSS，进入SS阶段</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052035667.png" alt="image-20221105203533573" style="zoom: 33%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052000929.png" alt="image-20221105200035853" style="zoom:50%;" />

<p><strong>TCP 吞吐量</strong></p>
<ul>
<li>TCP的平均吞吐量是多少，使用窗口window尺寸W和RTT来描述?<ul>
<li>忽略慢启动阶段，假设发送端总有数据传输</li>
</ul>
</li>
<li>W：发生丢失事件时的窗口尺寸（单位：字节）<ul>
<li>平均窗口尺寸（#in-flight字节）：3&#x2F;4W</li>
<li>平均吞吐量：RTT时间吞吐3&#x2F;4</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052001118.png" alt="image-20221105200146060" style="zoom:50%;" />

<p><strong>TCP 未来: TCP over “long, fat pipes”</strong></p>
<p>  例如: 1500字节／段, 100ms RTT, 如果需要10 Gbps吞吐量</p>
<ul>
<li>T&#x3D;0.75W&#x2F;R -&gt; W&#x3D;TR&#x2F;0.75&#x3D;12.5M字节&#x3D;83333段</li>
<li>需要窗口大小 W &#x3D; 83,333 in-flight 段<br>吞吐量用丢失率表示:</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052003282.png" alt="image-20221105200355235" style="zoom: 33%;" />

<p>   -&gt; L &#x3D; 2·10-10 （为了达到10Gbps的吞吐，平均50亿段丢失一个） 非常非常小的丢失率！可能远远低于链路的物理丢失率，达不到的</p>
<ul>
<li>网络带宽增加，需要更新的TCP版本!</li>
</ul>
<p><strong>TCP 公平性</strong></p>
<p>公平性目标: 如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R&#x2F;K</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052004819.png" alt="image-20221105200440760" style="zoom: 33%;" />

<p><strong>为什么TCP是公平的?</strong><br>2个竞争的TCP会话:</p>
<ul>
<li>加性增加，斜率为1, 吞吐量增加</li>
<li>乘性减，吞吐量比例减少</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052005731.png" alt="image-20221105200529670" style="zoom: 50%;" />

<p>公平性和UDP</p>
<ul>
<li>多媒体应用通常不是用TCP<ul>
<li>应用发送的数据速率希望不受拥塞控制的节制</li>
</ul>
</li>
<li>使用UDP:<ul>
<li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li>
</ul>
</li>
<li>研究领域: TCP 友好性</li>
</ul>
<p>公平性和并行TCP连接</p>
<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>Web浏览器</li>
<li>例如: 带宽为R的链路支持了9个连接;<ul>
<li>如果新的应用要求建1个TCP连接,获得带宽R&#x2F;10</li>
<li>如果新的应用要求建11个TCP连接,获得带宽R&#x2F;2</li>
</ul>
</li>
</ul>
<p><strong>Explicit Congestion Notification (ECN)</strong><br>网络辅助拥塞控制:</p>
<ul>
<li>TOS字段中2个bit被网络路由器标记，用于指示是否发生拥塞</li>
<li>拥塞指示被传送到接收主机</li>
<li>在接收方-到发送方的ACK中，接收方(在IP数据报中看到了拥塞指示）设置ECE bit，指示发送方发生了拥塞</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211052011546.png" alt="image-20221105201118472" style="zoom:50%;" />

<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="数据平面与控制平面"><a href="#数据平面与控制平面" class="headerlink" title="数据平面与控制平面"></a>数据平面与控制平面</h3><p><strong>网络层服务</strong></p>
<ul>
<li>在发送主机和接收主机对之间传送段（segment）</li>
<li>在发送端将段封装到数据报中</li>
<li>在接收端，将段上交给传输层实体</li>
<li>网络层协议存在于每一个主机和路由器</li>
<li>路由器检查每一个经过它的IP数据报的头部</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081555085.png" alt="image-20221108155500972" style="zoom:67%;" />

<p><strong>网络层的关键功能</strong></p>
<p>网络层功能：</p>
<ul>
<li>转发: 将分组从路由器的输入接口转发到合适的输出接口</li>
<li>路由: 使用路由算法来决定分组从发送主机到目标接收主机的路径<ul>
<li>路由选择算法</li>
<li>路由选择协议</li>
</ul>
</li>
</ul>
<p>旅行的类比：</p>
<ul>
<li>转发: 通过单个路口的过程</li>
<li>路由: 从源到目的的路由路径规划过程</li>
</ul>
<p><strong>网络层：数据平面、控制平面</strong></p>
<p><em>数据平面</em> </p>
<ul>
<li><p>本地，每个路由器功能</p>
</li>
<li><p>决定从路由器输入端口到达的分组如何转发到输出端口</p>
</li>
<li><p>转发功能：</p>
<ul>
<li>传统方式：基于目标地址+转发表</li>
<li>SDN方式：基于多个字段+流表<br><em>控制平面</em></li>
</ul>
</li>
<li><p>网络范围内的逻辑</p>
</li>
<li><p>决定数据报如何在路由器之间路由，决定数据报从源到目标主机之间的端到端路径</p>
</li>
<li><p>2个控制平面方法: </p>
<pre><code>• 传统的路由算法: 在路由器中被实现 
• **software-defined networking (SDN):** 在远程的服务器中实现
</code></pre>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081600117.png" alt="image-20221108160044046" style="zoom:50%;" />

<p><strong>传统方式：每一路由器(Per-router)控制平面</strong></p>
<p>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081603537.png" alt="image-20221108160328433" style="zoom:50%;" />

<p><strong>传统方式：路由和转发的相互作用</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081605776.png" alt="image-20221108160505690" style="zoom:50%;" />

<p><strong>SDN方式：逻辑集中的控制平面</strong></p>
<p>一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081606570.png" alt="image-20221108160623463" style="zoom:50%;" />

<p><strong>网络服务模型</strong></p>
<p>Q: 从发送方主机到接收方主机传输数据报的“通道”，网络提供什么样的服务模型？<br>对于单个数据报的服务:</p>
<ul>
<li>可靠传送</li>
<li>延迟保证，如：少于40ms的延迟<br>对于数据报流的服务:</li>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟</li>
</ul>
<p><strong>连接建立</strong></p>
<ul>
<li>在某些网络架构中是第三个重要的功能<ul>
<li>ATM, frame relay, X.25</li>
</ul>
</li>
<li>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接<ul>
<li>涉及到路由器</li>
</ul>
</li>
<li>网络层和传输层连接服务区别:<ul>
<li>网络层: 在2个主机之间，涉及到路径上的一些路由器</li>
<li>传输层: 在2个进程之间，很可能只体现在端系统上(TCP连接)</li>
</ul>
</li>
</ul>
<p><strong>网络层服务模型:</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081617770.png" alt="image-20221108161726692" style="zoom:50%;" />

<h3 id="路由器组成"><a href="#路由器组成" class="headerlink" title="路由器组成"></a>路由器组成</h3><p><strong>路由器结构概况</strong></p>
<p>高层面(非常简化的)通用路由器体系架构</p>
<ul>
<li>路由：运行路由选择算法／协议 (RIP, OSPF, BGP)-生成路由表</li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081621564.png" alt="image-20221108162124491" style="zoom:50%;" />

<p><strong>输入端口功能</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081624040.png" alt="image-20221108162413941" style="zoom:50%;" />

<ul>
<li>根据数据报头部的信息如：目的地址，在输入端口内存中的转发表中查找合适的输出端口（匹配+行动）</li>
<li>基于目标的转发：仅仅依赖于IP数据报的目标IP地址（传统方法）</li>
<li>通用转发：基于头部字段的任意集合进行转发</li>
</ul>
<p><strong>基于目标的转发</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081625043.png" alt="image-20221108162519962" style="zoom:50%;" />

<blockquote>
<p>Q: 但是如果地址范围如果没有划分的特别规整，会发生什么？</p>
</blockquote>
<p><strong>最长前缀匹配(longest prefix matching)</strong></p>
<p>当给定目标地址查找转发表时，采用最长地址前缀匹配的目标地址表项</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081803953.png" alt="image-20221108180306863" style="zoom:50%;" />

<ul>
<li>最长前缀匹配：在路由器中经常采用TCAMs( ternary content addressable memories)硬件来完成<ul>
<li>内容可寻址：将地址交给TCAM，它可以在一个时钟周期内检索出地址，不管表空间有多大</li>
<li>Cisco Catalyst系列路由器: 在TCAM中可以存储多达约为1百万条路由表项</li>
</ul>
</li>
</ul>
<p><strong>输入端口缓存</strong></p>
<ul>
<li>当交换机构的速率小于输入端口的汇聚速率时,在输入端口可能要排队<ul>
<li>排队延迟以及由于输入缓存溢出造成丢失!</li>
</ul>
</li>
<li>Head-of-the-Line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据报向前移动</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081806376.png" alt="image-20221108180646316" style="zoom:50%;" />

<p><strong>交换结构</strong></p>
<ul>
<li>将分组从输入缓冲区传输到合适的输出端口</li>
<li>交换速率：分组可以按照该速率从输入传输到输出<ul>
<li>运行速度经常是输入&#x2F;输出链路速率的若干倍</li>
<li>N个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈</li>
</ul>
</li>
<li>3种典型的交换机构</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081809481.png" alt="image-20221108180903422" style="zoom:50%;" /> 

<p><strong>通过内存交换</strong></p>
<p>第一代路由器:</p>
<ul>
<li>在CPU直接控制下的交换，采用传统的计算机</li>
<li>分组被拷贝到系统内存，CPU从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口</li>
<li>转发速率被内存的带宽限制 (数据报通过BUS两遍)</li>
<li>一次只能转发一个分组</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081810617.png" alt="image-20221108181055553" style="zoom:50%;" />

<p><strong>通过总线交换</strong></p>
<ul>
<li>数据报通过共享总线，从输入端口转发到输出端口</li>
<li>总线竞争: 交换速度受限于总线带宽<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081812640.png" alt="image-20221108181224586" style="zoom:33%;" /></li>
<li>1次处理一个分组</li>
<li>1 Gbps bus, Cisco 1900;32 Gbps bus, Cisco 5600;对于接入或企业级路由器，速度足够（但不适合区域或骨干网络）</li>
</ul>
<p><strong>通过互联网络(crossbar等)的交换</strong></p>
<ul>
<li>同时并发转发多个分组，克服总线带宽限制</li>
<li>Banyan（榕树）网络，crossbar(纵横)和其它的互联网络被开发，将多个处理器连接成多处理器</li>
<li>当分组从端口A到达，转给端口Y；控制器短接相应的两个总线<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081850864.png" alt="image-20221108184956431" style="zoom:50%;" /></li>
<li>高级设计：将数据报分片为固定长度的信元，通过交换网络交换</li>
<li>Cisco12000：以60Gbps的交换速率通过互联网络</li>
</ul>
<p><strong>输出端口</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081859298.png" alt="image-20221108185909231" style="zoom:33%;" />

<ul>
<li>当数据报从交换机构的到达速度比传输速率快就需要输出端口缓存</li>
<li>由调度规则选择排队的数据报进行传输</li>
</ul>
<p><strong>输出端口排队</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081859605.png" alt="image-20221108185959541" style="zoom:50%;" />

<ul>
<li>假设交换速率Rswitch是Rline的N倍（N：输入端口的数量）</li>
<li>当多个输入端口同时向输出端口发送时，缓冲该分组（当通过交换网络到达的速率超过输出速率则缓存）</li>
<li>排队带来延迟，由于输出端口缓存溢出则丢弃数据报</li>
</ul>
<p><strong>调度机制</strong></p>
<ul>
<li><p>调度: 选择下一个要通过链路传输的分组</p>
</li>
<li><p>FIFO (first in first out) scheduling: 按照<br>分组到来的次序发送</p>
<ul>
<li><p>现实例子?</p>
</li>
<li><p>丢弃策略: 如果分组到达一个满的队列，哪个分组将会被抛弃?</p>
<ul>
<li><p>tail drop: 丢弃刚到达的分组</p>
</li>
<li><p>priority: 根据优先权丢失&#x2F;移除分组</p>
</li>
<li><p>random: 随机地丢弃&#x2F;移除</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081905837.png" alt="image-20221108190552779" style="zoom:50%;" />

<p><strong>调度策略：优先权</strong></p>
<p>优先权调度：发送最高优先权的分组</p>
<ul>
<li>多类，不同类别有不同的优先权<ul>
<li>类别可能依赖于标记或者其他的头部字段, e.g. IP source&#x2F;dest, port numbers, ds，etc.</li>
<li>先传高优先级的队列中的分组，除非没有</li>
<li>高（低）优先权中的分组传输次序：FIFO</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081911766.png" alt="image-20221108191143692" style="zoom:50%;" />

<p><strong>Round Robin (RR) scheduling:</strong></p>
<ul>
<li>多类</li>
<li>循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081920877.png" alt="image-20221108192057818" style="zoom:50%;" />

<p><strong>Weighted Fair Queuing (WFQ):</strong></p>
<ul>
<li>一般化的Round Robin</li>
<li>在一段时间内，每个队列得到的服务时间是：<br>Wi&#x2F;(XIGMA(Wi)) *t，和权重成正比</li>
<li>每个类在每一个循环中获得不同权重的服务量</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211081922626.png" alt="image-20221108192220569" style="zoom:50%;" />

<h3 id="IP-Internet-Protocol"><a href="#IP-Internet-Protocol" class="headerlink" title="IP:Internet Protocol"></a>IP:Internet Protocol</h3><p><strong>互联网的网络层</strong></p>
<p>主机,路由器中的网络层功能:</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100912728.png" alt="image-20221110091244629" style="zoom:50%;" />

<p><strong>IP 数据报格式</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100914365.png" alt="image-20221110091417264" style="zoom:50%;" />

<p><strong>IP 分片和重组(Fragmentation &amp; Reassembly)</strong></p>
<ul>
<li>网络链路有MTU (最大传输单元) –链路层帧所携带的最大数据长度<ul>
<li>不同的链路类型</li>
<li>不同的MTU</li>
</ul>
</li>
<li>大的IP数据报在网络上被分片(“fragmented”)<ul>
<li>一个数据报被分割成若干个小的数据报<ul>
<li>相同的ID</li>
<li>不同的偏移量</li>
<li>最后一个分片标记为0</li>
</ul>
</li>
<li>“重组”只在最终的目标主机进行</li>
<li>IP头部的信息被用于标识，排序相关分片</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100917997.png" alt="image-20221110091718907" style="zoom:67%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100930963.png" alt="image-20221110093039882" style="zoom:50%;" />

<p><strong>IP 编址: 引论</strong></p>
<ul>
<li>IP 地址: 32位标示，对主机或者路由器的接口编址</li>
<li>接口: 主机&#x2F;路由器和物理链路的连接处<ul>
<li>路由器通常拥有多个接口</li>
<li>主机也有可能有多个接口</li>
<li>IP地址和每一个接口关联</li>
</ul>
</li>
<li>一个IP地址和一个接口相关联</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100933203.png" alt="image-20221110093341132" style="zoom:67%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100937982.png" alt="image-20221110093704893" style="zoom:50%;" />

<ul>
<li>IP地址:<ul>
<li>子网部分(高位bits)</li>
<li>主机部分(地位bits)</li>
</ul>
</li>
<li>什么是子网(subnet) ?<ul>
<li>一个子网内的节点（主机或者路由器）它们的IP地址的高位部分相同，这些节点构成的网络的一部分叫做子网</li>
<li>无需路由器介入，子网内各主机可以在物理上相互直接到达</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100952697.png" alt="image-20221110095243600" style="zoom:50%;" />

<p>方法：</p>
<ul>
<li>要判断一个子网, 将每一个接口从主机或者路由器上分开,构成了一个个网络的孤岛</li>
<li>每一个孤岛（网络）都是一个都可以被称之为subnet.</li>
</ul>
<p>子网掩码：11111111 11111111 11111111 00000000<br>Subnet mask: &#x2F;24</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211100954846.png" alt="image-20221110095440752" style="zoom:50%;" />

<ul>
<li>Class A：126 networks ，16 million hosts</li>
<li>Class B：16382networks ，64 K hosts</li>
<li>Class C：2 million networks ，254 host </li>
<li>Class D：multicast</li>
<li>Class E：reserved for future</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101000432.png" alt="image-20221110100035328" style="zoom: 50%;" />

<p><strong>特殊IP地址</strong></p>
<ul>
<li>一些约定：<ul>
<li>子网部分: 全为 0—本网络</li>
<li>主机部分: 全为0—本主机</li>
<li>主机部分: 全为1–广播地址，这个网络的所有主机</li>
</ul>
</li>
<li>特殊IP地址</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101014236.png" alt="image-20221110101436139" style="zoom:67%;" />

<p><strong>内网(专用)IP地址</strong></p>
<ul>
<li>专用地址：地址空间的一部份供专用地址使用</li>
<li>永远不会被当做公用地址来分配, 不会与公用地址重复<ul>
<li>只在局部网络中有意义区分不同的设备</li>
</ul>
</li>
<li>路由器不对目标地址是专用地址的分组进行转发</li>
<li>专用地址范围<ul>
<li>Class A 10.0.0.0-10.255.255.255 MASK 255.0.0.0</li>
<li>Class B 172.16.0.0-172.31.255.255 MASK 255.255.0.0</li>
<li>Class C 192.168.0.0-192.168.255.255 MASK 255.255.255. 0</li>
</ul>
</li>
</ul>
<p><strong>IP 编址: CIDR</strong></p>
<p>CIDR: Classless InterDomain Routing（无类域间路由）</p>
<ul>
<li>子网部分可以在任意的位置</li>
<li>地址格式: a.b.c.d&#x2F;x, 其中 x 是 地址中子网号的长度</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101016829.png" alt="image-20221110101622727" style="zoom:50%;" />

<p><strong>子网掩码(subnet mask)</strong></p>
<ul>
<li>32bits , 0 or 1 in each bit<ul>
<li>1: bit位置表示子网部分</li>
<li>0:bit位置表示主机部分</li>
</ul>
</li>
<li>原始的A、B、C类网络的子网掩码分别是<ul>
<li>A：255.0.0.0 ：11111111 00000000 0000000 00000000</li>
<li>B：255.255.0.0：11111111 11111111 0000000 00000000</li>
<li>C：255.255.255.0：11111111 11111111 11111111 00000000</li>
</ul>
</li>
<li>CIDR下的子网掩码例子：<ul>
<li>11111111 11111111 11111100 00000000</li>
</ul>
</li>
<li>另外的一种表示子网掩码的表达方式<ul>
<li>&#x2F;#</li>
<li>例：&#x2F;22：表示前面22个bit为子网部分</li>
</ul>
</li>
</ul>
<p><strong>转发表和转发算法</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101030928.png" alt="image-20221110103043837" style="zoom: 50%;" />

<ul>
<li>获得IP数据报的目标地址</li>
<li>对于转发表中的每一个表项<br>√  如 (IP Des addr) &amp; (mask)&#x3D;&#x3D; destination, 则按照表项对应的接口转发该数据报<br>√  如果都没有找到,则使用默认表项转发数据报</li>
</ul>
<p><strong>如何获得一个IP地址</strong></p>
<p>Q: 主机如何获得一个IP地址?</p>
<ul>
<li>系统管理员将地址配置在一个文件中<ul>
<li>Wintel: control-panel-&gt;network-&gt;configuration-&gt;tcp&#x2F;ip-&gt;properties</li>
<li>UNIX: &#x2F;etc&#x2F;rc.config</li>
</ul>
</li>
<li>DHCP: Dynamic Host Configuration Protocol: 从服务器中动态获得一个IP地址<ul>
<li>“plug-and-play”</li>
</ul>
</li>
</ul>
<p><strong>DHCP: Dynamic Host Configuration Protocol</strong><br>目标: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址：</p>
<ul>
<li>可以更新对主机在用IP地址的租用期-租期快到了</li>
<li>重新启动时，允许重新使用以前用过的IP地址</li>
<li>支持移动用户加入到该网络（短期在网）<br>DHCP工作概况:</li>
<li>主机广播“DHCP discover” 报文[可选]</li>
<li>DHCP 服务器用 “DHCP offer”提供报文响应[可选]</li>
<li>主机请求IP地址：发送 “DHCP request” 报文</li>
<li>DHCP服务器发送地址：“DHCP ack” 报文</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101036018.png" alt="image-20221110103606899" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101036537.png" alt="image-20221110103633435" style="zoom:50%;" />

<p><strong>DHCP: 不仅仅是IP addresses</strong></p>
<p>DHCP 返回:</p>
<ul>
<li>IP 地址</li>
<li>第一跳路由器的IP地址（默认网关）</li>
<li>DNS服务器的域名和IP地址</li>
<li>子网掩码 (指示地址部分的网络号和主机号)</li>
</ul>
<blockquote>
<p>Q: 如何获得一个网络的子网部分? </p>
</blockquote>
<p>A: 从ISP获得地址块中分配一个小地址块</p>
<blockquote>
<p> Q: 一个ISP如何获得一个地址块? </p>
</blockquote>
<p>A: ICANN: Internet Corporation for Assigned  Names and Numbers</p>
<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决冲突</li>
</ul>
<p><strong>NAT: Network Address Translation</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101043213.png" alt="image-20221110104341106" style="zoom: 50%;" />

<ul>
<li>动机: 本地网络只有一个有效IP地址:<ul>
<li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备–省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的–安全</li>
</ul>
</li>
</ul>
<p>实现: NAT 路由器必须:</p>
<ul>
<li>外出数据包：替换源地址和端口号为NAT IP地址和新的端口号，目标IP和端口不变 …远端的C&#x2F;S将会用NAP IP地址，新端口号作为目标地址</li>
<li>记住每个转换替换对（在NAT转换表中） .. 源IP，端口 vs NAP IP ，新端口</li>
<li>进入数据包：替换目标IP地址和端口号，采用存储在NAT表中的mapping表项，用（源IP，端口）</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101058953.png" alt="image-20221110105859829" style="zoom: 33%;" />

<ul>
<li>16-bit端口字段:<ul>
<li>6万多个同时连接，一个局域网!</li>
</ul>
</li>
<li>对NAT是有争议的:<ul>
<li>路由器只应该对第3层做信息处理，而这里对端口号（4层）作了处理</li>
<li>违反了end-to-end 原则<ul>
<li>端到端原则：复杂性放到网络边缘<ul>
<li>无需借助中转和变换，就可以直接传送到目标主机</li>
</ul>
</li>
<li>NAT可能要被一些应用设计者考虑, eg, P2P applications</li>
<li>外网的机器无法主动连接到内网的机器上</li>
</ul>
</li>
<li>地址短缺问题可以被IPv6解决</li>
<li>NAT穿越：如果客户端需要连接在NAT后面的服务器，如何操作</li>
</ul>
</li>
</ul>
<p><strong>NAT 穿越问题</strong></p>
<ul>
<li>客户端需要连接地址为10.0.0.1的服务器<ul>
<li>服务器地址10.0.0.1 LAN本地地址 (客户端不能够使用其作为目标地址)</li>
<li>整网只有一个外部可见地址: 138.76.29.7</li>
</ul>
</li>
<li>方案1: 静态配置NAT：转发进来的对服务器特定端口连接请求<ul>
<li>e.g., (123.76.29.7, port 2500) 总是转发到10.0.0.1 port 25000</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101613082.png" alt="image-20221110161315995" style="zoom:50%;" />

<ul>
<li>方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许NATted主机可以:<ul>
<li>获知网络的公共 IP地址(138.76.29.7)</li>
<li>列举存在的端口映射</li>
<li>增&#x2F;删端口映射 (在租用时间内)<br>i.e., 自动化静态NAT端口映射配置</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101614155.png" alt="image-20221110161426090" style="zoom:50%;" />

<ul>
<li>方案 3: 中继 (used in Skype)<ul>
<li>NAT后面的服务器建立和中继的连接</li>
<li>外部的客户端链接到中继</li>
<li>中继在2个连接之间桥接</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101615857.png" alt="image-20221110161523775" style="zoom:50%;" />

<p><strong>IPv6：动机</strong></p>
<ul>
<li>初始动机: 32-bit地址空间将会被很快用完</li>
<li>另外的动机:</li>
<li>头部格式改变帮助加速处理和转发<ul>
<li>TTL-1</li>
<li>头部checksum</li>
<li>分片</li>
</ul>
</li>
<li>头部格式改变帮助QoS</li>
</ul>
<p>IPv6 数据报格式: </p>
<ul>
<li>固定的40 字节头部</li>
<li>数据报传输过程中，不允许分片</li>
</ul>
<p><strong>IPv6 头部 (Cont)</strong><br>Priority: 标示流中数据报的优先级<br>Flow Label: 标示数据报在一个“flow.” ( “flow”的概念没有被严格的定义)<br>Next header: 标示上层协议</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101632539.png" alt="image-20221110163226476" style="zoom: 33%;" />

<p><strong>和IPv4的其它变化</strong></p>
<ul>
<li>Checksum: 被移除掉，降低在每一段中的处理速度</li>
<li>Options: 允许，但是在头部之外, 被 “Next Header” 字段标示</li>
<li>ICMPv6: ICMP的新版本<ul>
<li>附加了报文类型, e.g. “Packet Too Big”</li>
<li>多播组管理功能</li>
</ul>
</li>
</ul>
<p><strong>从IPv4到IPv6的平移</strong></p>
<ul>
<li>不是所有的路由器都能够同时升级的<ul>
<li>没有一个标记日 “flag days”</li>
<li>在IPv4和IPv6路由器混合时，网络如何运转?</li>
</ul>
</li>
<li>隧道: 在IPv4路由器之间传输的IPv4数据报中携带IPv6数据报</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101636951.png" alt="image-20221110163629884" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211101637205.png" alt="image-20221110163750114" style="zoom: 33%;" />

<p>IPv6: 应用</p>
<ul>
<li>Google: 8% 的客户通过IPv6访问谷歌服务</li>
<li>NIST: 全美国1&#x2F;3的政府域支持IPv6</li>
<li>估计还需要很长时间进行部署<ul>
<li>20年以上!</li>
<li>看看过去20年来应用层面的变化: WWW, Facebook, streaming media, Skype, …<blockquote>
<p>为什么?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>部署应用好比刷墙漆，而更换IPv6则是重新盖房子，无法很快的执行</p>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p><strong>路由(route)的概念</strong></p>
<ul>
<li>路由:按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径<ul>
<li>较好路径: 按照某种指标较小的路径</li>
<li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均</li>
<li>采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视</li>
</ul>
</li>
<li>以网络为单位进行路由（路由信息通告+路由计算）<ul>
<li>网络为单位进行路由，路由信息传输、计算和匹配的代价低</li>
<li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集</li>
<li>路由就是：计算网络到其他网络如何走的问题</li>
</ul>
</li>
<li>网络到网络的路由&#x3D; 路由器-路由器之间路由<ul>
<li>网络对应的路由器到其他网络对应的路由器的路由</li>
<li>在一个网络中：路由器-主机之间的通信，链路层解决</li>
<li>到了这个路由器就是到了这个网络</li>
</ul>
</li>
<li>路由选择算法(routing algorithm):网络层软件的一部分,完成路由功能</li>
</ul>
<p><strong>网络的图抽象</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211140924184.png" alt="image-20221114092408085" style="zoom:50%;" />

<p>G &#x3D; (N,E)<br>N &#x3D; 路由器集合 &#x3D; { u, v, w, x, y, z }<br>E &#x3D; 链路集合 &#x3D;{ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }边有代价</p>
<p><strong>边和路径的代价</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211140927566.png" alt="image-20221114092737478" style="zoom:50%;" />

<ul>
<li>c(x,x’) &#x3D; 链路的代价 (x,x’) - e.g., c(w,z) &#x3D; 5</li>
<li>代价可能总为1</li>
<li>或是链路带宽的倒数</li>
<li>或是拥塞情况的倒数</li>
</ul>
<p>路由的输入：拓扑、边的代价、源节点<br>输出的输出：源节点的汇集树</p>
<p><strong>最优化原则(optimality principle)</strong></p>
<ul>
<li>汇集树(sink tree)<ul>
<li>此节点到所有其它节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211140928894.png" alt="image-20221114092831798" style="zoom:50%;" />

<p><strong>路由的原则</strong></p>
<ul>
<li>路由选择算法的原则<ul>
<li>正确性(correctness):算法必须是正确的和完整的,使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；</li>
<li>简单性(simplicity):算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量；</li>
<li>健壮性(robustness):算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据；</li>
<li>稳定性(stability)：产生的路由不应该摇摆</li>
<li>公平性(fairness)：对每一个站点都公平</li>
<li>最优性(optimality)：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
</li>
</ul>
<p><strong>路由算法分类</strong><br>全局或者局部路由信息?<br>全局:</p>
<ul>
<li><p>的路由器拥有完整的拓扑和边的代价的信息</p>
</li>
<li><p>“link state” 算法<br>分布式:</p>
</li>
<li><p>路由器只知道与它有物理连接关系的邻居路由器，和到相应邻居路由器的代价值</p>
</li>
<li><p>叠代地与邻居交换路由信息、计算路由信息</p>
</li>
<li><p>“distance vector” 算法<br>静态或者动态的?<br>静态:</p>
</li>
<li><p>路由随时间变化缓慢<br>动态:</p>
</li>
<li><p>路由变化很快</p>
<ul>
<li>周期性更新</li>
<li>根据链路代价的变化而变化</li>
</ul>
</li>
<li><p>非自适应算法(non-adaptive algorithm):不能适应网络拓扑和通信量的变化,路由表是事先计算好的</p>
</li>
<li><p>自适应路由选择(adaptive algorithm):能适应网络拓扑和通信量的变化</p>
</li>
</ul>
<p><strong>LS路由的工作过程</strong></p>
<ul>
<li>配置LS路由选择算法的路由工作过程<ul>
<li>各点通过各种渠道获得整个网络拓扑, 网络中所有链路代价等信息（这部分和算法没关系，属于协议和实现）</li>
<li>使用LS路由算法,计算本站点到其它站点的最优路径(汇集树),得到路由表</li>
<li>按照此路由表转发分组(datagram方式)<ul>
<li>严格意义上说不是路由的一个步骤</li>
<li>分发到输入端口的网络层</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211140938969.png" alt="image-20221114093856895" style="zoom: 50%;" />

<p><strong>链路状态路由选择(link state routing)</strong></p>
<p>LS路由的基本工作过程</p>
<ol>
<li>发现相邻节点,获知对方网络地址</li>
<li>测量到相邻节点的代价(延迟,开销)</li>
<li>组装一个LS分组,描述它到相邻节点的代价情况</li>
<li>将分组通过扩散的方法发到所有其它路由器以上4步让每个路由器获得拓扑和边代价</li>
<li>通过Dijkstra算法找出最短路径（这才是路由算法）<ol>
<li>每个节点独立算出来到其他节点（路由器&#x3D;网络）的最短路径</li>
<li>迭代算法：第k步能够知道本节点到k个其他节点的最短路径</li>
</ol>
</li>
</ol>
<p><strong>详细过程</strong></p>
<ol>
<li>发现相邻节点,获知对方网络地址</li>
</ol>
<ul>
<li>一个路由器上电之后,向所有线路发送HELLO分组</li>
<li>其它路由器收到HELLO分组,回送应答,在应答分组中,告知自己的名字(全局唯一)</li>
<li>在LAN中,通过广播HELLO分组,获得其它路由器的信息,可以认为引入一个人工节点</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141003088.png" alt="image-20221114100348007" style="zoom: 50%;" />

<ol start="2">
<li>测量到相邻节点的代价(延迟,开销)</li>
</ol>
<ul>
<li>实测法,发送一个分组要求对方立即响应</li>
<li>回送一个ECHO分组</li>
<li>通过测量时间可以估算出延迟情况</li>
</ul>
<ol start="3">
<li>组装一个分组,描述相邻节点的情况</li>
</ol>
<ul>
<li>发送者名称</li>
<li>序号,年龄</li>
<li>列表: 给出它相邻节点,和它到相邻节点的延迟</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141005721.png" alt="image-20221114100515646" style="zoom: 50%;" />

<ol start="4">
<li>将分组通过扩散的方法发到所有其它路由器</li>
</ol>
<ul>
<li>顺序号:用于控制无穷的扩散,每个路由器都记录(源路由器,顺序号),发现重复的或老的就不扩散<ul>
<li>具体问题1: 循环使用问题</li>
<li>具体问题2: 路由器崩溃之后序号从0开始</li>
<li>具体问题3:序号出现错误</li>
</ul>
</li>
<li>解决问题的办法:年龄字段(age)<ul>
<li>生成一个分组时,年龄字段不为0</li>
<li>每个一个时间段,AGE字段减1</li>
<li>AGE字段为0的分组将被抛弃</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141007840.png" alt="image-20221114100740764" style="zoom:50%;" />

<ol start="5">
<li>通过Dijkstra算法找出最短路径</li>
</ol>
<ul>
<li>路由器获得各站点LS分组和整个网络的拓扑</li>
<li>通过Dijkstra算法计算出到其它各路由器的最短路径(汇集树)</li>
<li>将计算结果安装到路由表中</li>
<li>LS的应用情况<ul>
<li>OSPF协议是一种LS协议,被用于Internet上</li>
<li>IS-IS(intermediate system- intermediate system): 被用于Internet主干中, Netware</li>
</ul>
</li>
<li>符号标记:<br>c(i,j): 从节点i 到j链路代价(初始状态下非相邻节点之间的链路代价为∞)<br>D(v): 从源节点到节点V的当前路径代价(节点的代价)<br>p(v): 从源到节点V的路径前序节点<br>N’: 当前已经知道最优路径的的节点集合(永久节点的集合)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141022763.png" alt="image-20221114102214694" style="zoom:50%;" />

<ul>
<li><p>LS路由选择算法的工作原理</p>
<ul>
<li>节点标记: 每一个节点使用(D(v),p(v)) 如：(3,B)标记<ul>
<li>D(v)从源节点由已知最优路径到达本节点的距离</li>
<li>P(v)前序节点来标注</li>
</ul>
</li>
<li>2类节点<ul>
<li>临时节点(tentative node) :还没有找到从源节点到此节点的最优路径的节点</li>
<li>永久节点(permanent node) N’:已经找到了从源节点到此节点的最优路径的节点</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li>除了源节点外,所有节点都为临时节点</li>
<li>节点代价除了与源节点代价相邻的节点外,都为∞</li>
</ul>
</li>
<li><p>从所有临时节点中找到一个节点代价最小的临时节点,将之变成永久节点(当前节点)W</p>
</li>
<li><p>对此节点的所有在临时节点集合中的邻节点(V)</p>
<ul>
<li>如 D(v)&gt;D(w) + c(w,v), 则重新标注此点, (D(W)+C(W,V), W)</li>
<li>否则，不重新标注</li>
</ul>
</li>
<li><p>开始一个新的循环</p>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141029372.png" alt="image-20221114102958295" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141030408.png" alt="image-20221114103025305" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211141033798.png" alt="image-20221114103328693" style="zoom:50%;" />

<p><strong>Dijkstra算法的讨论</strong></p>
<p>算法复杂度: n节点</p>
<ul>
<li>每一次迭代: 需要检查所有不在永久集合N中节点</li>
<li>n(n+1)&#x2F;2 次比较: O(n2)</li>
<li>有很有效的实现: O(nlogn)</li>
</ul>
<p>可能的震荡：</p>
<ul>
<li>e.g.,链路代价&#x3D;链路承载的流量</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211142159537.png" alt="image-20221114215928431" style="zoom:50%;" />

<p><strong>距离矢量路由选择(distance vector routing)</strong></p>
<ul>
<li><p>代价及相邻节点间代价的获得</p>
<ul>
<li>跳数(hops), 延迟(delay),队列长度</li>
<li>相邻节点间代价的获得：通过实测</li>
</ul>
</li>
<li><p>路由信息的更新</p>
<ul>
<li>根据实测 得到本节点A到相邻站点的代价（如:延迟）</li>
<li>根据各相邻站点声称它们到目标站点B的代价</li>
<li>计算出本站点A经过各相邻站点到目标站点B的代价</li>
<li>找到一个最小的代价，和相应的下一个节点Z，到达节点B经过此节点Z，并且代价为A-Z-B的代价</li>
<li>其它所有的目标节点一个计算</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211142213616.png" alt="image-20221114221341539" style="zoom: 50%;" /></li>
</ul>
<p><strong>例子</strong></p>
<ul>
<li>以当前节点J为例,相邻节点A,I,H,K</li>
<li>J测得到A,I,H,K的延迟为8ms,10ms,12ms,6ms</li>
<li>通过交换DV, 从A,I,H,K获得到它们到G的延迟为18ms,31ms,6ms,31ms</li>
<li>因此从J经过A,I,H,K到G的延迟为26ms,41ms,18ms,37ms</li>
<li>将到G的路由表项更新为18ms, 下一跳为：H</li>
<li>其它目标一样，除了本节点</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151551801.png" alt="image-20221115155151694" style="zoom: 50%;" />

<p><strong>距离矢量算法</strong></p>
<p>Bellman-Ford 方程(动态规划)</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151553820.png" alt="image-20221115155332748" style="zoom: 50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151554445.png" alt="image-20221115155421369" style="zoom:50%;" />

<p>那个能够达到目标z最小代价的节点x，就在到目标节点的下一条路径上, 在转发表中使用</p>
<p><strong>距离矢量算法</strong></p>
<ul>
<li>Dx(y) &#x3D; 节点x到y代价最小值的估计<ul>
<li>x 节点维护距离矢量Dx &#x3D; [Dx(y): y є N ]</li>
</ul>
</li>
<li>节点x:<ul>
<li>知道到所有邻居v的代价: c(x,v)</li>
<li>收到并维护一个它邻居的距离矢量集</li>
<li>对于每个邻居, x 维护Dv &#x3D; [Dv(y): y є N ]</li>
</ul>
</li>
</ul>
<p>核心思路:</p>
<ul>
<li><p>每个节点都将自己的距离矢量估计值传送给邻居，定时或者DV有变化时，让对方去算</p>
</li>
<li><p>当x从邻居收到DV时，自己运算，更新它自己的距离矢量</p>
<ul>
<li>采用B-F equation:</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151557436.png" alt="image-20221115155732377" style="zoom:50%;" />
</li>
<li><p>Dx(y)估计值最终收敛于实际的最小代价值dx(y)</p>
<ul>
<li>分布式、迭代算法</li>
</ul>
</li>
</ul>
<p>异步式,迭代: 每次本地迭代被以下事件触发: </p>
<ul>
<li>本地链路代价变化了</li>
<li>从邻居来了DV的更新消息<br>分布式:</li>
<li>每个节点只是在自己的DV改变之后向邻居通告<ul>
<li>然后邻居们在有必要的时候通知他们的邻居</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151559957.png" alt="image-20221115155908890" style="zoom:50%;" />

<p><strong>距离矢量路由选择(distance vector routing)</strong></p>
<ul>
<li>DV的无穷计算问题<ul>
<li>DV的特点<ul>
<li>好消息传的快 坏消息传的慢</li>
</ul>
</li>
<li>好消息的传播以每一个交换周期前进一个路由器的速度进行<ul>
<li>好消息:某个路由器接入或有更短的路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151601216.png" alt="image-20221115160145148" style="zoom:50%;" />

<ul>
<li>坏消息的传播速度非常慢(无穷计算问题)</li>
<li>例子:<ul>
<li>第一次交换之后, B从C处获得信息,C可以到达A(C-A,要经过B本身),但是路径是2,因此B变成3,从C处走</li>
<li>第二次交换,C从B处获得消息, B可以到达A,路径为3, 因此,C到A从B走,代价为3</li>
<li>无限此之后, 到A的距离变成INF,不可达</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151607113.png" alt="image-20221115160707037" style="zoom:50%;" />

<p><strong>水平分裂(split horizon)算法</strong></p>
<ul>
<li><p>一种对无穷计算问题的解决办法</p>
<ul>
<li>C知道要经过B才能到达A，所以C向B报告它到A的距离为INF；C 告诉D它到A的真实距离</li>
<li>D告诉E,它到A的距离,但D告诉C它通向A的距离为INF</li>
<li>第一次交换: B通过测试发现到A的路径为INF,而C也告诉B到A的距离为INF,因此,B到A的距离为INF</li>
<li>第二次交换: C从B和D那里获知,到A的距离为INF,因此将它到A的距离为INF</li>
<li>……坏消息以一次交换一个节点的速度传播<br> <em>不告诉下属到自己的真实路程，只问下属到下一个的真实距离</em></li>
</ul>
</li>
<li><p>水平分裂的问题:在某些拓扑形式下会失败（存在环路）</p>
</li>
<li><p>例子:</p>
<ul>
<li>A,B到D的距离为2, C到D的距离为1、</li>
<li>如果C-D路径失败，C获知到D为INF,从A,B获知到D的距离为INF,因此C认为D不可达</li>
<li>A从C获知D的距离为INF,但从B处获知它到D的距离为2,因此A到B的距离为3,从B走</li>
<li>B也有类似的问题</li>
<li>经过无限次之后,A和B都知道到D的距离为INF</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151629325.png" alt="image-20221115162942246" style="zoom:50%;" />

<p><strong>LS 和 DV 算法的比较</strong></p>
<p>消息复杂度（DV胜出）</p>
<ul>
<li>LS: 有 n 节点, E 条链路,发送报文O(nE)个<ul>
<li>局部的路由信息；全局传播</li>
</ul>
</li>
<li>DV: 只和邻居交换信息<ul>
<li>全局的路由信息，局部传播</li>
</ul>
</li>
</ul>
<p>收敛时间（LS胜出）</p>
<ul>
<li>LS: O(n2) 算法<ul>
<li>有可能震荡</li>
</ul>
</li>
<li>DV: 收敛较慢<ul>
<li>可能存在路由环路</li>
<li>count-to-infinity 问题</li>
</ul>
</li>
</ul>
<p>健壮性: 路由器故障会发生什么（LS胜出）<br>LS: </p>
<ul>
<li>节点会通告不正确的链路代价</li>
<li>每个节点只计算自己的路由表</li>
<li>错误信息影响较小，局部，路由较健壮<br>DV:</li>
<li>DV节点可能通告对全网所有节点的不正确路径代价<ul>
<li>距离矢量</li>
</ul>
</li>
<li>每一个节点的路由表可能被其它节点使用<ul>
<li>错误可以扩散到全网</li>
</ul>
</li>
</ul>
<p>2种路由选择算法都有其优缺点，而且在互联网上都有应用</p>
<h3 id="自治系统内部的路由选择"><a href="#自治系统内部的路由选择" class="headerlink" title="自治系统内部的路由选择"></a>自治系统内部的路由选择</h3><p><strong>RIP ( Routing Information Protocol)</strong></p>
<ul>
<li>在 1982年发布的BSD-UNIX 中实现</li>
<li>Distance vector 算法<ul>
<li>距离矢量:每条链路cost&#x3D;1，# of hops (max &#x3D; 15 hops) 跳数</li>
<li>DV每隔30秒和邻居交换DV，通告</li>
<li>每个通告包括：最多25个目标子网</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151643291.png" alt="image-20221115164318220" style="zoom:50%;" />

<p><strong>RIP 通告（advertisements）</strong></p>
<ul>
<li>DV: 在邻居之间每30秒交换通告报文<ul>
<li>定期，而且在改变路由的时候发送通告报文</li>
<li>在对方的请求下可以发送通告报文</li>
</ul>
</li>
<li>每一个通告: 至多AS内部的25个目标网络的DV<ul>
<li>目标网络+跳数（一次公告最多25个子网，最大跳数为16）</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151705528.png" alt="image-20221115170500453" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151705233.png" alt="image-20221115170533153" style="zoom:50%;" />

<p><strong>RIP: 链路失效和恢复</strong></p>
<p>如果180秒没有收到通告信息  –&gt;  邻居或者链路失效</p>
<ul>
<li>发现经过这个邻居的路由已失效</li>
<li>新的通告报文会传递给邻居</li>
<li>邻居因此发出新的通告 (如果路由变化的话)</li>
<li>链路失效快速(?)地在整网中传输</li>
<li>使用毒性逆转（poison reverse）阻止ping-pong回路 (不可达的距离：跳数无限 &#x3D; 16 段)</li>
</ul>
<p><strong>RIP 进程处理</strong></p>
<ul>
<li><p>RIP 以应用进程的方式实现：route-d (daemon)</p>
</li>
<li><p>通告报文通过UDP报文传送，周期性重复</p>
</li>
<li><p>网络层的协议使用了传输层的服务，以应用层实体的方式实现</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151707156.png" alt="image-20221115170713086" style="zoom:50%;" /></li>
</ul>
<p><strong>OSPF (Open Shortest Path First)</strong></p>
<ul>
<li>“open”: 标准可公开获得</li>
<li>使用LS算法<ul>
<li>LS 分组在网络中（一个AS内部）分发</li>
<li>全局网络拓扑、代价在每一个节点中都保持</li>
<li>路由计算采用Dijkstra算法</li>
</ul>
</li>
<li>OSPF通告信息中携带：每一个邻居路由器一个表项</li>
<li>通告信息会传遍AS全部（通过泛洪）<ul>
<li>在IP数据报上直接传送OSPF报文 (而不是通过UDP和TCP)</li>
</ul>
</li>
<li>IS-IS路由协议：几乎和OSPF一样</li>
</ul>
<p><strong>OSPF “高级” 特性(在RIP中的没有的)</strong></p>
<ul>
<li>安全: 所有的OSPF报文都是经过认证的 (防止恶意的攻击) </li>
<li>允许有多个代价相同的路径存在 (在RIP协议中只有一个)</li>
<li>对于每一个链路，对于不同的TOS有多重代价矩阵<ul>
<li>例如：卫星链路代价对于尽力而为的服务代价设置比较低，对实时服务代价设置的比较高</li>
<li>支持按照不同的代价计算最优路径，如：按照时间和延迟分别计算最优路径</li>
</ul>
</li>
<li>对单播和多播的集成支持: <ul>
<li>Multicast OSPF (MOSPF) 使用相同的拓扑数据库，就像在OSPF中一样</li>
</ul>
</li>
<li>在大型网络中支持层次性OSP</li>
</ul>
<p><strong>层次化的OSPF路由</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211151722904.png" alt="image-20221115172201809" style="zoom: 50%;" />

<ul>
<li>2个级别的层次性: 本地, 骨干<ul>
<li>链路状态通告仅仅在本地区域Area范围内进行</li>
<li>每一个节点拥有本地区域的拓扑信息；<ul>
<li>关于其他区域，知道去它的方向，通过区域边界路由器（最短路径）</li>
</ul>
</li>
</ul>
</li>
<li>区域边界路由器: “汇总（聚集）”到自己区域内网络的距离, 向其它区域边界路由器通告.</li>
<li>骨干路由器: 仅仅在骨干区域内，运行OSPF路由</li>
<li>边界路由器: 连接其它的AS’s.</li>
</ul>
<h3 id="ISP之间的路由选择-BGP"><a href="#ISP之间的路由选择-BGP" class="headerlink" title="ISP之间的路由选择:  BGP"></a>ISP之间的路由选择:  BGP</h3><p>层次路由</p>
<ul>
<li><p>一个平面的路由</p>
<ul>
<li>一个网络中的所有路由器的地位一样</li>
<li>通过LS, DV，或者其他路由算法，所有路由器都要知道其他所有路由器（子网）如何走</li>
<li>所有路由器在一个平面</li>
</ul>
</li>
<li><p>平面路由的问题</p>
<ul>
<li>规模巨大的网络中，路由信息的存储、传输和计算代价巨大<ul>
<li>DV: 距离矢量很大，且不能够收敛 </li>
<li>LS：几百万个节点的LS分组的泛洪传输，存储以及最短路径算法的计算</li>
</ul>
</li>
<li>管理问题：<ul>
<li>不同的网络所有者希望按照自己的方式管理网络</li>
<li>希望对外隐藏自己网络的细节</li>
<li>当然，还希望和其它网络互联</li>
</ul>
</li>
</ul>
</li>
<li><p>层次路由：将互联网分成一个个AS(路由器区域)</p>
<ul>
<li>某个区域内的路由器集合，自治系统“autonomous systems” (AS)</li>
<li>一个AS用AS Number（ASN)唯一标示</li>
<li>一个ISP可能包括1个或者多个AS</li>
</ul>
</li>
<li><p>路由变成了: 2个层次路由</p>
<ul>
<li>AS内部路由：在同一个AS内路由器运行相同的路由协议<ul>
<li>“intra-AS” routing protocol：内部网关协议</li>
<li>不同的AS可能运行着不同的内部网关协议</li>
<li>能够解决规模和管理问题</li>
<li>如：RIP,OSPF,IGRP</li>
<li>网关路由器：AS边缘路由器，可以连接到其他AS</li>
</ul>
</li>
<li>AS间运行AS间路由协议<ul>
<li>“inter-AS” routing protocol：外部网关协议</li>
<li>解决AS之间的路由问题，完成AS之间的互联互通</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>层次路由的优点</strong></p>
<ul>
<li>解决了规模问题<ul>
<li>内部网关协议解决：AS内部数量有限的路由器相互到达的问题, AS内部规模可控<ul>
<li>如AS节点太多，可分割AS，使得AS内部的节点数量有限</li>
</ul>
</li>
<li>AS之间的路由的规模问题<ul>
<li>增加一个AS，对于AS之间的路由从总体上来说，只是增加了一个节点&#x3D;子网（每个AS可以用一个点来表示）</li>
<li>对于其他AS来说只是增加了一个表项，就是这个新增的AS如何走的问题</li>
<li>扩展性强：规模增大，性能不会减得太多</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>互联网AS间路由：BGP</strong></p>
<ul>
<li>BGP (Border Gateway Protocol): 自治区域间路由协议“事实上的”标准<ul>
<li>“将互联网各个AS粘在一起的胶水”</li>
</ul>
</li>
<li>BGP 提供给每个AS以以下方法：<ul>
<li>eBGP: 从相邻的ASes那里获得子网可达信息</li>
<li>iBGP: 将获得的子网可达信息传遍到AS内部的所有路由器</li>
<li>根据子网可达信息和策略来决定到达子网的“好”路径</li>
</ul>
</li>
<li>允许子网向互联网其他网络通告“我在这里”</li>
<li>基于距离矢量算法（路径矢量）<ul>
<li>不仅仅是距离矢量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单DV算法的路由环路问题</li>
</ul>
</li>
</ul>
<p><strong>eBGP, iBGP 连接</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170902692.png" alt="image-20221117090208536" style="zoom: 50%;" />

<p><strong>BGP基础</strong></p>
<ul>
<li><p>BGP 会话: 2个BGP路由器(“peers”)在一个半永久的TCP连接上交换BGP报文:</p>
<ul>
<li>通告向不同目标子网前缀的“路径”（BGP是一个“路径矢量”协议）</li>
</ul>
</li>
<li><p>当AS3网关路由器3a向AS2的网关路由器2c通告路径： AS3,X</p>
<ul>
<li>3a参与AS内由运算，知道本AS所有子网X信息</li>
<li>语义上：AS3向AS2承诺，它可以向子网X转数据报</li>
<li>3a是2c关于X的下一跳（next hop）</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170905434.png" alt="image-20221117090502341" style="zoom:50%;" />

<p><strong>路径的属性&amp; BGP 路由</strong></p>
<ul>
<li>当通告一个子网前缀时，通告包括 BGP 属性<ul>
<li>prefix + attributes &#x3D; “route”</li>
</ul>
</li>
<li>2个重要的属性:<ul>
<li>AS-PATH: 前缀的通告所经过的AS列表: AS 67 AS 17<ul>
<li>检测环路；多路径选择</li>
<li>在向其它AS转发时，需要将自己的AS号加在路径上</li>
</ul>
</li>
<li>NEXT-HOP: 从当前AS到下一跳AS有多个链路，在NETX-HOP属性中，告诉对方通过那个 I 转发.</li>
<li>其它属性：路由偏好指标，如何被插入的属性</li>
</ul>
</li>
<li>基于策略的路由：<ul>
<li>当一个网关路由器接收到了一个路由通告, 使用输入策略来接受或过滤（accept&#x2F;decline.）<ul>
<li>过滤原因例1：不想经过某个AS，转发某些前缀的分组</li>
<li>过滤原因例2：已经有了一条往某前缀的偏好路径</li>
</ul>
</li>
<li>策略也决定了是向它别的邻居通告收到的这个路</li>
</ul>
</li>
</ul>
<p><strong>BGP 路径通告</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170913019.png" alt="image-20221117091328930" style="zoom: 50%;" />

<ul>
<li>路由器AS2.2c从AS3.3a接收到的AS3,X路由通告 (通过 eBGP)</li>
<li>基于AS2的输入策略，AS2.2c决定接收AS3,X的通告，而且通过iBGP）向AS2的所有路由器进行通告</li>
<li>基于AS2的策略，AS2路由器2a通过eBGP向AS1.1c路由器通告AS2,AS3,X 路由信息<ul>
<li>路径上加上了 AS2自己作为AS序列的一跳</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170914841.png" alt="image-20221117091402737" style="zoom: 50%;" />

<p>网关路由器可能获取有关一个子网X的多条路径，从多个eBGP会话上：</p>
<ul>
<li>AS1 网关路由器1c从2a学习到路径：AS2,AS3,X</li>
<li>AS1网关路由器1c从3a处学习到路径AS3,X</li>
<li>基于策略，AS1路由器1c选择了路径：AS3,X，而且通过iBGP告诉所有AS1内部的路由器</li>
</ul>
<p><strong>BGP报文</strong></p>
<ul>
<li>使用TCP协议交换BGP报文.</li>
<li>BGP 报文:<ul>
<li>OPEN: 打开TCP连接，认证发送方</li>
<li>UPDATE: 通告新路径 (或者撤销原路径)</li>
<li>KEEPALIVE：在没有更新时保持连接，也用于对OPEN 请求确认</li>
<li>NOTIFICATION: 报告以前消息的错误，也用来关闭连接</li>
</ul>
</li>
</ul>
<p><strong>BGP, OSPF, 转发表表项</strong></p>
<blockquote>
<p>Q:路由器是如何设置到这些远程子网前缀的转发表表项的？</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170922400.png" alt="image-20221117092208290" style="zoom: 50%;" />

<blockquote>
<p>Q:路由器是如何设置到这些远程子网前缀的转发表表项的？</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170923844.png" alt="image-20221117092330731" style="zoom:50%;" />

<p><strong>BGP 路径选择</strong></p>
<ul>
<li>路由器可能获得一个网络前缀的多个路径，路由器必须进行路径的选择，路由选择可以基于：</li>
</ul>
<ol>
<li>本地偏好值属性: 偏好策略决定</li>
<li>最短AS-PATH ：AS的跳数</li>
<li>最近的NEXT-HOP路由器:热土豆路由</li>
<li>附加的判据：使用BGP标示</li>
</ol>
<ul>
<li>一个前缀对应着多种路径，采用消除规则直到留下一条路径</li>
</ul>
<p><strong>热土豆路由</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170926711.png" alt="image-20221117092610603" style="zoom:50%;" />

<ul>
<li>2d通过iBGP获知，它可以通过2a或者2c到达X</li>
<li>热土豆策略：选择具备最小内部区域代价的网关作为往X的出口（如：2d选择2a，即使往X可能有比较多的AS跳数）：不要操心域间的代价！</li>
</ul>
<p><strong>BGP: 通过路径通告执行策略</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170927887.png" alt="image-20221117092741791" style="zoom:50%;" />

<ul>
<li>A向B和C通告路径Aw</li>
<li>B选择不向C通告BAw：<ul>
<li>B从CBAw的路由上无法获得收益，因为C,A,w都不是B的客户</li>
<li>C从而无法获知 CBAw路径的存在：每个ISP感知到的网络和真实不一致</li>
</ul>
</li>
<li>C可能会通过 CAw (而不是使用B)最终路由到w</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170933408.png" alt="image-20221117093344314"></p>
<ul>
<li>A,B,C 是 提供商网络：</li>
<li>X,W,Y 是桩网络（stub networks）或者叫端网络</li>
<li>X 是双重接入的，多宿桩网络，接入了2个网络</li>
<li>策略强制让X:<ul>
<li>X不想路由从B通过X到C的分组</li>
<li>因而X就不通告给B，它实际上可以路由到C</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么内部网关协议和外部网关协议如此不同?</p>
</blockquote>
<p>策略:</p>
<ul>
<li>Inter-AS: 管理员需要控制通信路径，谁在使用它的网络进行数据传输；</li>
<li>Intra-AS: 一个管理者，所以无需策略;<ul>
<li>AS内部的各子网的主机尽可能地利用资源进行快速路由<br>规模:</li>
</ul>
</li>
<li>AS间路由必须考虑规模问题，以便支持全网的数据转发</li>
<li>AS内部路由规模不是一个大的问题<ul>
<li>如果AS 太大，可将此AS分成小的AS；规模可控</li>
<li>AS之间只不过多了一个点而已</li>
<li>或者AS内部路由支持层次性，层次性路由节约了表空间, 降低了更新的数据流量<br>性能:</li>
</ul>
</li>
<li>Intra-AS: 关注性能</li>
<li>Inter-AS: 策略可能比</li>
</ul>
<h3 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h3><p><strong>传统方式：每-路由器(Per-router)控制平面</strong></p>
<p>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170935569.png" alt="image-20221117093536442" style="zoom:50%;" />

<p><strong>SDN方式：逻辑上集中的控制平面</strong></p>
<p>一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211170937232.png" alt="image-20221117093716104" style="zoom:67%;" />

<p><strong>Software defined networking (SDN)</strong></p>
<p>为什么需要一个逻辑上集中的控制平面?</p>
<ul>
<li>网络管理更加容易：避免路由器的错误配置，对于通信流的弹性更好</li>
<li>基于流表的转发（回顾一下OpenFlow API)，允许“可编程”的路由器<ul>
<li>集中式“编程”更加容易：集中计算流表然后分发</li>
<li>传统方式分布式“编程”困难：在每个单独的路由器上分别运行分布式的算法，得转发表（部署和升级代价低）<ul>
<li>而且要求各分布式计算出的转发表都得基本正确</li>
</ul>
</li>
</ul>
</li>
<li>控制平面的开放实现（非私有）<ul>
<li>新的竞争生态</li>
</ul>
</li>
</ul>
<p><strong>主框架到PC的演变</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211171027946.png" alt="image-20221117102718800" style="zoom:50%;" />

<p><strong>流量工程: 传统路由比较困难</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211171027124.png" alt="image-20221117102753025" style="zoom:50%;" />

<blockquote>
<p> Q: 网管如果需要u到z的流量走uvwz,x到z的流量走xwyz，怎么办？</p>
</blockquote>
<p>A: 需要定义链路的代价，流量路由算法以此运算（ IP路由面向目标，无法操作） (或者需要新的路由算法）</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211171030850.png" alt="image-20221117103020751" style="zoom:50%;" />

<blockquote>
<p>Q: 如果网管需要将u到z的流量分成2路：uvwz 和uxyz (负载均衡)，怎么办?（ IP路由面向目标）</p>
</blockquote>
<p>A: 无法完成(在原有体系下只有使用新的路由选择算法，而在全网部署新的路由算法是个大的事情</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211171032993.png" alt="image-20221117103207886" style="zoom:50%;" />

<blockquote>
<p>Q:如果需要w对蓝色的和红色的流量采用不同的路由，怎么办？</p>
</blockquote>
<p>A: 无法操作 (基于目标的转发，采用LS, DV 路由)</p>
<p><strong>SDN特点</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211171033243.png" alt="image-20221117103346125" style="zoom: 50%;" />

<p><strong>SDN 架构: 数据平面交换机</strong></p>
<ul>
<li>快速，简单，商业化交换设备采用硬件实现通用转发功能</li>
<li>流表被控制器计算和安装</li>
<li>基于南向API（例如OpenFlow），SDN控制器访问基于流的交换机<ul>
<li>定义了哪些可以被控制哪些不能</li>
</ul>
</li>
<li>也定义了和控制器的协议(eg.OpenFlow)</li>
</ul>
<p><strong>SDN 控制器(网络OS):</strong></p>
<ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现</li>
</ul>
<p>**网络控制应用: **</p>
<ul>
<li>控制的大脑： 采用下层提供的服务（SDN控制器提供的API)，实现网络功能<br>• 路由器 交换机<br>• 接入控制 防火墙<br>• 负载均衡<br>• 其他功能</li>
<li>非绑定：可以被第三方提供，与控制器厂商以通常上不同，与分组交换机厂商也可以不同</li>
</ul>
<p><strong>SDN控制器里的元件</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172223136.png" alt="image-20221117222319913" style="zoom:50%;" />

<p><strong>OpenFlow 协议</strong></p>
<ul>
<li>控制器和SDN交换机交互的协议</li>
<li>采用TCP来交换报文<ul>
<li>加密可选</li>
</ul>
</li>
<li>3种OpenFlow报文类型<ul>
<li>控制器&gt;交换机</li>
<li>异步（交换机&gt;控制器）</li>
<li>对称 (misc)</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172225828.png" alt="image-20221117222504726" style="zoom:50%;" />

<p><strong>OpenFlow: 控制器-交换机报文</strong></p>
<p>一些关键的控制器到交换机的报文</p>
<ul>
<li>特性：控制器查询交换机特性，交换机应答</li>
<li>配置：交换机查询&#x2F;设置交换机的配置参数</li>
<li>修改状态：增加删除修改OpenFlow表中的流表</li>
<li>packet-out：控制器可以将分组通过特定的端口发出</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172227171.png" alt="image-20221117222718069" style="zoom:50%;" />

<ul>
<li>分组进入: 将分组（和它的控制）传给控制器，见来自控制器的packet-out报文</li>
<li>流移除: 在交换机上删除流表项</li>
<li>端口状态: 通告控制器端口的变化</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172227118.png" alt="image-20221117222755006" style="zoom:50%;" />

<p><strong>SDN: 控制&#x2F;数据平面交互的例子</strong></p>
<p>1.S1, 经历了链路失效，采用OpenFlow报文通告控制器:端口状态报文<br>2.SDN 控制器接收OpenFlow报文，更新链路状态信息<br>3.Dijkstra路由算法应用被调用（前面注册过这个状态变化消息）<br>4.Dijkstra路由算法访问控制器中的网络拓扑信息，链路状态信息计算新路由<br>5.链路状态路由app和SDN控制器中流表计算元件交互，计算出新的所需流表<br>6.控制器采用OpenFlow在交换机上安装新的需要更新的流表</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172230331.png" alt="image-20221117223020214" style="zoom:50%;" />

<p><strong>OpenDaylight (ODL) 控制器</strong></p>
<ul>
<li>ODL Lithium 控制器</li>
<li>网络应用可以在SDN 控制 内 或者 外面</li>
<li>服务抽象层SAL：和内部以及外部的应用以及服务进行交互</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172231278.png" alt="image-20221117223144158" style="zoom:50%;" />

<p><strong>ONOS 控制器</strong></p>
<ul>
<li>控制应用和控制器分离（应用app在控制器外部）</li>
<li>意图框架：服务的高级规范：描述什么而不是如何</li>
<li>相当多的重点聚焦在分布式核心上，以提高服务的可靠性，性能的可扩展性</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211172232568.png" alt="image-20221117223233430" style="zoom:50%;" />

<p><strong>SDN: 面临的挑战</strong></p>
<ul>
<li>强化控制平面：可信、可靠、性能可扩展性、安全的分布式系统<ul>
<li>对于失效的鲁棒性： 利用为控制平面可靠分布式系统的强大理论</li>
<li>可信任，安全：从开始就进行铸造</li>
</ul>
</li>
<li>网络、协议满足特殊任务的需求<ul>
<li>e.g., 实时性，超高可靠性、超高安全性</li>
</ul>
</li>
<li>互联网络范围内的扩展性<ul>
<li>而不是仅仅在一个AS的内部部署，全网部署</li>
</ul>
</li>
</ul>
<h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><p><strong>网络节点的连接方式</strong></p>
<ul>
<li>点到点连接</li>
<li>多点连接：<ul>
<li>共享型介质</li>
<li>通过网络交换机</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221146986.png" alt="image-20221122114604763" style="zoom:50%;" />

<ul>
<li><p>WAN:网络形式采用点到点链路</p>
<ul>
<li>带宽大、距离远（延迟大） &gt;带宽延迟积大</li>
<li>如果采用多点连接方式<ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
</li>
<li><p>点到点链路的链路层服务实现非常简单，封装和解封装</p>
</li>
<li><p>LAN一般采用多点连接方式</p>
<ul>
<li>连接节点非常方便</li>
<li>接到共享型介质上（或网络交换机），就可以连接所有其他节点</li>
</ul>
</li>
<li><p>多点连接方式网络的链路层功能实现相当复杂</p>
<ul>
<li>多点接入：协调各节点对共享性介质的访问和使用</li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ul>
</li>
</ul>
<p><strong>链路层</strong></p>
<p><em>术语</em></p>
<ul>
<li>主机和路由器是节点（网桥和交换机也是）：nodes</li>
<li>沿着通信路径,连接个相邻节点通信信道的是链路：links<ul>
<li>有线链路</li>
<li>无线链路</li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>第二层协议数据单元帧frame，封装数据报</li>
</ul>
<p>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点（一个子网内部的2节点）</p>
<p><strong>链路层：上下文</strong></p>
<ul>
<li>数据报（分组）在不同的链路上以不同的链路协议传送：<ul>
<li>第一跳链路：以太网</li>
<li>中间链路：帧中继链路</li>
<li>最后一跳802.11 :</li>
</ul>
</li>
<li>不同的链路协议提供不同的服务</li>
<li>e.g.比如在链路层上提供（或没有）可靠数据传送</li>
</ul>
<p>传输类比</p>
<ul>
<li>从Princeton到Lausanne<ul>
<li>轿车: Princeton to JFK</li>
<li>飞机: JFK to Geneva</li>
<li>火车: Geneva to Lausanne</li>
</ul>
</li>
<li>旅行者&#x3D;数据报datagram</li>
<li>交通段&#x3D;通信链路communication link</li>
<li>交通模式&#x3D;链路层协议 : 数据链路层和局域网protocol</li>
<li>票务代理&#x3D;路由算法routing algorith</li>
</ul>
<p><strong>链路层服务</strong></p>
<ul>
<li>成帧，链路接入：<ul>
<li>将数据报封装在帧中，加上帧头、帧尾部</li>
<li>如果采用的是共享性介质，信道接入获得信道访问权</li>
<li>在帧头部使用“MAC”（物理）地址来标示源和目的<ul>
<li>不同于IP地址</li>
</ul>
</li>
</ul>
</li>
<li>在（一个网络内）相邻两个节点完成可靠数据传递<ul>
<li>已经学过了（第三章）</li>
<li>在低出错率的链路上（光纤和双绞线电缆）很少使用</li>
<li>在无线链路经常使用：出错率高<blockquote>
<p>Q: 为什么在链路层和传输层都实现了可靠性</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>一般化的链路层服务，不是所有的链路层都提供这些服务一个特定的链路层只是提供其中一部分的服务</p>
<ul>
<li>在相邻节点间（一个子网内）进行可靠的转发<ul>
<li>在低差错链路上很少使用 (光纤,一些双绞线)<ul>
<li>出错率低，没有必要在每一个帧中做差错控制的工作，协议复杂<ul>
<li>发送端对每一帧进行差错控制编码，根据反馈做相应的动作</li>
<li>接收端进行差错控制解码，反馈给发送端（ACK，NAK）</li>
</ul>
</li>
<li>在本层放弃可靠控制的工作，在网络层或者是传输层做可靠控制的工作，或者根本就不做可靠控制的工作</li>
</ul>
</li>
<li>在高差错链路上需要进行可靠的数据传送<ul>
<li>高差错链路：无线链路：</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Q：为什么要在采用无线链路的网络上，链路层做可靠数据传输工作；还要在传输层做端到端的可靠性工作？</p>
</blockquote>
<p>原因：出错率高，如果在链路层不做差错控制工作，漏出去的错误比较高；到了上层如果需要可靠控制的数据传输代价会很大</p>
<p>如不做local recovery 工作，总体代价大</p>
<ul>
<li>流量控制：<ul>
<li>使得相邻的发送和接收方节点的速度匹配</li>
</ul>
</li>
<li>错误检测：<ul>
<li>差错由信号衰减和噪声引起</li>
<li>接收方检测出的错误: <ul>
<li>通知发送端进行重传或丢弃帧</li>
</ul>
</li>
</ul>
</li>
<li>差错纠正: <ul>
<li>接收端检查和纠正bit错误，不通过重传来纠正错误</li>
</ul>
</li>
<li>半双工和全双工:<ul>
<li>半双工：链路可以双向传输，但一次只有一个方向</li>
</ul>
</li>
</ul>
<p><strong>链路层在哪里实现</strong></p>
<ul>
<li>在每一个主机上<ul>
<li>也在每个路由器上</li>
<li>交换机的每个端口上</li>
</ul>
</li>
<li>链路层功能在“适配器”上实现 (aka network interface card NIC) 或者在一个芯片组上<ul>
<li>以太网卡，802.11 网卡：以太网芯片组</li>
<li>实现链路层和相应的物理层功能</li>
</ul>
</li>
<li>接到主机的系统总线上</li>
<li>硬件、软件和固件的综合体</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221221156.png" alt="image-20221122122159051" style="zoom: 50%;" />

<p><strong>适配器通信</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221224847.png" alt="image-20221122122415765" style="zoom:50%;" />

<ul>
<li><p>发送方:</p>
<ul>
<li>在帧中封装数据报</li>
<li>加上差错控制编码，实现RDT和流量控制功能等</li>
</ul>
</li>
<li><p>接收方：</p>
<ul>
<li>检查有无出错，执行rdt和流量控制功能等</li>
<li>解封装数据报，将至交给上层</li>
</ul>
</li>
</ul>
<h3 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h3><p><strong>错误检测</strong></p>
<p>EDC&#x3D;差错检测和纠正位（冗余位）<br>D &#x3D;数据由差错检测保护，可以包含头部字段<br>错误检测不是100%可靠的</p>
<ul>
<li>协议会漏检一些错误，但是很少</li>
<li>更长的EDC字段可以得到更好的检测和纠正效果</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221544216.png" alt="image-20221122154449074" style="zoom: 33%;" />

<p><strong>奇偶校验</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221545684.png" alt="image-20221122154524565" style="zoom: 33%;" />

<p><strong>Internet校验和</strong></p>
<p>目标: 检测在传输报文段时的错误（如位翻转），（注：仅仅用在传输层）</p>
<p>发送方:</p>
<ul>
<li>将报文段看成16-bit整数</li>
<li>报文段的校验和: 和 (1’的补码和)</li>
<li>发送方将checksum的值放在‘UDP校验和’字段</li>
</ul>
<p>接收方:</p>
<ul>
<li>计算接收到的报文段的校验和</li>
<li>检查是否与携带校验和字段值一致:<ul>
<li>不一致：检出错误</li>
<li>一致：没有检出错误，但可能还是有错误</li>
</ul>
</li>
</ul>
<p><strong>检验和：CRC（循环冗余校验）</strong></p>
<ul>
<li>强大的差错检测码</li>
<li>将数据比特 D, 看成是二进制的数据</li>
<li>生成多项式G：双方协商r+1位模式（r次方）<ul>
<li>生成和检查所使用的位模式</li>
</ul>
</li>
<li>目标:选择r位 CRC附加位R，使得<ul>
<li>&lt;D,R&gt; 正好被 G整除 (modulo 2)</li>
<li>接收方知道 G, 将 &lt;D,R&gt;除以 G. 如果非0余数: 检查出错误!</li>
<li>能检出所有少于r+1位的突发错误</li>
</ul>
</li>
<li>实际中广泛使用（以太网、802.11 WiFi、ATM）</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221613826.png" alt="image-20221122161350735" style="zoom: 33%;" />

<p><strong>CRC 例子</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221614032.png" alt="image-20221122161442891" style="zoom: 33%;" />

<p><strong>CRC性能分析</strong></p>
<ul>
<li>突发错误和突发长度</li>
<li>CRC检错性能描述</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221615437.png" alt="image-20221122161544342" style="zoom: 33%;" />

<h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><p><strong>多路访问链路和协议</strong></p>
<p>两种类型的链路（一个子网内部链路连接形式）：</p>
<ul>
<li>点对点<ul>
<li>拨号访问的PPP</li>
<li>以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>广播 (共享线路或媒体)<ul>
<li>传统以太网</li>
<li>HFC上行链路</li>
<li>802.11无线局域网</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221629001.png" alt="image-20221122162912914" style="zoom:50%;" />

<p><strong>多点访问协议</strong></p>
<ul>
<li>单个共享的广播型链路</li>
<li>2个或更多站点同时传送: 冲突（collision）<ul>
<li>多个节点在同一个时刻发送，则会收到2个或多个信号叠加</li>
</ul>
</li>
</ul>
<p><em>多路访问协议（介质访问控制协议：MAC）</em></p>
<ul>
<li>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送？</li>
<li>关于共享控制的通信必须用借助信道本身传输！<ul>
<li>没有带外的信道，各节点使用其协调信道使用</li>
<li>用于传输控制信息</li>
</ul>
</li>
</ul>
<p><strong>理想的多路访问协议</strong></p>
<p>给定：Rbps的广播信道<br>必要条件：<br>1.当一个节点要发送时，可以R速率发送.<br>2.当M个节点要发送，每个可以以R&#x2F;M的平均速率发送<br>3.完全分布的:</p>
<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙的同步</li>
</ul>
<p>4.简单</p>
<p><strong>MAC（媒体访问控制）协议：分类</strong><br>3大类:</p>
<ul>
<li>信道划分<ul>
<li>把信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li>随机访问<ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li>依次轮流<ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
<p><strong>a.信道划分MAC协议：TDMA</strong></p>
<p>TDMA:time division multiple acces</p>
<ul>
<li>轮流使用信道，信道的时间分为周期</li>
<li>每个站点使用每周期中固定的时隙(长度&#x3D;帧传输时间)传输帧</li>
<li>如果站点无帧传输，时隙空闲-&gt;浪费</li>
<li>如：6站LAN，1、3、4有数据报，时隙2、5、6空闲</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221638519.png" alt="image-20221122163802447" style="zoom:50%;" />

<p>FDMA: frequency division multiple access</p>
<ul>
<li>信道的有效频率范围被分成一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段如果没有被使用，则空闲</li>
<li>例如：6站LAN，1、3、4有数据报，频段2、5、 6空闲</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211221639358.png" alt="image-20221122163919276" style="zoom:50%;" />

<p><strong>a.码分多路访问（CDMA）</strong></p>
<ul>
<li>CDMA (code division multiple access) : <ul>
<li>所有站点在整个频段上同时进行传输,采用编码原理加以区分</li>
<li>完全无冲突</li>
<li>假定:信号同步很好,线性叠加</li>
</ul>
</li>
<li>比方<ul>
<li>TDM：不同的人在不同的时刻讲话</li>
<li>FDM：不同的组在不同的小房间里通信</li>
<li>CDMA：不同的人使用不同的语言讲话</li>
</ul>
</li>
</ul>
<p><strong>b.随机存取协议</strong></p>
<ul>
<li>当节点有帧要发送时<ul>
<li>以信道带宽的全部 R bps发送</li>
<li>没有节点间的预先协调</li>
</ul>
</li>
<li>两个或更多节点同时传输，会发生➜冲突“collision”</li>
<li>随机存取协议规定: <ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复（如：通过稍后的重传）</li>
</ul>
</li>
<li>随机MAC协议:<ul>
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA, CSMA&#x2F;CD, CSMA&#x2F;CA</li>
</ul>
</li>
</ul>
<p><strong>b.1 时隙ALOHA</strong><br>假设</p>
<ul>
<li>所有帧是等长的</li>
<li>时间被划分成相等的时隙，每个时隙可发送一帧</li>
<li>节点只在时隙开始时发送帧</li>
<li>节点在时钟上是同步的</li>
<li>如果两个或多个节点在一个时隙传输，所有的站点都能检测到冲突</li>
</ul>
<p>运行</p>
<ul>
<li>当节点获取新的帧，在下一个时隙传输</li>
<li>传输时没有检测到冲突，成功<ul>
<li>节点能够在下一时隙发送新帧</li>
</ul>
</li>
<li>检测时如果检测到冲突，失败<ul>
<li>节点在每一个随后的时隙以概率p重传帧直到成功</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211231927424.png" alt="image-20221123192758312" style="zoom:50%;" />

<p>优点</p>
<ul>
<li>节点可以以信道带宽全速连续传输</li>
<li>高度分布：仅需要节点之间在时隙上的同步</li>
<li>简单</li>
</ul>
<p>缺点</p>
<ul>
<li>存在冲突，浪费时隙</li>
<li>即使有帧要发送，仍然有可能存在空闲的时隙</li>
<li>节点检测冲突的时间&lt;帧传输的时间 <ul>
<li>必须传完</li>
</ul>
</li>
<li>需要时钟上同步</li>
</ul>
<p><strong>时隙ALOHA的效率( Efficiency )</strong></p>
<p>效率：当有很多节点，每个节点有很多帧要发送时，x%的时隙是成功传输帧的时隙</p>
<ul>
<li><p>假设N个节点，每个节点都有很多帧要发送，在每个时隙中的传输概率是p</p>
</li>
<li><p>一个节点成功传输概率是p(1-p)^N-1</p>
</li>
<li><p>任何一个节点的成功概率是&#x3D; Np(1-p)^N-1</p>
</li>
<li><p>N个节点的最大效率：求出使f(P)&#x3D;Np(1-p)N-1最大的p*</p>
</li>
<li><p>代入P<em>得到最大f(p</em>)&#x3D;Np*(1-p*)N-1 </p>
</li>
<li><p>N为无穷大时的极限为1&#x2F;e&#x3D;0.37</p>
</li>
</ul>
<p>最好情况：信道利用率37%</p>
<p><strong>b.2 纯ALOHA(非时隙)</strong></p>
<ul>
<li>无时隙ALOHA：简单、无须节点间在时间上同步</li>
<li>当有帧需要传输：马上传输</li>
<li>冲突的概率增加:<ul>
<li>帧在to发送，和其它在[to-1, to+1]区间内开始发送的帧冲突</li>
<li>和当前帧冲突的区间（其他帧在此区间开始传输）增大</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232156904.png" alt="image-20221123215626805" style="zoom:50%;" />

<p><strong>b.3 CSMA(载波侦听多路访问)</strong></p>
<p>Aloha: 如何提高ALOHA的效率发之前不管有无其他节点在传输<br>CSMA: 在传输前先侦听信道:</p>
<ul>
<li>如果侦听到信道空闲，传送整个帧</li>
<li>如果侦听到信道忙，推迟传送</li>
<li>人类类比：不要打断别人正在进行的说话</li>
</ul>
<p><strong>b.4 CSMA&#x2F;CD(冲突检测)</strong><br>CSMA&#x2F;CD: </p>
<ul>
<li>载波侦听CSMA：和在CSMA中一样发送前侦听信道</li>
<li>没有传完一个帧就可以在短时间内检测到冲突</li>
<li>冲突发生时则传输终止，减少对信道的浪费</li>
<li>冲突检测CD技术，有线局域网中容易实现：<ul>
<li>检测信号强度，比较传输与接收到的信号是否相同</li>
<li>通过周期的过零点检测</li>
</ul>
</li>
<li>人类类比：礼貌的对话人</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232202527.png" alt="image-20221123220202432" style="zoom:50%;" />

<p>Ps：对信道的浪费减少了</p>
<p><strong>以太网CSMA&#x2F;CD算法</strong></p>
<ol>
<li>适配器获取数据报，创建帧</li>
<li>发送前：侦听信道CS<br> 1)闲：开始传送帧<br> 2)忙：一直等到闲再发送<br> 3.发送过程中，冲突检测CD<br> 1)没有冲突:成功<br> 2)检测到冲突:放弃,之后尝试重发</li>
</ol>
<p>4.发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此。 强化冲突：让所有站点都知道冲突</p>
<p>5.如果放弃，适配器进入指数退避状态在第m次失败后，适配器随机选择一个{0，1，2， ， 2^m-1}中K，等待K*512位时，然后转到步骤2<br>exponential backoff二进制指数退避算法</p>
<p>指数退避: </p>
<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发<ul>
<li>高负载：重传窗口时间大，减少冲突，但等待时间长</li>
<li>低负载：使得各站点等待时间少，但冲突概率大</li>
</ul>
</li>
<li>首次碰撞：在{0，1}选择K；延迟K*512位时</li>
<li>第2次碰撞：在{0，1，2，3}选择K</li>
<li>第10次碰撞：在{0，1，2，3，……，1023}选择K</li>
</ul>
<p><strong>CSMA&#x2F;CD效率</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232212271.png" alt="image-20221123221214189" style="zoom:50%;" />

<p><strong>b.5 无线局域网 CSMA&#x2F;CA</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232213893.png" alt="image-20221123221302796" style="zoom:50%;" />

<ul>
<li>冲突: 2+ 站点（AP或者站点）在同一个时刻发送</li>
<li>802.11: CSMA – 发送前侦听信道<ul>
<li>不会和其它节点正在进行的传输发生冲突</li>
</ul>
</li>
<li>802.11: 没有冲突检测!<ul>
<li>无法检测冲突：自身信号远远大于其他节点信号</li>
<li>即使能CD：冲突!&#x3D;成功</li>
<li>目标: avoid collisions: CSMA&#x2F;C(ollision)A(voidance)<ul>
<li>无法CD，一旦发送一脑全部发送完毕，不CD</li>
<li>为了避免无CD带来的信道利用率低的问题，事前进行冲突避免</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232214802.png" alt="image-20221123221439722" style="zoom:50%;" />

<p>发送方<br>1 如果站点侦测到信道空闲持续DIFS长，则传输整个帧 (no CD)<br>2 如果侦测到信道忙碌，那么 选择一个随机回退值，并在信道空闲时递减该值；如果信道忙碌，回退值不会变化到数到0时（只生在信道闲时）发送整个帧如果没有收到ACK, 增加回退值，重复2<br>802.11 接收方 </p>
<ul>
<li>如果帧正确，则在SIFS后发送ACK</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211232217374.png" alt="image-20221123221732295" style="zoom:50%;" />

<p><strong>IEEE 802.11 MAC 协议: CSMA&#x2F;CA</strong></p>
<ul>
<li><p>在count down时，侦听到了信道空闲为什么不发送，而要等到0时在发送</p>
<ul>
<li>2个站点有数据帧需要发送，第三个节点正在发送</li>
<li>LAN CD：让2者听完第三个节点发完，立即发送<ul>
<li>冲突：放弃当前的发送，避免了信道的浪费于无用冲突帧的发送</li>
<li>代价不昂贵</li>
</ul>
</li>
</ul>
</li>
<li><p>WLAN : CA</p>
<ul>
<li>无法CD，一旦发送就必须发完，如冲突信道浪费严重，代价高昂</li>
<li>思想：尽量事先避免冲突，而不是在发生冲突时放弃然后重发<ul>
<li><p>听到发送的站点，分别选择随机值，回退到0发送</p>
<ul>
<li>不同的随机值，一个站点会胜利</li>
<li>失败站点会冻结计数器，当胜利节点发完再发</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251944856.png" alt="image-20221125194429770" style="zoom:33%;" /></li>
</ul>
</li>
</ul>
</li>
<li><p>无法完全避免冲突</p>
<ul>
<li>两个站点相互隐藏：<br>• A,B 相互隐藏，C在传输<br>• A,B选择了随机回退值<br>• 一个节点如A胜利了，发送<br>• 而B节点收不到，顺利count down到0 发送<br>• A,B的发送在C附近形成了干扰 </li>
<li>选择了非常靠近的随机回退值：<br>• A,B选择的值非常近<br>• A到0后发送<br>• 但是这个信号还没达到B时<br>• B也到0了，发送冲突</li>
</ul>
</li>
</ul>
<p><strong>冲突避免</strong><br>思想：允许发送方“预约”信道，而不是随机访问该信道: 避免长数据帧的冲突（可选项）</p>
<ul>
<li>发送方首先使用CSMA向BS发送一个小的RTS分组<ul>
<li>RTS可能会冲突（但是由于比较短，浪费信道较少）</li>
</ul>
</li>
<li>BS广播 clear-to-send CTS，作为RTS的响应</li>
<li>CTS能够被所有涉及到的节点听到<ul>
<li>发送方发送数据帧</li>
<li>其它节点抑制发<blockquote>
<p>采用小的预约分组，可以完全避免数据帧的冲突</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>冲突避免：RTS-CTS交换</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251946535.png" alt="image-20221125194629422" style="zoom:50%;" />

<p><strong>b.5 线缆接入网络</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251947136.png" alt="image-20221125194741021" style="zoom: 50%;" />
+ 多个40Mbps 下行(广播)信道,FDM
  + 下行：通过FDM分成若干信道，互联网、数字电视等 
  + 互联网信道：只有1个CMTS在其上传输
+ 多个30 Mbps上行的信道,FDM
  + 多路访问：所有用户使用；接着TDM分成微时隙
  + 部分时隙：分配；部分时隙：竞争

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251951154.png" alt="image-20221125195114062" style="zoom: 50%;" />

<p>DOCSIS: data over cable service interface spec </p>
<ul>
<li>采用FDM进行信道的划分：若干上行、下行信道</li>
<li>下行信道:<ul>
<li>在下行MAP帧中：CMTS告诉各节点微时隙分配方案，分配给各站点的上行微时隙</li>
<li>另外：头端传输下行数据（给各个用户）</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211251955187.png" alt="image-20221125195507101" style="zoom:50%;" />

<p>DOCSIS: TDM上行信道</p>
<ul>
<li>采用TDM的方式将上行信道分成若干微时隙：MAP指定</li>
<li>站点采用分配给它的微时隙上行数据传输：分配</li>
<li>在特殊的上行微时隙中，各站点请求上行微时隙：竞争<ul>
<li>各站点对于该时隙的使用是随机访问的</li>
<li>一旦碰撞（请求不成功，结果是：在下行的MAP中没有为它分配，则二进制退避）选择时隙上传输</li>
</ul>
</li>
</ul>
<p><strong>c.轮流(Taking Turns)MAC协议</strong></p>
<p>信道划分MAC协议:</p>
<ul>
<li>共享信道在高负载时是有效和公平的</li>
<li>在低负载时效率低下<ul>
<li>只能等到自己的时隙开始发送或者利用1&#x2F;N的信道频率发送</li>
<li>当只有一个节点有帧传时，也只能够得到1&#x2F;N个带宽分配<br>随机访问MAC协议：</li>
</ul>
</li>
<li>在低负载时效率高：单个节点可以完全利用信道全部带宽</li>
<li>高负载时：冲突开销较大，效率极低，时间很多浪费在冲突中<br>轮流协议<br>有2者的优点!</li>
</ul>
<p><strong>轮询</strong><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252007476.png" alt="image-20221125200704394" style="zoom:50%;" /></p>
<ul>
<li>主节点邀请从节点依次传送</li>
<li>从节点一般比较“dumb”</li>
<li>缺点:<ul>
<li>轮询开销：轮询本身消耗信道带宽</li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送</li>
<li>单点故障：主节点失效时造成整个系统无法工作</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211252007970.png" alt="image-20221125200759875" style="zoom: 50%;" />

<p>令牌传递:</p>
<ul>
<li>控制令牌( token)循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点:<ul>
<li>令牌开销：本身消耗带宽</li>
<li>延迟：只有等到抓住令牌，才可传输</li>
<li>单点故障 (token)：<ul>
<li>令牌丢失系统级故障，整个系统无法传输</li>
<li>复杂机制重新生成令牌</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>MAC 协议总结</strong></p>
<ul>
<li>多点接入问题：对于一个共享型介质，各个节点如何协调对它的访问和使用?<ul>
<li>信道划分：按时间、频率或者编码<ul>
<li>TDMA、FDMA、CDMA</li>
</ul>
</li>
</ul>
</li>
<li>随机访问 (动态)<br>• ALOHA, S-ALOHA, CSMA, CSMA&#x2F;CD<br>• 载波侦听: 在有些介质上很容易 (wire：有线介质), 但在有些介质上比较困难 (wireless：无线)<br>• CSMA&#x2F;CD ：802.3 Ethernet网中使用<br>• CSMA&#x2F;CA ：802.11WLAN中使用</li>
<li>依次轮流协议<ul>
<li>集中：由一个中心节点轮询；分布：通过令牌控制</li>
<li>蓝牙、FDDI、令牌环</li>
</ul>
</li>
</ul>
<h3 id="LANs"><a href="#LANs" class="headerlink" title="LANs"></a>LANs</h3><p><strong>MAC 地址和ARP</strong></p>
<ul>
<li>32bitIP地址: <ul>
<li>网络层地址</li>
<li>前n-1跳：用于使数据报到达目的IP子网</li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li>LAN（MAC&#x2F;物理&#x2F;以太网）地址:<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)</li>
<li>48bit MAC地址固化在适配器的ROM，有时也可以通过软件设定</li>
<li>理论上全球任何2个网卡的MAC地址都不相同</li>
</ul>
</li>
</ul>
<p><strong>网络地址和mac地址分离</strong></p>
<ol>
<li>分离好处<br>a) 网卡坏了，ip不变，可以捆绑到另外一个网卡的mac上<br>b) 物理网络还可以除IP之外支持其他网络层协议，链路协议为任意 上层网络协议， 如IPX等</li>
<li>捆绑的问题<br>a) 如果仅仅使用IP地址，不用mac地址，那么它仅支持IP协议<br>b) 每次上电都要重新写入网卡 IP地址；<br>c) 另外一个选择就是不使用任何地址；不用MAC地址，则每到来一个帧都要上传到IP层次，由它判断是不是需要接受，干扰一次</li>
</ol>
<p><strong>LAN 地址和ARP</strong></p>
<p>局域网上每个适配器都有一个唯一的LAN地址</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211282212521.png" alt="image-20221128221255400" style="zoom: 33%;" />

<ul>
<li>MAC地址由IEEE管理和分配</li>
<li>制造商购入MAC地址空间（保证唯一性）</li>
<li>类比:<br>(a)MAC地址：社会安全号<br>(b)IP地址：通讯地址</li>
<li>MAC平面地址 ➜ 支持移动<ul>
<li>可以将网卡到接到其它网络</li>
</ul>
</li>
<li>IP地址有层次-不能移动<ul>
<li>依赖于节点连接的IP子网，与子网的网络号相同（有与其相连的子网相同的网络前缀）</li>
</ul>
</li>
</ul>
<p><strong>ARP: Address Resolution Protocol</strong></p>
<blockquote>
<p>问题:已知B的IP地址，如何确定B的MAC地址?</p>
</blockquote>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202211282218076.png" alt="image-20221128221800956" style="zoom: 33%;" />

<ul>
<li>在LAN上的每个IP节点都有一个ARP表</li>
<li>ARP表：包括一些LAN节点IP&#x2F;MAC地址的映射</li>
</ul>
<p>&lt; IP address; MAC address; TTL&gt; </p>
<ul>
<li>TTL时间是指地址映射失效的时间</li>
<li>典型是20min</li>
</ul>
<p><strong>ARP协议：在同一个LAN (网络)</strong></p>
<ul>
<li>A要发送帧给B(B的IP地址已知)， 但B的MAC地址不在A的ARP表中</li>
<li>A广播包含B的IP地址的ARP查询包<ul>
<li>Dest MAC address &#x3D; FF-FF-FF-FF-FF-FF</li>
<li>LAN上的所有节点都会收到该查询包</li>
</ul>
</li>
<li>B接收到ARP包，回复A自己的MAC地址<ul>
<li>帧发送给A</li>
<li>用A的MAC地址（单播）</li>
</ul>
</li>
<li>A在自己的ARP表中，缓存IP-to-MAC地址映射关系，直到信息超时<ul>
<li>软状态: 靠定期刷新维持的系统状态</li>
<li>定期刷新周期之间维护的状态信息可能和原有系统不一致</li>
</ul>
</li>
<li>ARP是即插即用的<ul>
<li>节点自己创建ARP的表项</li>
<li>无需网络管理员的干预</li>
</ul>
</li>
</ul>
<p><strong>路由到其他LAN</strong><br>Walkthrough :发送数据报：由A通过R到B，假设A知道B的IP地址</p>
<ul>
<li>在R上有两个ARP表，分别对应两个LAN</li>
<li>在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110</li>
<li>在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B, etc</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021833202.png" alt="image-20221202183348052" style="zoom: 67%;" />

<p><strong>编址：路由到其他LAN</strong></p>
<ul>
<li>A创建数据报，源IP地址：A；目标IP地址：B </li>
<li>A创建一个链路层的帧，目标MAC地址是R，该帧包含A到B的IP数据报</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021835229.png" alt="image-20221202183537128" style="zoom:67%;" />


<ul>
<li>帧从A发送到R</li>
<li>帧被R接收到，从中提取出IP分组，交给上层IP协议实体</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021838477.png" alt="image-20221202183811360" style="zoom: 67%;" />


<ul>
<li>R转发数据报，数据报源IP地址为A，目标IP地址为B</li>
<li>R创建一个链路层的帧，目标MAC地址为B，帧中包含A到B的IP数据报</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021840499.png" alt="image-20221202184002402" style="zoom: 67%;" />


<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021841410.png" alt="image-20221202184108306"></p>
<p><strong>以太网</strong></p>
<ul>
<li>目前最主流的LAN技术：98%占有率</li>
<li>廉价：30元RMB 100Mbps！</li>
<li>最早广泛应用的LAN技术</li>
<li>比令牌网和ATM网络简单、廉价</li>
<li>带宽不断提升：10M, 100M, 1G, 10G</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212012132949.png" alt="image-20221201213207726" style="zoom: 50%;" />

<p><strong>以太网：物理拓扑</strong></p>
<ul>
<li>总线：在上个世纪90年代中期很流行<ul>
<li>所有节点在一个碰撞域内，一次只允许一个节点发送</li>
<li>可靠性差，如果介质破损，截面形成信号的反射，发送节点误认为是冲突，总是冲突</li>
</ul>
</li>
<li>星型：目前最主流</li>
<li>连接选择: hub 或者 switch</li>
<li>现在一般是交换机在中心</li>
<li>每个节点以及相连的交换机端口使用（独立的）以太网协议（不会和其他节点的发送产生碰撞）</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212012135126.png" alt="image-20221201213517999" style="zoom:50%;" />

<p><strong>以太帧结构</strong></p>
<p>发送方适配器在以太网帧中封装IP数据报， 或其他网络层协议数据单元</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212012137769.png" alt="image-20221201213705659" style="zoom:50%;" />

<p>前导码: </p>
<ul>
<li>7B 10101010 + 1B 10101011</li>
<li>用来同步接收方和发送方的时钟速率<ul>
<li>使得接收方将自己的时钟调到发送端的时钟</li>
<li>从而可以按照发送端的时钟来接收所发送的</li>
</ul>
</li>
<li>地址：6字节源MAC地址，目标MAC地址<ul>
<li>如：帧目标地址&#x3D;本站MAC地址，或是广播地址，接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
</li>
<li>类型：指出高层协(大多情况下是IP，但也支持其它网络层协议Novell IPX和AppleTalk)</li>
<li>CRC：在接收方校验<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212012138696.png" alt="image-20221201213851562" style="zoom:50%;" />

<p><strong>以太网：无连接、不可靠的服务</strong></p>
<ul>
<li>无连接：帧传输前，发送方和接收方之间没有握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul>
<li>递交给网络层的数据报流可能有gap</li>
<li>如上层使用像传输层TCP协议这样的rdt，gap会被补上(源主机，TCP实体)</li>
<li>否则，应用层就会看到gap</li>
</ul>
</li>
<li>以太网的MAC协议：采用二进制退避的CSMA&#x2F;CD介质访问控制形式</li>
</ul>
<p><strong>802.3 以太网标准：链路和物理层</strong></p>
<ul>
<li>很多不同的以太网标准<ul>
<li>相同的MAC协议（介质访问控制）和帧结构</li>
<li>不同的速率：2 Mbps、10 Mbps 、100 Mbps 、 1Gbps、 10G bps</li>
<li>不同的物理层标准</li>
<li>不同的物理层媒介：光纤，同轴电缆和双绞线</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021847874.png" alt="image-20221202184724742" style="zoom:50%;" />

<p><strong>以太网使用CSMA&#x2F;CD</strong></p>
<p>+没有时隙</p>
<ul>
<li>NIC如果侦听到其它NIC在发送就不发送：载波侦听carrier sense</li>
<li>发送时，适配器当侦听到其它适配器在发送就放弃对当前帧的发送，冲突检测collision detection</li>
<li>冲突后尝试重传，重传前适配器等待一个随机时间，随机访问random access</li>
</ul>
<p><strong>以太网CSMA&#x2F;CD算法</strong></p>
<ol>
<li>适配器获取数据报，创建帧</li>
<li>发送前：侦听信道CS<br>1)闲：开始传送帧<br>2)忙：一直等到闲再发送</li>
</ol>
<p>3.发送过程中，冲突检测CD<br>1)没有冲突:成功<br>2)检测到冲突:放弃,之后尝试重发</p>
<p>4.发送方适配器检测到冲突，除放弃外，还发送一个Jam信号，所有听到冲突的适配器也是如此<br>强化冲突：让所有站点都知道冲突</p>
<p>5.如果放弃，适配器进入指数退避状态在第m次失败后，适配器随机选择一个{0，1，2， ， 2^m-1}中K，等待K*512位时，然后转到步骤2 exponential backoff二进制指数退避算法</p>
<p>Jam Signal: 使其它发送方明确知道发生碰撞，48bits<br>Bit time: 10Mbps以太网1&#x2F;10M&#x3D;0.1us<br>对于K&#x3D; 1023，大约等50ms：最坏情况<br>1023<em>512</em>0.1us&#x3D;50ms<br>指数退避: </p>
<ul>
<li>目标：适配器试图适应当前负载，在一个变化的碰撞窗口中随机选择时间点尝试重发<ul>
<li>高负载：重传窗口时间大，减少冲突，但等待时间长</li>
<li>低负载：使得各站点等待时间少，但冲突概率大</li>
</ul>
</li>
<li>首次碰撞：在{0，1}选择K；延迟K*512位时</li>
<li>第2次碰撞：在{0，1，2， 3}选择K</li>
<li>第10次碰撞：在{0，1，2，3，……，1023}选择K</li>
</ul>
<p><strong>10BaseT and 100BaseT</strong></p>
<ul>
<li>100 Mbps 速率 也被称之为 “fast ethernet”</li>
<li>T代表双绞线</li>
<li>节点连接到HUB上: “star topology”物理上星型<ul>
<li>逻辑上总线型，盒中总线</li>
</ul>
</li>
<li>节点和HUB间的最大距离是100 m</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021854364.png" alt="image-20221202185420214" style="zoom:50%;" />

<p><strong>Hubs</strong></p>
<p>Hubs 本质上是物理层的中继器:</p>
<ul>
<li>从一个端口收，转发到所有其他端口</li>
<li>速率一致</li>
<li>没有帧的缓存</li>
<li>在hub端口上没有CSMA&#x2F;CD机制:适配器检测冲突</li>
<li>提供网络管理功能</li>
</ul>
<p><strong>Manchester 编码</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021856536.png" alt="image-20221202185603425"></p>
<ul>
<li>在 10BaseT中使用</li>
<li>每一个bit的位时中间有一个信号跳变</li>
<li>允许在接收方和发送方节点之间进行时钟同步<ul>
<li>节点间不需要集中的和全局的时钟</li>
</ul>
</li>
<li>10Mbps，使用20M带宽，效率50%</li>
<li>Hey, this is physical-layer stuff!</li>
</ul>
<p><strong>100BaseT中的4b5b编码</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212021856752.png" alt="image-20221202185643622" style="zoom:50%;" />

<p><strong>千兆以太网</strong></p>
<ul>
<li>采用标准的以太帧格式</li>
<li>允许点对点链路和共享广播信道</li>
<li>物理编码：8b10b编码</li>
<li>在共享模式，继续使用CSMA&#x2F;CD MAC技术，节点间需要较短距离以提高利用率</li>
<li>交换模式：全双工千兆可用于点对点链路<ul>
<li>站点使用专用信道，基本不会冲突，效率高</li>
<li>除非发往同一个目标</li>
</ul>
</li>
</ul>
<p><strong>IEEE 802.11 Wireless LAN</strong></p>
<ul>
<li>802.11b<ul>
<li>使用无需许可的2.4-5 GHz 频谱<ul>
<li>无绳电话和微波炉</li>
</ul>
</li>
<li>最高11 Mbps</li>
<li>在物理层采用直接序列扩频<br>direct sequence spread<br>spectrum (DSSS)<br>+所有的主机采用同样的序列码<br>不同：速率，物理层<br>相同：MAC, 帧格式</li>
</ul>
</li>
<li>802.11a<ul>
<li>更高频率5-6 GHz</li>
<li>最高54 Mbps</li>
<li>距离相对短，受多路径影响大</li>
</ul>
</li>
<li>802.11g<ul>
<li>频率2.4-5 GHz</li>
<li>最大54 Mbps</li>
<li>与802.11b向后兼容</li>
</ul>
</li>
<li>802.11n: 多天线MIMO<ul>
<li>频率2.4-5 GHz</li>
<li>最高200 Mbps</li>
</ul>
</li>
<li>所有的802.11标准都是用CSMA&#x2F;CA进行多路访问</li>
<li>所有的802.11标准都有基站模式和自组织网络模式</li>
</ul>
<p><strong>802.11 LAN 体系结构</strong></p>
<ul>
<li>无线主机与基站通信<ul>
<li>基站base station &#x3D; 接入点access point (AP)</li>
</ul>
</li>
<li>基础设施模式下的基本服务集Basic Service Set (BSS) (aka“cell”) 包括以下构件:<ul>
<li>无线主机</li>
<li>接入点(AP): 基站</li>
<li>自组织模式下：只有无线主机</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031627860.png" alt="image-20221203162705693" style="zoom:50%;" />

<p><strong>802.11: 信道与关联</strong></p>
<ul>
<li>802.11b: 2.4GHz-2.485GHz 频谱被分为11个相互不同的但是部分重叠的频段<ul>
<li>AP管理员为AP选择一个频率</li>
<li>可能的干扰: 邻居AP可能选择同样一个信道!</li>
</ul>
</li>
<li>主机: 必须在通信之前和AP建立associate<ul>
<li>扫描所有的信道，侦听包含AP SSID和MAC地址的信标帧<ul>
<li>主动扫描：主机发送探测，接受AP的响应</li>
<li>被动扫描</li>
</ul>
</li>
<li>选择希望关联的AP</li>
<li>可能需要执行鉴别（认证）[Chapter 8]<ul>
<li>基于MAC、用户名口令</li>
<li>通过AP的中继，使用RADIUS鉴别服务器进行身份鉴别</li>
</ul>
</li>
<li>将会执行DHCP获得IP地址和AP所在子网前缀</li>
</ul>
</li>
</ul>
<p><strong>802.11: 被动&#x2F;主动扫描</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031629367.png" alt="image-20221203162910214" style="zoom:50%;" />

<p>被动扫描<br>(1) AP发送信标帧<br>(2) 关联请求帧的发送：H1向拟关联的AP<br>(3) 关联响应帧的发送: AP向H1<br>主动扫描<br>(1) H1广播探测请求帧<br>(2) 自AP发送探测响应<br>(3) H1向选择的AP发送关联请求帧<br>(4) 选择的AP向H1发送关联的响应帧</p>
<p><strong>802.11 帧：地址</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031633574.png" alt="image-20221203163348442" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031634569.png" alt="image-20221203163415418" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031635050.png" alt="image-20221203163508897" style="zoom:50%;" />

<p><strong>Hub：集线器</strong></p>
<ul>
<li>网段(LAN segments) ：可以允许一个站点发送的网络范围<ul>
<li>在一个碰撞域，同时只允许一个站点在发送</li>
<li>如果有2个节点同时发送，则会碰撞</li>
<li>通常拥有相同的前缀，比IP子网更详细的前缀</li>
</ul>
</li>
<li>所有以hub连到一起的站点处在一个网段，处在一个碰撞域<ul>
<li>骨干hub将所有网段连到了一起</li>
</ul>
</li>
<li>通过hub可扩展节点之间的最大距离</li>
<li>通过HUB,不能将10BaseT和100BaseT的网络连</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031637861.png" alt="image-20221203163726714" style="zoom:50%;" />

<p><strong>交换机</strong></p>
<ul>
<li>链路层设备：扮演主动角色（端口执行以太网协议）<ul>
<li>对帧进行存储和转发</li>
<li>对于到来的帧，检查帧头，根据目标MAC地址进行选择性转发</li>
<li>当帧需要向某个（些）网段进行转发，需要使用CSMA&#x2F;CD进行接入控制</li>
<li>通常一个交换机端口一个独立网段</li>
</ul>
</li>
<li>透明：主机对交换机的存在可以不关心<ul>
<li>通过交换机相联的各节点好像这些站点是直接相联的一样</li>
<li>有MAC地址；无IP地址</li>
</ul>
</li>
<li>即插即用，自学习：<ul>
<li>交换机无需配置</li>
</ul>
</li>
</ul>
<p><strong>交换机：多路同时传输</strong></p>
<ul>
<li>主机有一个专用和直接到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入的链路使用以太网协议，没有碰撞；全双工<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
<li>交换：A-to-A’ 和 B-to-B’ 可以同时传输，没有碰撞</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031640163.png" alt="image-20221203164044002" style="zoom:50%;" />

<p><strong>交换机转发表</strong></p>
<blockquote>
<p>Q: 交换机如何知道通过接口1到达A，通过接口5到达 B’?</p>
</blockquote>
<ul>
<li>A: 每个交换机都有一个交6换表 switch table, 每个表项:<ul>
<li>(主机的MAC地址,到达该MAC经过的接口，时戳)</li>
<li>比较像路由表!<blockquote>
<p>Q: 每个表项是如何创建的？如何维护的?</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p> 有点像路由协议?</p>
<p><strong>交换机：自学习</strong></p>
<ul>
<li>交换机通过学习得到哪些主机（mac地址）可以通过哪些端口到达<ul>
<li>当接收到帧，交换机学习到发送站点所在的端口（网段）</li>
<li>记录发送方MAC地址&#x2F;进入端口映射关系，在交换表中</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031647058.png" alt="image-20221203164748916" style="zoom:50%;" />

<p><strong>交换机：过滤／转发</strong><br>当交换机收到一个帧:<br>1.记录进入链路，发送主机的MAC地址<br>2.使用目标MAC地址对交换表进行索引</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031650979.png" alt="image-20221203165003821" style="zoom:50%;" />

<p><strong>自学习，转发的例子</strong></p>
<ul>
<li>帧的目标： A’, 不知道其位置在哪：泛洪</li>
<li>知道目标A对应的链路：选择性发送到哪个端口</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031653024.png" alt="image-20221203165318889" style="zoom:50%;" />

<p><strong>交换机级联</strong></p>
<ul>
<li>交换机可被级联到一起</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031654342.png" alt="image-20221203165409189" style="zoom:50%;" />

<p>Q: A to G的发送 – 交换机S1如何知道经过从S4和S3最终达到F?<br>A: 自学习! (和在一个交换机联接所有站点一样!)</p>
<p><strong>VLANs: 动机</strong><br>考虑场景：</p>
<ul>
<li>CS用户搬到EE大楼办公室，但是希望连接到CS的交换机?<ul>
<li>接到多个交换机上</li>
<li>麻烦和浪费：96端口&#x2F;10个有用</li>
</ul>
</li>
<li>如果都接到一个交换机上，在一个广播域<ul>
<li>所有的层2广播流量(ARP, DHCP,不知道MAC地址对应端口的帧)都必须穿过整个LAN</li>
<li>安全性&#x2F;私密性的</li>
</ul>
</li>
</ul>
<p><strong>VLANs</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031743000.png" alt="image-20221203174341869" style="zoom:50%;" />

<p>基于端口的VLAN: 交换机端口成组( 通过交换机管理软件)，以至于单个的交换机可以分成若干虚拟LANs</p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031744166.png" alt="image-20221203174450006" style="zoom:50%;" />

<p><strong>基于端口的VLAN</strong></p>
<ul>
<li>流量隔离: 从&#x2F;到1-8端口的流量只会涉及到1-8<ul>
<li>也可以基于MAC地址进行VLAN定义</li>
</ul>
</li>
<li>动态成员: 成员可以在VLANs之间动态分配router</li>
<li>在VLANs间转发:通过路由器进行转发 (就像他们通过各自的交换机相联一样)<ul>
<li>实际操作中，设备生产商可以提供：交换机和路由器的单一设备</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212031746858.png" alt="image-20221203174623704" style="zoom: 67%;" />

<p><strong>VLANs 互联多个交换机</strong></p>
<ul>
<li>如果有多个交换机，希望它们相连并且共享VLANs信息</li>
<li>方法1：各交换机每个VLAN一个端口和另外交换机相应VLAN端口相连-&gt;扩展性问题</li>
<li>trunk port干线端口: 多个交换机共享定义的VLAN，在它们之间传输帧<ul>
<li>帧在不同交换机上的一个VLAN上转发，不能够再使用vanilla 802.1帧 (必须要携带VLAN ID信息)</li>
<li>802.1q协议增加&#x2F;移除附加的头部字段，用于在trun端口上进行帧的转发</li>
</ul>
</li>
</ul>
<p><strong>802.1Q VLAN 帧格式</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212032031174.png" alt="image-20221203203103998" style="zoom:50%;" />



<h3 id="链路虚拟化"><a href="#链路虚拟化" class="headerlink" title="链路虚拟化"></a>链路虚拟化</h3><p><strong>MPLS概述</strong></p>
<ul>
<li>从IP网络来看，将一组支持MPLS的网络虚拟成链路的技术</li>
<li>纯IP网络是按照IP地址对分组进行转发的<ul>
<li>前缀匹配，转发的方法固定</li>
<li>无法控制IP分组的路径，无法支持流连工程</li>
<li>也无法对一个IP分组流进行资源分配，性能无法保证</li>
</ul>
</li>
<li>MPLS网络按照标签label进行分组的转发<ul>
<li>类似于VC</li>
<li>有基于标签的转发表</li>
<li>基于虚电路表，IP vs 线路交换</li>
</ul>
</li>
<li>标签交换的过程：<ul>
<li>入口路由器:LER对进入的分组按照EFC的定义打上标签在MPLS网络中（虚拟成了链路）对分组按照标签进行交换</li>
<li>到了出口路由器，再将标签摘除</li>
<li>支持MPLS的路由器组构成的网络，从IP网络的角度来看虚拟成了链路</li>
</ul>
</li>
<li>标签封装：一些列标准定义了在ATM,FR和以太网中如何封装，利用原有网络中的机制VCI，或者定义新的标签</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212041123275.png" alt="image-20221204112340139" style="zoom:50%;" />

<ul>
<li>建立基于标签的转发表-信令协议：支持逐跳和显式路由：路由信息传播，路由计算(基于Qos，&#x3D;基于策略的)，标签分发<ul>
<li>LDP CR-LDP</li>
<li>RSVP扩展 BGP扩展</li>
</ul>
</li>
<li>MPLS优点<ul>
<li>路由弹性：基于Qos，基于策略的</li>
<li>充分利用已有的硬件ATM，快速转发</li>
<li>支持流连工程，VPN</li>
<li>支持带宽等资源的分配</li>
</ul>
</li>
</ul>
<p><strong>标签分发</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212041125956.png" alt="image-20221204112511818" style="zoom:50%;" />

<p><strong>Label Switched Path (LSP)</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212041126375.png" alt="image-20221204112612242" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212041126015.png" alt="image-20221204112642851" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212041127702.png" alt="image-20221204112749564" style="zoom: 50%;" />

<p><strong>Multiprotocol label switching (MPLS)</strong></p>
<ul>
<li>初始目的：使用固定长度的标签label进行高速率IP转发 (而不是使用IP address,采用最长前缀匹配)<ul>
<li>一开始采用固定长度ID进行查表 (而不是采用前缀匹配)</li>
<li>借鉴了虚电路的思想 (VC)</li>
<li>但是IP数据报仍然保留IP地址!</li>
<li>在帧和其封装的分组之间加入一个垫层，标签交换使能的路由器使用垫层信息进行分组转发，不解析分组目标地址</li>
</ul>
</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052142967.png" alt="image-20221205214253867" style="zoom:50%;" />

<p><strong>具有MPLS能力的路由器</strong></p>
<ul>
<li>a.k.a. 标签交换路由器</li>
<li>基于标签的值进行分组的转发 (而非检查IP地址)<ul>
<li>MPLS转发表和IP转发表相互独立</li>
</ul>
</li>
<li>弹性: MPLS转发决策可以和IP不同<ul>
<li>采用源地址和目标地址来路由到达同一个目标的流，不同路径（支持流量工程）</li>
<li>如果链路失效，能够快速重新路由: 预先计算好的备份链路 (对于VoIP有效)</li>
</ul>
</li>
</ul>
<p><strong>MPLS vs IP 路径</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052144072.png" alt="image-20221205214453976"></p>
<ul>
<li>IP 路由: 到达目标的路径仅仅取决 目标地址</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052145544.png" alt="image-20221205214540448"></p>
<ul>
<li>IP路由:到达目标的路径仅仅取决于目标地址</li>
<li>MPLS路由：到达目标的路由，可以基于源和目标地址<ul>
<li>快速重新路由：在链路失效时，采用预先计算好的路径</li>
</ul>
</li>
</ul>
<p><strong>MPLS 信令</strong></p>
<ul>
<li>修改OSPF, IS-IS链路状态泛洪协议来携带MPLS路由信息<ul>
<li>e.g., 链路带宽，链路带宽的倒数?</li>
</ul>
</li>
<li>MPLS使能的路由器采用RSVP-TE信令协议在下游路由器上来建立MPLS转发表</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052147840.png" alt="image-20221205214739750" style="zoom:50%;" />

<p><strong>MPLS 转发表</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052148912.png" alt="image-20221205214820816" style="zoom:50%;" />

<p><strong>数据中心网络</strong></p>
<ul>
<li>数万-数十万台主机构成DC网络，密集耦合、距离<br>临近:<ul>
<li>电子商务(e.g. Amazon)</li>
<li>内容服务器(e.g., YouTube, Akamai, Apple, Microsoft)</li>
<li>搜索引擎，数据挖掘 (e.g., Google)</li>
</ul>
</li>
<li>挑战:<ul>
<li>多种应用，每一种都服务海量的客户端</li>
<li>管理&#x2F;负载均衡，避免处理、网络和数据的瓶颈</li>
</ul>
</li>
</ul>
<p>负载均衡器: 应用层路由</p>
<ul>
<li>接受外部的客户端请求</li>
<li>将请求导入到数据中心内部</li>
<li>返回结果给外部客户端 (对于客户端隐藏数据中心的内部结构)</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052151732.png" alt="image-20221205215146641" style="zoom:50%;" />

<ul>
<li>在交换机之间，机器阵列之间有丰富的互连措施:<ul>
<li>在阵列之间增加吞吐 (多个可能的路由路径)</li>
<li>通过冗余度增加可靠</li>
</ul>
</li>
</ul>
<img src="C:/Users/mua/AppData/Roaming/Typora/typora-user-images/image-20221205215504807.png" alt="image-20221205215504807" style="zoom:50%;" />

<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052156626.png" alt="image-20221205215650522" style="zoom:67%;" />

<ul>
<li>笔记本需要一个IP地址，第一跳路由器的IP地址，DNS的地址: 采用DHCP</li>
<li>DHCP 请求被封装在UDP中，封装在IP, 封装在 802.3 以太网帧中</li>
<li>以太网的帧在LAN上广播(dest: FFFFFFFFFFFF), 被运行中的DHCP服务器接收到</li>
<li>以太网帧中解封装IP分组，解封装UDP，解封装DHCP</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052157739.png" alt="image-20221205215743644" style="zoom: 67%;" />

<ul>
<li>DHCP 服务器生成DHCP ACK 包括客户端IP地址，第一跳路由器IP地址和DNS名字服务器地址</li>
<li>在DHCP服务器封装, 帧通过LAN转发 (交换机学习) 在客户端段解封装</li>
<li>客户端接收DHCP ACK应答<br>客户端段解封装客户端有了IP地址，知道了DNS域名服务器的名字和IP地址第一跳路由器的IP地址</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052203616.png" alt="image-20221205220344524" style="zoom:67%;" />

<p><strong>ARP (DNS之前, HTTP之前)</strong></p>
<ul>
<li>在发送HTTP request请求之前, 需要知道 <a href="http://www.google.com/">www.google.com</a> 的IP: DNS</li>
<li>DNS查询被创建，封装在UDP段中，封装在IP数据报中，封装在以太网的帧中. 将帧传递给路由器，但是需要知道路由器的接口：<br>MAC地址：ARP</li>
<li>ARP查询广播，被路由器接收，路由器用ARP应答，给出其IP地址某个端口的MAC地址</li>
<li>客户端现在知道第一跳路由器MAC地址，所以可以发送DNS查询帧了</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052204827.png" alt="image-20221205220425731" style="zoom:67%;" />

<p><strong>使用DNS</strong></p>
<ul>
<li>包含了DNS查询的IP数据报通过LAN交换机转发，从客户端到第一跳路由器</li>
</ul>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052205861.png" alt="image-20221205220557772" style="zoom:50%;" />


<ul>
<li>IP 数据报被转发，从校园到达comcast网络，路由（路由表被RIP，OSPF，IS-IS 和&#x2F;或BGP协议创建）到DNS服务器</li>
<li>被DNS服务器解封装</li>
<li>DNS服务器回复给客户端：<a href="http://www.google.com/">www.google.com</a> 的IP地址</li>
</ul>
<p><strong>TCP连接携带HTTP报文</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052207544.png" alt="image-20221205220753436" style="zoom:67%;" />

<p><strong>HTTP请求和应答</strong></p>
<img src="https://cdn.staticaly.com/gh/Dreamin121/picgohub@master/imgs/202212052208350.png" alt="image-20221205220828239" style="zoom:67%;" />]]></content>
      <categories>
        <category>Base</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>computer network</tag>
      </tags>
  </entry>
</search>
